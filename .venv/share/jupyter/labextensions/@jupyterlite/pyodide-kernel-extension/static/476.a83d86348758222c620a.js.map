{"version":3,"file":"476.a83d86348758222c620a.js?v=a83d86348758222c620a","mappings":"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","sources":["webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/services/lib/contents/drivefs.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/services/lib/contents/emscripten.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { UUID } from '@lumino/coreutils';\nimport { DIR_MODE, SEEK_CUR, SEEK_END, instanceOfStream } from './emscripten';\nexport const DRIVE_SEPARATOR = ':';\nexport const BLOCK_SIZE = 4096;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        var _a;\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            try {\n                const file = this.fs.API.get(path);\n                stream.file = file;\n            }\n            catch (e) {\n                // If we're opening a file for writing and the file does not exist, create it! Otherwise, throw the proper error\n                // We need to do this because the current thread is thinking a file exist (isFile returns true)\n                // whilst it was actually deleted in the main thread\n                // if writing\n                const flags = (_a = stream.flags) !== null && _a !== void 0 ? _a : stream.shared.flags;\n                let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n                parsedFlags &= 0x1fff;\n                let needsWrite = true;\n                if (parsedFlags in flagNeedsWrite) {\n                    needsWrite = flagNeedsWrite[parsedFlags];\n                }\n                if (needsWrite) {\n                    stream.node = this.fs.node_ops.mknod(stream.node.parent, stream.node.name, stream.node.mode, 0);\n                    const file = this.fs.API.get(path);\n                    stream.file = file;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['ENOENT']);\n                }\n            }\n        }\n    }\n    close(stream) {\n        var _a;\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = (_a = stream.flags) !== null && _a !== void 0 ? _a : stream.shared.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n        }\n        stream.file = undefined;\n    }\n    read(stream, buffer, offset, length, position) {\n        if (length <= 0 ||\n            stream.file === undefined ||\n            position >= (stream.file.data.length || 0)) {\n            return 0;\n        }\n        const size = Math.min(stream.file.data.length - position, length);\n        buffer.set(stream.file.data.subarray(position, position + size), offset);\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        const now = Date.now();\n        stream.node.timestamp = now;\n        stream.node.atime = now;\n        stream.node.mtime = now;\n        stream.node.ctime = now;\n        if (position + length > (((_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) || 0)) {\n            const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n            stream.file.data = new Uint8Array(position + length);\n            stream.file.data.set(oldData);\n        }\n        stream.file.data.set(buffer.subarray(offset, offset + length), position);\n        return length;\n    }\n    llseek(stream, offset, whence) {\n        var _a;\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += (_a = stream.position) !== null && _a !== void 0 ? _a : stream.shared.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.node = (nodeOrStream) => {\n            if (instanceOfStream(nodeOrStream)) {\n                return nodeOrStream.node;\n            }\n            return nodeOrStream;\n        };\n        this.getattr = (value) => {\n            const node = this.node(value);\n            return {\n                ...this.fs.API.getattr(this.fs.realPath(node)),\n                mode: node.mode,\n                ino: node.id,\n            };\n        };\n        this.setattr = (value, attr) => {\n            const node = this.node(value);\n            for (const [key, value] of Object.entries(attr)) {\n                switch (key) {\n                    case 'mode':\n                        node.mode = value;\n                        break;\n                    case 'timestamp':\n                        node.timestamp = value;\n                        break;\n                    case 'atime':\n                        node.atime = value;\n                        break;\n                    case 'mtime':\n                        node.mtime = value;\n                        break;\n                    case 'ctime':\n                        node.ctime = value;\n                        break;\n                    case 'size': {\n                        const size = value;\n                        const path = this.fs.realPath(node);\n                        if (this.fs.FS.isFile(node.mode) && size >= 0) {\n                            let file;\n                            try {\n                                file = this.fs.API.get(path);\n                            }\n                            catch (e) {\n                                // TODO: Should do anything here? Should we create the file?\n                                break;\n                            }\n                            const oldData = file.data ? file.data : new Uint8Array();\n                            if (size !== oldData.length) {\n                                if (size < oldData.length) {\n                                    file.data = file.data.slice(0, size);\n                                }\n                                else {\n                                    file.data = new Uint8Array(size);\n                                    file.data.set(oldData);\n                                }\n                                this.fs.API.put(path, file);\n                            }\n                        }\n                        else {\n                            console.warn('setattr size of', size, 'on', node, 'not yet implemented');\n                        }\n                        break;\n                    }\n                    case 'dontFollow':\n                        // Ignore for now\n                        break;\n                    default:\n                        console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n                        break;\n                }\n            }\n        };\n        this.lookup = (parent, name) => {\n            const node = this.node(parent);\n            const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n            const result = this.fs.API.lookup(path);\n            if (!result.ok) {\n                throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['ENOENT']);\n            }\n            return this.fs.createNode(node, name, result.mode, 0);\n        };\n        this.mknod = (parent, name, mode, dev) => {\n            const node = this.node(parent);\n            const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n            this.fs.API.mknod(path, mode);\n            return this.fs.createNode(node, name, mode, dev);\n        };\n        this.rename = (value, newDir, newName) => {\n            const oldNode = this.node(value);\n            const newDirNode = this.node(newDir);\n            this.fs.API.rename(oldNode.parent\n                ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n                : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDirNode), newName));\n            // Updating the in-memory node\n            oldNode.name = newName;\n            oldNode.parent = newDirNode;\n        };\n        this.unlink = (parent, name) => {\n            return this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n        };\n        this.rmdir = (parent, name) => {\n            return this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n        };\n        this.readdir = (value) => {\n            return this.fs.API.readdir(this.fs.realPath(this.node(value)));\n        };\n        this.symlink = (parent, newName, oldPath) => {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        };\n        this.readlink = (node) => {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EINVAL']);\n        };\n        this.fs = fs;\n    }\n}\n/**\n * ContentsAPI base class\n */\nexport class ContentsAPI {\n    constructor(options) {\n        this._driveName = options.driveName;\n        this._mountpoint = options.mountpoint;\n        this.FS = options.FS;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return this.request({ method: 'getmode', path: this.normalizePath(path) });\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({\n            method: 'get',\n            path: this.normalizePath(path),\n        });\n        if (!response) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({\n            method: 'getattr',\n            path: this.normalizePath(path),\n        });\n        // Emscripten 4.0.9+ (used by Pyodide 0.28+) requires all three timestamps\n        // to be valid Date objects with .getTime() method (see https://github.com/emscripten-core/emscripten/pull/22998).\n        // Fallback to epoch if any timestamp is missing/null/undefined.\n        const defaultDate = new Date(0);\n        stats.atime = stats.atime ? new Date(stats.atime) : defaultDate;\n        stats.mtime = stats.mtime ? new Date(stats.mtime) : defaultDate;\n        stats.ctime = stats.ctime ? new Date(stats.ctime) : defaultDate;\n        // ensure a non-undefined size (0 isn't great, though)\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n}\n/**\n * An Emscripten-compatible synchronous Contents API using the service worker.\n */\nexport class ServiceWorkerContentsAPI extends ContentsAPI {\n    /**\n     * Construct a new ServiceWorkerContentsAPI.\n     */\n    constructor(options) {\n        super(options);\n        this._baseUrl = options.baseUrl;\n        this._browsingContextId = options.browsingContextId || '';\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        // Generate unique request ID for correlation\n        const requestId = UUID.uuid4();\n        // Add the origin browsing context ID and request ID to the request\n        const requestWithMetadata = {\n            data: { ...data, requestId },\n            browsingContextId: this._browsingContextId,\n            requestId,\n        };\n        try {\n            xhr.send(JSON.stringify(requestWithMetadata));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = this.createAPI(options);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    /**\n     * Create the ContentsAPI.\n     *\n     * This is supposed to be overwritten if needed.\n     */\n    createAPI(options) {\n        if (!options.browsingContextId || !options.baseUrl) {\n            throw new Error('Cannot create service-worker API without current browsingContextId');\n        }\n        return new ServiceWorkerContentsAPI(options);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n//# sourceMappingURL=drivefs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\nexport function instanceOfStream(nodeOrStream) {\n    return 'node' in nodeOrStream;\n}\n//# sourceMappingURL=emscripten.js.map"],"names":["encoder","TextEncoder","decoder","TextDecoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","constructor","fs","this","open","stream","_a","path","realPath","node","FS","isFile","mode","file","API","get","e","flags","shared","parsedFlags","parseInt","needsWrite","ErrnoError","ERRNO_CODES","node_ops","mknod","parent","name","close","put","undefined","read","buffer","offset","length","position","data","size","Math","min","set","subarray","write","now","Date","timestamp","atime","mtime","ctime","oldData","Uint8Array","llseek","whence","EPERM","EINVAL","DriveFSEmscriptenNodeOps","nodeOrStream","instanceOfStream","getattr","value","ino","id","setattr","attr","key","Object","entries","slice","console","warn","lookup","PATH","join2","result","ok","createNode","dev","rename","newDir","newName","oldNode","newDirNode","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","options","_driveName","driveName","_mountpoint","mountpoint","request","method","normalizePath","getmode","newPath","dirlist","push","response","serializedContent","content","format","encode","binString","atob","len","i","charCodeAt","decode","binary","byteLength","String","fromCharCode","btoa","stats","defaultDate","startsWith","ServiceWorkerContentsAPI","super","_baseUrl","baseUrl","_browsingContextId","browsingContextId","xhr","XMLHttpRequest","encodeURI","endpoint","requestId","UUID","uuid4","requestWithMetadata","send","JSON","stringify","error","status","parse","responseText","DriveFS","createAPI","stream_ops","Error","mount","DIR_MODE","isDir","getMode","parts","currentNode","reverse","join","apply"],"sourceRoot":""}