from collections.abc import Iterable, Iterator
from typing import Any, Self, TypeAlias, overload

import numpy as np
import optype as op
import optype.numpy as onp

from ._rotation import Rotation as Rotation

_Indexer: TypeAlias = op.CanIndex | onp.ToInt1D | slice

###

__all__ = ["RigidTransform"]

def normalize_dual_quaternion(dual_quat: onp.ArrayND[np.float64]) -> onp.ArrayND[np.float64]: ...
def _create_transformation_matrix(
    translations: onp.ToFloat1D | onp.ToFloat2D, rotation_matrices: onp.ToFloat2D | onp.ToFloat3D, single: bool
) -> onp.ArrayND[np.float64]: ...  # undocumented

class RigidTransform:
    @staticmethod
    def from_matrix(matrix: onp.ToFloat2D | onp.ToFloat3D) -> RigidTransform: ...
    @staticmethod
    def from_rotation(rotation: Rotation) -> RigidTransform: ...
    @staticmethod
    def from_translation(translation: onp.ToFloat1D | onp.ToFloat2D) -> RigidTransform: ...
    @staticmethod
    def from_components(translation: onp.ToFloat1D | onp.ToFloat2D, rotation: Rotation) -> RigidTransform: ...
    @staticmethod
    def from_exp_coords(exp_coords: onp.ToFloat1D | onp.ToFloat2D) -> RigidTransform: ...
    @staticmethod
    def from_dual_quat(dual_quat: onp.ToFloat1D | onp.ToFloat2D, *, scalar_first: bool = False) -> RigidTransform: ...
    @staticmethod
    def identity(num: int | None = None, *, shape: int | tuple[int, ...] | None = None) -> RigidTransform: ...
    @staticmethod
    def concatenate(transforms: RigidTransform | Iterable[RigidTransform]) -> RigidTransform: ...

    #
    def __init__(self, /, matrix: onp.ToFloat2D | onp.ToFloat3D, normalize: bool = True, copy: bool = True) -> None: ...
    def __len__(self, /) -> int: ...
    def __iter__(self, /) -> Iterator[RigidTransform]: ...
    def __getitem__(self, indexer: _Indexer, /) -> Self: ...
    def __setitem__(self, indexer: _Indexer, value: Self, /) -> None: ...
    def __mul__(self, other: Self, /) -> Self: ...
    def __pow__(self, n: onp.ToFloat, /) -> Self: ...

    #
    def as_matrix(self, /) -> onp.ArrayND[np.float64, tuple[int, int] | tuple[int, int, int]]: ...
    def as_components(self, /) -> tuple[onp.ArrayND[np.float64, tuple[int] | tuple[int, int]], Rotation]: ...
    def as_exp_coords(self, /) -> onp.ArrayND[np.float64, tuple[int] | tuple[int, int]]: ...
    def as_dual_quat(self, /, *, scalar_first: bool = False) -> onp.ArrayND[np.float64, tuple[int] | tuple[int, int]]: ...
    def inv(self, /) -> Self: ...
    def mean(self, weights: onp.ToFloat1D | None = None, axis: int | tuple[int, ...] | None = None) -> RigidTransform: ...

    #
    @overload
    def apply(self, /, vector: onp.ToFloatStrict1D, inverse: bool = False) -> onp.Array1D[np.float64]: ...
    @overload
    def apply(self, /, vector: onp.ToFloatStrict2D, inverse: bool = False) -> onp.Array2D[np.float64]: ...
    @overload
    def apply(
        self, /, vector: onp.ToFloat1D | onp.ToFloat2D, inverse: bool = False
    ) -> onp.ArrayND[np.float64, tuple[int] | tuple[Any, ...]]: ...

    #
    @property
    def rotation(self, /) -> Rotation: ...
    @property
    def translation(self, /) -> onp.ArrayND[np.float64, tuple[int] | tuple[int, int]]: ...
    @property
    def single(self, /) -> bool: ...
    @property
    def shape(self, /) -> tuple[int, ...]: ...
