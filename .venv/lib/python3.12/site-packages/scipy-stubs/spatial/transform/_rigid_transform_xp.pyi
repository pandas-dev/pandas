from _typeshed import Incomplete
from typing import Protocol, TypeVar, type_check_only

@type_check_only
class _HasArrayNamespace(Protocol):
    def __array_namespace__(self, /) -> Incomplete: ...

_ArrayT = TypeVar("_ArrayT", bound=_HasArrayNamespace)

###
# for the sake of simplicity, we assume that the array types do no include shape-typing information,
# and have the same input/output dtype

def from_matrix(matrix: _ArrayT, normalize: bool = True, copy: bool = True) -> _ArrayT: ...
def from_rotation(quat: _ArrayT) -> _ArrayT: ...
def from_translation(translation: _ArrayT) -> _ArrayT: ...
def from_components(translation: _ArrayT, quat: _ArrayT) -> _ArrayT: ...
def from_exp_coords(exp_coords: _ArrayT) -> _ArrayT: ...
def from_dual_quat(dual_quat: _ArrayT, *, scalar_first: bool = False) -> _ArrayT: ...
def as_exp_coords(matrix: _ArrayT) -> _ArrayT: ...
def as_dual_quat(matrix: _ArrayT, *, scalar_first: bool = False) -> _ArrayT: ...
def compose_transforms(tf_matrix: _ArrayT, other_tf_matrix: _ArrayT) -> _ArrayT: ...
def inv(matrix: _ArrayT) -> _ArrayT: ...
def apply(matrix: _ArrayT, vector: _ArrayT, inverse: bool = False) -> _ArrayT: ...
def pow(matrix: _ArrayT, n: float | _ArrayT) -> _ArrayT: ...
def mean(matrix: _ArrayT, weights: Incomplete | None = None, axis: int | tuple[int, ...] | None = None) -> _ArrayT: ...
def setitem(matrix: _ArrayT, indexer: Incomplete, value: _ArrayT) -> _ArrayT: ...
def normalize_dual_quaternion(dual_quat: _ArrayT) -> _ArrayT: ...
def _create_transformation_matrix(translations: _ArrayT, rotation_matrices: _ArrayT) -> _ArrayT: ...
def _compute_se3_exp_translation_transform(rot_vec: _ArrayT) -> _ArrayT: ...
def _compute_se3_log_translation_transform(rot_vec: _ArrayT) -> _ArrayT: ...
def _create_skew_matrix(vec: _ArrayT) -> _ArrayT: ...
def _normalize_dual_quaternion(real_part: _ArrayT, dual_part: _ArrayT) -> tuple[_ArrayT, _ArrayT]: ...
