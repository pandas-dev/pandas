from collections.abc import Sequence
from typing import Literal as L, Never, TypeAlias, overload
from typing_extensions import TypeVar, deprecated

import numpy as np
import numpy.typing as npt
import optype.numpy as onp
import optype.numpy.compat as npc

__all__ = [
    "block_diag",
    "circulant",
    "companion",
    "convolution_matrix",
    "dft",
    "fiedler",
    "fiedler_companion",
    "hadamard",
    "hankel",
    "helmert",
    "hilbert",
    "invhilbert",
    "invpascal",
    "leslie",
    "pascal",
    "toeplitz",
]

_ScalarT = TypeVar("_ScalarT", bound=np.generic)
_NumberT = TypeVar("_NumberT", bound=npc.number | np.object_)
_InexactT = TypeVar("_InexactT", bound=npc.inexact | np.object_)

_Kind: TypeAlias = L["symmetric", "upper", "lower"]
_ConvMode: TypeAlias = L["valid", "same", "full"]

_Bool2D: TypeAlias = onp.Array2D[np.bool_]
_Bool3D: TypeAlias = onp.Array3D[np.bool_]
_BoolND: TypeAlias = onp.ArrayND[np.bool_]
_Int2D: TypeAlias = onp.Array2D[np.int_]
_Int3D: TypeAlias = onp.Array3D[np.int_]
_IntND: TypeAlias = onp.ArrayND[np.int_]
_Float2D: TypeAlias = onp.Array2D[np.float64]
_Float3D: TypeAlias = onp.Array3D[np.float64]
_FloatND: TypeAlias = onp.ArrayND[np.float64]
_Complex2D: TypeAlias = onp.Array2D[np.complex128]
_Complex3D: TypeAlias = onp.Array3D[np.complex128]
_ComplexND: TypeAlias = onp.ArrayND[np.complex128]

_To0D: TypeAlias = onp.CanArray0[_ScalarT]
_To1D: TypeAlias = Sequence[_To0D[_ScalarT]] | onp.CanArrayND[_ScalarT]
_ToStrict1D: TypeAlias = Sequence[_To0D[_ScalarT]] | onp.CanArray1D[_ScalarT]
_ToStrict2ND: TypeAlias = onp.SequenceND[_To1D[_ScalarT]] | onp.CanArrayND[_ScalarT, onp.AtLeast2D]

_JustAnyShape: TypeAlias = tuple[Never, Never, Never, Never]  # workaround for https://github.com/microsoft/pyright/issues/10232

###

#
@overload
def toeplitz(
    c: onp.ArrayND[_ScalarT, _JustAnyShape], r: onp.ToArrayND[_ScalarT, _ScalarT] | None = None
) -> onp.ArrayND[_ScalarT]: ...
@overload
def toeplitz(c: list[bool], r: onp.ToBoolStrict1D | None = None) -> _Bool2D: ...  # type: ignore[overload-overlap]
@overload
def toeplitz(c: list[int], r: onp.ToArrayStrict1D[int, npc.integer] | None = None) -> _Int2D: ...
@overload
def toeplitz(c: list[float], r: onp.ToArrayStrict1D[float, npc.floating64] | None = None) -> _Float2D: ...
@overload
def toeplitz(c: list[complex], r: onp.ToArrayStrict1D[complex, npc.inexact64] | None = None) -> _Complex2D: ...
@overload
def toeplitz(
    c: onp.ToArrayStrict1D[_ScalarT, _ScalarT], r: onp.ToArrayStrict1D[_ScalarT, _ScalarT] | None = None
) -> onp.Array2D[_ScalarT]: ...
@overload
def toeplitz(c: Sequence[list[bool]], r: onp.ToBoolStrict1D | None = None) -> _Bool3D: ...  # type: ignore[overload-overlap]
@overload
def toeplitz(c: Sequence[list[int]], r: onp.ToArrayStrict1D[int, npc.integer] | None = None) -> _Int3D: ...
@overload
def toeplitz(c: Sequence[list[float]], r: onp.ToArrayStrict1D[float, npc.floating64] | None = None) -> _Float3D: ...
@overload
def toeplitz(c: Sequence[list[complex]], r: onp.ToArrayStrict1D[complex, npc.inexact64] | None = None) -> _Complex3D: ...
@overload
def toeplitz(
    c: onp.ToArrayStrict2D[_ScalarT, _ScalarT], r: onp.ToArrayStrict2D[_ScalarT, _ScalarT] | None = None
) -> onp.Array3D[_ScalarT]: ...
@overload
def toeplitz(c: onp.ToJustBoolND, r: onp.ToIntND | None = None) -> _BoolND: ...
@overload
def toeplitz(c: onp.ToJustInt64_ND, r: onp.ToIntND | None = None) -> _IntND: ...
@overload
def toeplitz(c: onp.ToJustFloat64_ND, r: onp.ToFloat64_ND | None = None) -> _FloatND: ...
@overload
def toeplitz(c: onp.ToJustComplex128_ND, r: onp.ToComplex128_ND | None = None) -> _ComplexND: ...
@overload
def toeplitz(
    c: onp.ToArrayND[_ScalarT, _ScalarT], r: onp.ToArrayND[_ScalarT, _ScalarT] | None = None
) -> onp.ArrayND[_ScalarT]: ...

# keep in sync with convolution_matrix
@overload
def circulant(c: onp.ArrayND[_ScalarT, _JustAnyShape]) -> onp.ArrayND[_ScalarT]: ...
@overload
def circulant(c: list[bool]) -> _Bool2D: ...  # type: ignore[overload-overlap]
@overload
def circulant(c: list[int]) -> _Int2D: ...
@overload
def circulant(c: list[float]) -> _Float2D: ...
@overload
def circulant(c: list[complex]) -> _Complex2D: ...
@overload
def circulant(c: onp.ToArrayStrict1D[_ScalarT, _ScalarT]) -> onp.Array2D[_ScalarT]: ...
@overload
def circulant(c: Sequence[list[bool]]) -> _Bool3D: ...  # type: ignore[overload-overlap]
@overload
def circulant(c: Sequence[list[int]]) -> _Int3D: ...
@overload
def circulant(c: Sequence[list[float]]) -> _Float3D: ...
@overload
def circulant(c: Sequence[list[complex]]) -> _Complex3D: ...
@overload
def circulant(c: onp.ToArrayStrict2D[_ScalarT, _ScalarT]) -> onp.Array3D[_ScalarT]: ...
@overload
def circulant(c: onp.ToJustBoolND) -> _BoolND: ...
@overload
def circulant(c: onp.ToJustInt64_ND) -> _IntND: ...
@overload
def circulant(c: onp.ToJustFloat64_ND) -> _FloatND: ...
@overload
def circulant(c: onp.ToJustComplex128_ND) -> _ComplexND: ...
@overload
def circulant(c: onp.ToArrayND[_ScalarT, _ScalarT]) -> onp.ArrayND[_ScalarT]: ...

# keep in sync with circulant
@overload
def convolution_matrix(a: onp.ArrayND[_ScalarT, _JustAnyShape], n: int, mode: _ConvMode = "full") -> onp.ArrayND[_ScalarT]: ...
@overload
def convolution_matrix(a: list[bool], n: int, mode: _ConvMode = "full") -> _Bool2D: ...  # type: ignore[overload-overlap]
@overload
def convolution_matrix(a: list[int], n: int, mode: _ConvMode = "full") -> _Int2D: ...
@overload
def convolution_matrix(a: list[float], n: int, mode: _ConvMode = "full") -> _Float2D: ...
@overload
def convolution_matrix(a: list[complex], n: int, mode: _ConvMode = "full") -> _Complex2D: ...
@overload
def convolution_matrix(a: onp.ToArrayStrict1D[_ScalarT, _ScalarT], n: int, mode: _ConvMode = "full") -> onp.Array2D[_ScalarT]: ...
@overload
def convolution_matrix(a: Sequence[list[bool]], n: int, mode: _ConvMode = "full") -> _Bool3D: ...  # type: ignore[overload-overlap]
@overload
def convolution_matrix(a: Sequence[list[int]], n: int, mode: _ConvMode = "full") -> _Int3D: ...
@overload
def convolution_matrix(a: Sequence[list[float]], n: int, mode: _ConvMode = "full") -> _Float3D: ...
@overload
def convolution_matrix(a: Sequence[list[complex]], n: int, mode: _ConvMode = "full") -> _Complex3D: ...
@overload
def convolution_matrix(a: onp.ToArrayStrict2D[_ScalarT, _ScalarT], n: int, mode: _ConvMode = "full") -> onp.Array3D[_ScalarT]: ...
@overload
def convolution_matrix(a: onp.ToJustBoolND, n: int, mode: _ConvMode = "full") -> _BoolND: ...
@overload
def convolution_matrix(a: onp.ToJustInt64_ND, n: int, mode: _ConvMode = "full") -> _IntND: ...
@overload
def convolution_matrix(a: onp.ToJustFloat64_ND, n: int, mode: _ConvMode = "full") -> _FloatND: ...
@overload
def convolution_matrix(a: onp.ToJustComplex128_ND, n: int, mode: _ConvMode = "full") -> _ComplexND: ...
@overload
def convolution_matrix(a: onp.ToArrayND[_ScalarT, _ScalarT], n: int, mode: _ConvMode = "full") -> onp.ArrayND[_ScalarT]: ...

#
@overload
def fiedler(a: onp.ArrayND[_NumberT, _JustAnyShape]) -> onp.ArrayND[_NumberT]: ...
@overload
def fiedler(a: list[int]) -> _Int2D: ...
@overload
def fiedler(a: list[float]) -> _Float2D: ...
@overload
def fiedler(a: list[complex]) -> _Complex2D: ...
@overload
def fiedler(a: onp.ToArrayStrict1D[_NumberT, _NumberT]) -> onp.Array2D[_NumberT]: ...
@overload
def fiedler(a: Sequence[list[int]]) -> _Int3D: ...
@overload
def fiedler(a: Sequence[list[float]]) -> _Float3D: ...
@overload
def fiedler(a: Sequence[list[complex]]) -> _Complex3D: ...
@overload
def fiedler(a: onp.ToArrayStrict2D[_NumberT, _NumberT]) -> onp.Array3D[_NumberT]: ...
@overload
def fiedler(a: onp.ToJustInt64_ND) -> _IntND: ...
@overload
def fiedler(a: onp.ToJustFloat64_ND) -> _FloatND: ...
@overload
def fiedler(a: onp.ToJustComplex128_ND) -> _ComplexND: ...
@overload
def fiedler(a: onp.ToArrayND[_NumberT, _NumberT]) -> onp.ArrayND[_NumberT]: ...

# keep in sync with fiedler_companion
@overload
def companion(a: onp.ArrayND[_InexactT, _JustAnyShape]) -> onp.ArrayND[_InexactT]: ...
@overload
def companion(a: onp.ToArrayStrict1D[_InexactT, _InexactT]) -> onp.Array2D[_InexactT]: ...
@overload
def companion(a: onp.ToArrayStrict2D[_InexactT, _InexactT]) -> onp.Array3D[_InexactT]: ...
@overload
def companion(a: onp.ToArrayND[_InexactT, _InexactT]) -> onp.ArrayND[_InexactT]: ...
@overload
def companion(a: onp.ArrayND[npc.integer, _JustAnyShape]) -> _FloatND: ...
@overload
def companion(a: Sequence[float] | onp.ToIntStrict1D) -> _Float2D: ...
@overload
def companion(a: Sequence[Sequence[float]] | onp.ToIntStrict2D) -> _Float3D: ...
@overload
def companion(a: Sequence[onp.SequenceND[float]] | onp.ToIntND) -> _FloatND: ...
@overload
def companion(a: list[complex]) -> _Complex2D: ...
@overload
def companion(a: Sequence[list[complex]]) -> _Complex3D: ...
@overload
def companion(a: onp.SequenceND[list[complex]]) -> _ComplexND: ...

# keep in sync with companion
@overload
def fiedler_companion(a: onp.ArrayND[_InexactT, _JustAnyShape]) -> onp.ArrayND[_InexactT]: ...
@overload
def fiedler_companion(a: onp.ToArrayStrict1D[_InexactT, _InexactT]) -> onp.Array2D[_InexactT]: ...
@overload
def fiedler_companion(a: onp.ToArrayStrict2D[_InexactT, _InexactT]) -> onp.Array3D[_InexactT]: ...
@overload
def fiedler_companion(a: onp.ToArrayND[_InexactT, _InexactT]) -> onp.ArrayND[_InexactT]: ...
@overload
def fiedler_companion(a: onp.ArrayND[npc.integer, _JustAnyShape]) -> _FloatND: ...
@overload
def fiedler_companion(a: Sequence[float] | onp.ToIntStrict1D) -> _Float2D: ...
@overload
def fiedler_companion(a: Sequence[Sequence[float]] | onp.ToIntStrict2D) -> _Float3D: ...
@overload
def fiedler_companion(a: Sequence[onp.SequenceND[float]] | onp.ToIntND) -> _FloatND: ...
@overload
def fiedler_companion(a: list[complex]) -> _Complex2D: ...
@overload
def fiedler_companion(a: Sequence[list[complex]]) -> _Complex3D: ...
@overload
def fiedler_companion(a: onp.SequenceND[list[complex]]) -> _ComplexND: ...

#
@overload
def leslie(f: onp.ToJustFloat64_1D, s: onp.ToFloat64_1D) -> _Float2D: ...
@overload
def leslie(f: onp.ToFloat64_1D, s: onp.ToJustFloat64_1D) -> _Float2D: ...
@overload
def leslie(f: onp.ToJustBool1D, s: onp.ToJustBool1D) -> _Bool2D: ...
@overload
def leslie(f: onp.ToJustInt64_1D, s: onp.ToInt1D) -> _Int2D: ...
@overload
def leslie(f: onp.ToInt1D, s: onp.ToJustInt64_1D) -> _Int2D: ...
@overload
def leslie(f: onp.ToJustComplex128_1D, s: onp.ToComplex128_1D) -> _Complex2D: ...
@overload
def leslie(f: onp.ToComplex128_1D, s: onp.ToJustComplex128_1D) -> _Complex2D: ...
@overload
def leslie(f: onp.ToArray1D[_ScalarT, _ScalarT], s: onp.ToArray1D[_ScalarT, _ScalarT]) -> onp.Array2D[_ScalarT]: ...

#
@overload
def block_diag(arr0: onp.ToJustFloat64_1D = ..., /, *arrs: onp.ToFloat64_1D) -> _Float2D: ...
@overload
def block_diag(arr0: onp.ToJustBool1D, /, *arrs: onp.ToBool1D) -> _Bool2D: ...
@overload
def block_diag(arr0: onp.ToJustInt64_1D, /, *arrs: onp.ToInt1D) -> _Int2D: ...
@overload
def block_diag(arr0: onp.ToJustComplex128_1D, /, *arrs: onp.ToComplex128_1D) -> _Complex2D: ...
@overload
def block_diag(arr0: onp.ToArray1D[_ScalarT, _ScalarT], /, *arrs: onp.ToArray1D[_ScalarT, _ScalarT]) -> onp.Array2D[_ScalarT]: ...

# `n` should probably be an int, but floats are also accepted in practice
def dft(n: onp.ToFloat, scale: L["sqrtn", "n"] | None = None) -> _Complex2D: ...

#
@overload
def hadamard(n: onp.ToInt, dtype: onp.AnyIntDType = ...) -> _Int2D: ...
@overload
def hadamard(n: onp.ToInt, dtype: onp.AnyFloat64DType) -> _Float2D: ...
@overload
def hadamard(n: onp.ToInt, dtype: onp.AnyComplex128DType) -> _Complex2D: ...
@overload
def hadamard(n: onp.ToInt, dtype: onp.AnyObjectDType) -> onp.Array2D[np.object_]: ...
@overload
def hadamard(n: onp.ToInt, dtype: onp.ToDType[_NumberT]) -> onp.Array2D[_NumberT]: ...
@overload
def hadamard(n: onp.ToInt, dtype: npt.DTypeLike) -> onp.Array2D: ...

#
@overload
def hankel(c: onp.ToJustIntStrict1D, r: onp.ToJustIntStrict1D | None = None) -> _Int2D: ...
@overload
def hankel(c: onp.ToJustFloatStrict1D, r: onp.ToJustFloatStrict1D | None = None) -> _Float2D: ...
@overload
def hankel(c: onp.ToJustComplexStrict1D, r: onp.ToJustComplexStrict1D | None = None) -> _Complex2D: ...
@overload
def hankel(c: _ToStrict1D[_ScalarT], r: _ToStrict1D[_ScalarT] | None = None) -> onp.Array2D[_ScalarT]: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: onp.ToJustIntND, r: onp.ToJustIntND | None = None) -> _Int2D: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: onp.ToJustFloatND, r: onp.ToJustFloatND | None = None) -> _Float2D: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: onp.ToJustComplexND, r: onp.ToJustComplexND | None = None) -> _Complex2D: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: _ToStrict2ND[_ScalarT], r: _ToStrict2ND[_ScalarT] | None = None) -> onp.Array2D[_ScalarT]: ...
@overload
def hankel(c: _To1D[_ScalarT], r: _To1D[_ScalarT] | None = None) -> onp.Array2D[_ScalarT]: ...

#
def helmert(n: onp.ToInt, full: bool = False) -> _Float2D: ...

#
def hilbert(n: onp.ToInt) -> _Float2D: ...

#
@overload
def invhilbert(n: onp.ToInt, exact: L[False] = False) -> _Float2D: ...
@overload
def invhilbert(n: onp.ToInt, exact: L[True]) -> onp.Array2D[np.int64 | np.object_]: ...

#
@overload
def pascal(n: onp.ToInt, kind: _Kind = "symmetric", exact: L[True] = True) -> onp.Array2D[np.int64 | np.object_]: ...
@overload
def pascal(n: onp.ToInt, kind: _Kind, exact: L[False]) -> _Float2D: ...
@overload
def pascal(n: onp.ToInt, kind: _Kind = "symmetric", *, exact: L[False]) -> _Float2D: ...

#
@overload
def invpascal(n: onp.ToInt, kind: _Kind = "symmetric", exact: L[True] = True) -> onp.Array2D[np.int64 | np.object_]: ...
@overload
def invpascal(n: onp.ToInt, kind: _Kind, exact: L[False]) -> _Float2D: ...
@overload
def invpascal(n: onp.ToInt, kind: _Kind = "symmetric", *, exact: L[False]) -> _Float2D: ...
