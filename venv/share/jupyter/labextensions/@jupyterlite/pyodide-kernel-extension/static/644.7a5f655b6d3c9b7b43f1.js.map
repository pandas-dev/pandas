{"version":3,"file":"644.7a5f655b6d3c9b7b43f1.js?v=7a5f655b6d3c9b7b43f1","mappings":"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","sources":["webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/licenses.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/pluginmanager.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/translation.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/statedb.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/tokens.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/workspaces.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/workspace-router.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/service-worker-manager.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/@jupyterlite/apputils/lib/service-worker.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Licenses } from '@jupyterlab/apputils';\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class LiteLicensesClient extends Licenses.LicensesClient {\n    /**\n     * A GET handler for the licenses\n     */\n    async getBundles() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Download the licenses in the requested format.\n     */\n    async download(options) {\n        const link = document.createElement('a');\n        link.href = await this._getDownloadLink(options);\n        const extension = options.format === 'markdown' ? 'md' : options.format;\n        link.download = `jupyterlite-licenses.${extension}`;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Get the download link for the requested format\n     */\n    async _getDownloadLink(options) {\n        const bundles = await this.getBundles();\n        let formattedData;\n        let mime;\n        // Format the data based on the requested format\n        switch (options.format) {\n            case 'json':\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n                break;\n            case 'markdown':\n                formattedData = this._formatAsMarkdown(bundles);\n                mime = 'text/markdown';\n                break;\n            case 'csv':\n                formattedData = this._formatAsCSV(bundles);\n                mime = 'text/csv';\n                break;\n            default:\n                // Fallback to JSON\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n        }\n        // Create a blob with the appropriate MIME type\n        const blob = new Blob([formattedData], { type: mime });\n        // Generate a URL for the blob\n        return URL.createObjectURL(blob);\n    }\n    /**\n     * Format license data as Markdown\n     */\n    _formatAsMarkdown(data) {\n        let md = '# Third-Party Licenses\\n\\n';\n        // Process each bundle\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            md += `## ${bundleName}\\n\\n`;\n            // Process packages in the bundle\n            for (const pkg of bundle.packages) {\n                md += `### ${pkg.name}${pkg.versionInfo ? ` ${pkg.versionInfo}` : ''}\\n\\n`;\n                if (pkg.licenseId) {\n                    md += `**License ID:** ${pkg.licenseId}\\n\\n`;\n                }\n                if (pkg.extractedText) {\n                    md += `\\`\\`\\`\\n${pkg.extractedText}\\n\\`\\`\\`\\n\\n`;\n                }\n            }\n        }\n        return md;\n    }\n    /**\n     * Format license data as CSV\n     */\n    _formatAsCSV(data) {\n        // CSV header\n        const headers = ['Bundle', 'Package', 'Version', 'License ID', 'License Text'];\n        let csv = `${headers.join(',')}\\n`;\n        // Process each bundle and package\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            for (const pkg of bundle.packages) {\n                const row = [\n                    this._escapeCSVField(bundleName),\n                    this._escapeCSVField(pkg.name),\n                    this._escapeCSVField(pkg.versionInfo || ''),\n                    this._escapeCSVField(pkg.licenseId || ''),\n                    this._escapeCSVField(pkg.extractedText || ''),\n                ];\n                csv += `${row.join(',')}\\n`;\n            }\n        }\n        return csv;\n    }\n    /**\n     * Escape a field for CSV output\n     */\n    _escapeCSVField(field) {\n        // If the field contains commas, quotes, or newlines, wrap it in quotes and escape any quotes\n        if (field && (field.includes(',') || field.includes('\"') || field.includes('\\n'))) {\n            return `\"${field.replace(/\"/g, '\"\"')}\"`;\n        }\n        return field;\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n//# sourceMappingURL=licenses.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PluginListModel } from '@jupyterlab/pluginmanager';\n/**\n * Custom PluginModel for use in JupyterLite\n */\nexport class LitePluginListModel extends PluginListModel {\n    /**\n     * Create a new PluginListModel.\n     */\n    constructor(options) {\n        super(options);\n        this._availablePlugins = options.pluginData.availablePlugins.map((plugin) => {\n            let tokenLabel = plugin.provides ? plugin.provides.name.split(':')[1] : undefined;\n            if (plugin.provides && !tokenLabel) {\n                tokenLabel = plugin.provides.name;\n            }\n            return {\n                ...plugin,\n                tokenLabel,\n                // keep all plugins locked and enabled for now until there is\n                // a way to enable/disable plugins in JupyterLite\n                locked: true,\n                enabled: true,\n            };\n        });\n    }\n    get available() {\n        return this._availablePlugins;\n    }\n    async refresh() {\n        // no-op\n    }\n    async enable(entry) {\n        // no-op\n    }\n    async disable(entry) {\n        // no-op\n    }\n}\n//# sourceMappingURL=pluginmanager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A fake locale to retrieve all the language packs.\n */\nconst ALL = 'all';\n/**\n * A class to fetch translation bundles.\n */\nexport class LiteTranslatorConnector extends DataConnector {\n    constructor() {\n        super(...arguments);\n        this._prevLocale = '';\n    }\n    async fetch(opts) {\n        var _a;\n        const language = (_a = opts === null || opts === void 0 ? void 0 : opts.language) !== null && _a !== void 0 ? _a : '';\n        // normalize the requested locale\n        let locale = language;\n        if (language === 'default') {\n            locale = 'en';\n        }\n        else if (language === '') {\n            locale = ALL;\n        }\n        const apiURL = URLExt.join(PageConfig.getBaseUrl(), `api/translations/${locale}.json`);\n        try {\n            const response = await fetch(apiURL);\n            const json = JSON.parse(await response.text());\n            if (this._prevLocale !== ALL && locale === ALL) {\n                // TODO: fix this logic upstream?\n                // the upstream translation plugin relies on the comparison between\n                // the display name and the native name to enable or disable the commands:\n                // https://github.com/jupyterlab/jupyterlab/blob/befa831ffef36321b87f352a48fbe2439df6c872/packages/translation-extension/src/index.ts#L117\n                const prev = this._prevLocale;\n                json.data[prev].displayName = json.data[prev].nativeName;\n                if (prev !== 'en') {\n                    json.data['en'].displayName = `${json.data['en'].nativeName} (default)`;\n                }\n            }\n            this._prevLocale = locale;\n            return json;\n        }\n        catch (e) {\n            if (locale) {\n                return {\n                    data: {},\n                    message: `Language pack '${locale}' not installed!`,\n                };\n            }\n            return {\n                data: {\n                    en: { displayName: 'English', nativeName: 'English' },\n                },\n                message: '',\n            };\n        }\n    }\n}\n//# sourceMappingURL=translation.js.map","import { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * A StateDB data connector backed by IndexedDB\n */\nexport class IndexedDBDataConnector {\n    /**\n     * Construct a new IndexedDBDataConnector.\n     *\n     * @param options - The options for the data connector.\n     */\n    constructor(options) {\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n        this.initialize().catch(console.warn);\n    }\n    /**\n     * Initialize the data connector.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this._ready.promise.then(() => this._storage);\n    }\n    /**\n     * Initialize storage instance\n     */\n    async initStorage() {\n        this._storage = this.createStorage();\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for StateDB',\n            storeName: 'statedb',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Fetch a value from the data connector.\n     *\n     * @param id - The identifier of the value to fetch.\n     *\n     * @returns A promise that resolves with the fetched value.\n     */\n    async fetch(id) {\n        const result = (await (await this.storage).getItem(id));\n        if (!result) {\n            throw new Error(`Failed to fetch id ${id} from StateDB`);\n        }\n        return result;\n    }\n    /**\n     * List all values in a namespace.\n     *\n     * @param namespace - The namespace to list values from. Defaults to ''.\n     *\n     * @returns A promise that resolves with the list of IDs and values.\n     */\n    async list(namespace = '') {\n        const storage = await this.storage;\n        const items = {};\n        for (const key of await storage.keys()) {\n            // Casting to string here, we know for sure the item is there\n            items[key] = (await storage.getItem(key));\n        }\n        const result = Object.keys(items).reduce((acc, val) => {\n            if (namespace === '' ? true : namespace === val.split(':')[0]) {\n                acc.ids.push(val);\n                acc.values.push(items[val]);\n            }\n            return acc;\n        }, { ids: [], values: [] });\n        return result;\n    }\n    /**\n     * Remove a value from the data connector.\n     *\n     * @param id - The identifier of the value to remove.\n     *\n     * @returns A promise that resolves when the value is removed.\n     */\n    async remove(id) {\n        await (await this.storage).removeItem(id);\n    }\n    /**\n     * Save a value to the data connector.\n     *\n     * @param id - The identifier of the value to save.\n     * @param value - The value to save.\n     *\n     * @returns A promise that resolves when the value is saved.\n     */\n    async save(id, value) {\n        await (await this.storage).setItem(id, value);\n    }\n}\n//# sourceMappingURL=statedb.js.map","import { Token } from '@lumino/coreutils';\nimport SW_URL from './service-worker?text';\n/**\n * The token for the ServiceWorker.\n */\nexport const IServiceWorkerManager = new Token('@jupyterlite/apputils:IServiceWorkerManager', 'The service worker manager');\nexport const WORKER_NAME = `${SW_URL}`.split('/').slice(-1)[0];\n//# sourceMappingURL=tokens.js.map","import { ServerConnection } from '@jupyterlab/services';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { IndexedDBDataConnector } from './statedb';\n/**\n * A workspace manager for workspaces stored in the browser and on the server.\n */\nexport class LiteWorkspaceManager extends IndexedDBDataConnector {\n    /**\n     * Construct a new LiteWorkspaceManager.\n     *\n     * @param options - The options for the workspace manager.\n     */\n    constructor(options) {\n        super({ ...options });\n        this._workspacesApiUrl = PageConfig.getOption('workspacesApiUrl') ||\n            URLExt.join(PageConfig.getBaseUrl(), 'api/workspaces');\n        this.serverSettings = options.settings || ServerConnection.makeSettings();\n    }\n    /**\n     * Fetch a workspace by id.\n     *\n     * @param id - The workspace id\n     * @returns A promise that resolves with the workspace\n     */\n    async fetch(id) {\n        // First try to get from local storage\n        try {\n            const localWorkspace = await super.fetch(id);\n            if (localWorkspace) {\n                return localWorkspace;\n            }\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspace from local storage:', error);\n        }\n        // Fall back to server\n        try {\n            const serverWorkspaces = await this._getServerWorkspaces();\n            if (serverWorkspaces[id]) {\n                return serverWorkspaces[id];\n            }\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspace from server:', error);\n        }\n        // If neither local nor server has the workspace, throw an error\n        throw new Error(`Workspace with id '${id}' not found`);\n    }\n    /**\n     * List all workspaces.\n     *\n     * @returns A promise that resolves with all workspace ids\n     */\n    async list() {\n        var _a;\n        let serverWorkspaces = {};\n        // Try to get server workspaces\n        try {\n            serverWorkspaces = await this._getServerWorkspaces();\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspaces from server:', error);\n        }\n        // Get local workspaces\n        const localResult = await super.list();\n        // Merge server and local workspaces, with local taking precedence for same IDs\n        const allWorkspaces = { ...serverWorkspaces };\n        for (const localWorkspace of localResult.values) {\n            if ((_a = localWorkspace.metadata) === null || _a === void 0 ? void 0 : _a.id) {\n                allWorkspaces[localWorkspace.metadata.id] = localWorkspace;\n            }\n        }\n        const ids = Object.keys(allWorkspaces);\n        const values = Object.values(allWorkspaces);\n        return { ids, values };\n    }\n    /**\n     * Clear all workspace data\n     *\n     * @returns A promise which resolves when the workspace data is cleared\n     */\n    async clear() {\n        await (await this.storage).clear();\n    }\n    /**\n     * Fetch all workspaces from the server\n     *\n     * @returns A promise that resolves with server workspaces\n     */\n    async _getServerWorkspaces() {\n        const workspacesUrl = URLExt.join(this._workspacesApiUrl, 'all.json');\n        const response = await fetch(workspacesUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch workspaces: ${response.status} ${response.statusText}`);\n        }\n        return await response.json();\n    }\n}\n//# sourceMappingURL=workspaces.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * A token to advertise the workspace router is installed\n */\nexport const IWorkspaceRouter = new Token('@jupyterlite/apputils:IWorkspaceRouter');\n//# sourceMappingURL=workspace-router.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { DriveContentsProcessor } from '@jupyterlite/services';\nimport { PromiseDelegate, UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { WORKER_NAME } from './tokens';\n/**\n * The service-worker broadcast channel id\n */\nexport const SERVICE_WORKER_BROADCAST_CHANNEL_ID = '/sw-api.v1';\n/**\n * The version of the app\n */\nconst VERSION = PageConfig.getOption('appVersion');\n/**\n * Used to keep the service worker alive\n */\nconst SW_PING_ENDPOINT = '/api/service-worker-heartbeat';\n/**\n * A class that manages the ServiceWorker registration and communication,\n * used for accessing the file system.\n */\nexport class ServiceWorkerManager {\n    /**\n     * Construct a new ServiceWorkerManager.\n     */\n    constructor(options) {\n        var _a;\n        /**\n         * Handle a message received on the BroadcastChannel\n         *\n         * Message data is `any` because it can either be a drive message of type `TDriveReqiest<T>`\n         * or a stdin message of type `any` as ServiceWorkerManager passes it through to the\n         * stdinHandler without understanding or altering it.\n         */\n        this._onBroadcastMessage = async (event) => {\n            const { data, browsingContextId, requestId, pathname } = event.data;\n            if (browsingContextId !== this._browsingContextId) {\n                // Message is not meant for us\n                return;\n            }\n            if (pathname.includes('/api/stdin/')) {\n                this._onStdinMessage(pathname, data);\n            }\n            else {\n                this._onDriveMessage(data, requestId);\n            }\n        };\n        this._onDriveMessage = async (data, requestId) => {\n            const response = await this._driveContentsProcessor.processDriveRequest(data);\n            // pass the browsingContextId and requestId along so the Service Worker can identify the request\n            this._broadcastChannel.postMessage({\n                response,\n                browsingContextId: this._browsingContextId,\n                requestId,\n            });\n        };\n        this._onStdinMessage = async (pathname, data) => {\n            // Expecting pathname of the form '<optional something>/api/stdin/<suffix>' from which\n            // suffix is used to identify which stdinHandler to call.\n            // `data: any` because ServiceWorkerManager accepts any data and passes it through\n            // to the stdinHandler without understanding or altering it.\n            const suffix = pathname.slice(pathname.lastIndexOf('/') + 1);\n            const stdinHandler = this._stdinHandlers.get(suffix);\n            if (stdinHandler !== undefined) {\n                const response = await stdinHandler(data);\n                this._broadcastChannel.postMessage({\n                    response,\n                    browsingContextId: this._browsingContextId,\n                });\n            }\n            else {\n                console.warn(`No stdin handler registered for '${pathname}'`);\n            }\n        };\n        this._registration = null;\n        this._registrationChanged = new Signal(this);\n        this._ready = new PromiseDelegate();\n        this._stdinHandlers = new Map();\n        const workerUrl = (_a = options.workerUrl) !== null && _a !== void 0 ? _a : URLExt.join(PageConfig.getBaseUrl(), WORKER_NAME);\n        const fullWorkerUrl = new URL(workerUrl, window.location.href);\n        const enableCache = PageConfig.getOption('enableServiceWorkerCache') || 'false';\n        fullWorkerUrl.searchParams.set('enableCache', enableCache);\n        // Initialize broadcast channel related properties\n        this._browsingContextId = UUID.uuid4();\n        this._contents = options.contents;\n        this._broadcastChannel = new BroadcastChannel(SERVICE_WORKER_BROADCAST_CHANNEL_ID);\n        this._broadcastChannel.addEventListener('message', this._onBroadcastMessage);\n        this._driveContentsProcessor = new DriveContentsProcessor({\n            contentsManager: this._contents,\n        });\n        void this._initialize(fullWorkerUrl.href).catch(console.warn);\n    }\n    /**\n     * A signal emitted when the registration changes.\n     */\n    get registrationChanged() {\n        return this._registrationChanged;\n    }\n    /**\n     * Whether the ServiceWorker is enabled or not.\n     */\n    get enabled() {\n        return this._registration !== null;\n    }\n    /**\n     * A unique id to identify the browsing context where the ServiceWorkerManager was instantiated.\n     */\n    get browsingContextId() {\n        return this._browsingContextId;\n    }\n    /**\n     * Whether the ServiceWorker is ready or not.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Register a handler for stdin requests received via ServiceWorker.\n     * @param pathnameSuffix URL pathname suffix to match such as \"kernel\" or \"terminal\".\n     * @param stdinHandler\n     */\n    registerStdinHandler(pathnameSuffix, stdinHandler) {\n        this._stdinHandlers.set(pathnameSuffix, stdinHandler);\n    }\n    /**\n     * Initialize the ServiceWorkerManager.\n     */\n    async _initialize(workerUrl) {\n        const { serviceWorker } = navigator;\n        let registration = null;\n        if (!serviceWorker) {\n            console.warn('ServiceWorkers not supported in this browser');\n            return;\n        }\n        else if (serviceWorker.controller) {\n            const scriptURL = serviceWorker.controller.scriptURL;\n            await this._unregisterOldServiceWorkers(scriptURL);\n            registration = (await serviceWorker.getRegistration(scriptURL)) || null;\n            // eslint-disable-next-line no-console\n            console.info('JupyterLite ServiceWorker was already registered');\n        }\n        if (!registration && serviceWorker) {\n            try {\n                // eslint-disable-next-line no-console\n                console.info('Registering new JupyterLite ServiceWorker', workerUrl);\n                registration = await serviceWorker.register(workerUrl);\n                // eslint-disable-next-line no-console\n                console.info('JupyterLite ServiceWorker was sucessfully registered');\n            }\n            catch (err) {\n                console.warn(err);\n                console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${err}`);\n            }\n        }\n        this._setRegistration(registration);\n        if (!registration) {\n            this._ready.reject(void 0);\n        }\n        else {\n            this._ready.resolve(void 0);\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    /**\n     * Unregister old service workers if the version has changed.\n     */\n    async _unregisterOldServiceWorkers(scriptURL) {\n        const versionKey = `${scriptURL}-version`;\n        // Check if we have an installed version. If we do, compare it to the current version\n        // and unregister all service workers if they are different.\n        const installedVersion = localStorage.getItem(versionKey);\n        if ((installedVersion && installedVersion !== VERSION) || !installedVersion) {\n            // eslint-disable-next-line no-console\n            console.info('New version, unregistering existing service workers.');\n            const registrations = await navigator.serviceWorker.getRegistrations();\n            await Promise.all(registrations.map((registration) => registration.unregister()));\n            // eslint-disable-next-line no-console\n            console.info('All existing service workers have been unregistered.');\n        }\n        localStorage.setItem(versionKey, VERSION);\n    }\n    /**\n     * Ping the service worker to keep it alive.\n     */\n    async _pingServiceWorker() {\n        const response = await fetch(SW_PING_ENDPOINT);\n        const text = await response.text();\n        if (text === 'ok') {\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    /**\n     * Set the registration and emit a signal.\n     */\n    _setRegistration(registration) {\n        this._registration = registration;\n        this._registrationChanged.emit(this._registration);\n    }\n}\n//# sourceMappingURL=service-worker-manager.js.map","\"use strict\";\n/**\n * The name of the cache\n */\nconst CACHE = 'precache';\n/**\n * Communication channel with the main thread\n */\nconst broadcast = new BroadcastChannel('/sw-api.v1');\n/**\n * Whether to enable the cache\n */\nlet enableCache = false;\n/**\n * Install event listeners\n */\nself.addEventListener('install', onInstall);\nself.addEventListener('activate', onActivate);\nself.addEventListener('fetch', onFetch);\n// Event handlers\n/**\n * Handle installation with the cache\n */\nfunction onInstall(event) {\n    void self.skipWaiting();\n    event.waitUntil(cacheAll());\n}\n/**\n * Handle activation.\n */\nfunction onActivate(event) {\n    // check if we should enable the cache\n    const searchParams = new URL(location.href).searchParams;\n    enableCache = searchParams.get('enableCache') === 'true';\n    event.waitUntil(self.clients.claim());\n}\n/**\n * Handle fetching a single resource.\n */\nasync function onFetch(event) {\n    const { request } = event;\n    const url = new URL(event.request.url);\n    if (url.pathname === '/api/service-worker-heartbeat') {\n        event.respondWith(new Response('ok'));\n        return;\n    }\n    let responsePromise = null;\n    if (shouldBroadcast(url)) {\n        responsePromise = broadcastOne(request, url);\n    }\n    else if (!shouldDrop(request, url)) {\n        responsePromise = maybeFromCache(event);\n    }\n    if (responsePromise) {\n        event.respondWith(responsePromise);\n    }\n}\n// utilities\n/** Get a cached response, and update cache. */\nasync function maybeFromCache(event) {\n    const { request } = event;\n    if (!enableCache) {\n        return await fetch(request);\n    }\n    let response = await fromCache(request);\n    if (response) {\n        event.waitUntil(refetch(request));\n    }\n    else {\n        response = await fetch(request);\n        event.waitUntil(updateCache(request, response.clone()));\n    }\n    return response;\n}\n/**\n * Restore a response from the cache based on the request.\n */\nasync function fromCache(request) {\n    const cache = await openCache();\n    const response = await cache.match(request);\n    if (!response || response.status === 404) {\n        return null;\n    }\n    return response;\n}\n/**\n * This is where we call the server to get the newest version of the\n * file to use the next time we show view\n */\nasync function refetch(request) {\n    const fromServer = await fetch(request);\n    await updateCache(request, fromServer);\n    return fromServer;\n}\n/**\n * Whether a given URL should be broadcast\n */\nfunction shouldBroadcast(url) {\n    return (url.origin === location.origin &&\n        (url.pathname.includes('/api/drive') || url.pathname.includes('/api/stdin/')));\n}\n/**\n * Whether the fallback behavior should be used\n */\nfunction shouldDrop(request, url) {\n    return (request.method !== 'GET' ||\n        url.origin.match(/^http/) === null ||\n        url.pathname.includes('/api/'));\n}\n/**\n * Forward request to main using the broadcast channel\n */\nasync function broadcastOne(request, url) {\n    const message = await request.json();\n    const promise = new Promise((resolve) => {\n        const messageHandler = (event) => {\n            const data = event.data;\n            // Match both browsingContextId AND requestId to ensure correct correlation\n            if (data.browsingContextId !== message.browsingContextId ||\n                data.requestId !== message.requestId) {\n                // bail if the message is not for us\n                return;\n            }\n            const response = data.response;\n            resolve(new Response(JSON.stringify(response)));\n            broadcast.removeEventListener('message', messageHandler);\n        };\n        broadcast.addEventListener('message', messageHandler);\n    });\n    // Add URL pathname to message\n    message.pathname = url.pathname;\n    broadcast.postMessage(message);\n    return await promise;\n}\nasync function openCache() {\n    return await caches.open(CACHE);\n}\n/**\n * Cache a request/response pair.\n */\nasync function updateCache(request, response) {\n    const cache = await openCache();\n    return cache.put(request, response);\n}\n/**\n * Add all to the cache\n *\n * this is where we should (try to) add all relevant files\n */\nasync function cacheAll() {\n    const cache = await openCache();\n    return await cache.addAll([]);\n}\n//# sourceMappingURL=service-worker.js.map"],"names":["THIRD_PARTY_LICENSES","EMPTY_BUNDLE","Object","freeze","packages","LiteLicensesClient","Licenses","LicensesClient","getBundles","bundles","this","_getFederated","appName","_getAppLicenses","download","options","link","document","createElement","href","_getDownloadLink","extension","format","body","appendChild","click","removeChild","PageConfig","getOption","appLicensesUrl","URLExt","join","getBaseUrl","labExtensionsUrl","formattedData","mime","JSON","stringify","_formatAsMarkdown","_formatAsCSV","blob","Blob","type","URL","createObjectURL","data","md","bundleName","bundle","entries","pkg","name","versionInfo","licenseId","extractedText","csv","_escapeCSVField","field","includes","replace","fetch","json","err","console","warn","federated","parse","promises","ext","push","_getOneFederated","Promise","all","url","response","LitePluginListModel","PluginListModel","constructor","super","_availablePlugins","pluginData","availablePlugins","map","plugin","tokenLabel","provides","split","undefined","locked","enabled","available","refresh","enable","entry","disable","ALL","LiteTranslatorConnector","DataConnector","arguments","_prevLocale","opts","_a","language","locale","apiURL","text","prev","displayName","nativeName","e","message","en","DEFAULT_STORAGE_NAME","IndexedDBDataConnector","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","initialize","catch","initStorage","resolve","storage","promise","then","_storage","createStorage","defaultStorageOptions","driver","length","version","createInstance","description","storeName","id","result","getItem","Error","list","namespace","items","key","keys","reduce","acc","val","ids","values","remove","removeItem","save","value","setItem","IServiceWorkerManager","Token","WORKER_NAME","slice","LiteWorkspaceManager","_workspacesApiUrl","serverSettings","settings","ServerConnection","makeSettings","localWorkspace","error","serverWorkspaces","_getServerWorkspaces","localResult","allWorkspaces","metadata","clear","workspacesUrl","ok","status","statusText","IWorkspaceRouter","SERVICE_WORKER_BROADCAST_CHANNEL_ID","VERSION","ServiceWorkerManager","_onBroadcastMessage","async","event","browsingContextId","requestId","pathname","_browsingContextId","_onStdinMessage","_onDriveMessage","_driveContentsProcessor","processDriveRequest","_broadcastChannel","postMessage","suffix","lastIndexOf","stdinHandler","_stdinHandlers","get","_registration","_registrationChanged","Signal","Map","workerUrl","fullWorkerUrl","window","location","enableCache","searchParams","set","UUID","uuid4","_contents","contents","BroadcastChannel","addEventListener","DriveContentsProcessor","contentsManager","_initialize","registrationChanged","ready","registerStdinHandler","pathnameSuffix","serviceWorker","navigator","registration","controller","scriptURL","_unregisterOldServiceWorkers","getRegistration","info","register","_setRegistration","setTimeout","_pingServiceWorker","reject","versionKey","installedVersion","localStorage","registrations","getRegistrations","unregister","emit","CACHE","broadcast","openCache","caches","open","updateCache","request","put","self","skipWaiting","waitUntil","cache","addAll","cacheAll","clients","claim","respondWith","Response","responsePromise","origin","shouldBroadcast","method","match","shouldDrop","fromCache","fromServer","refetch","clone","maybeFromCache","messageHandler","removeEventListener","broadcastOne"],"sourceRoot":""}