{"version":3,"file":"304.fed478b20183b113f417.js?v=fed478b20183b113f417","mappings":"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","sources":["webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/proxy-target/esm/types.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/coincident/esm/channel.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/coincident/esm/bridge.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/coincident/esm/index.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/proxy-target/esm/traps.js","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/comlink/dist/esm/comlink.mjs","webpack://@jupyterlite/pyodide-kernel-extension/../../node_modules/process/browser.js"],"sourcesContent":["export const ARRAY     = 'array';\nexport const BIGINT    = 'bigint';\nexport const BOOLEAN   = 'boolean';\nexport const FUNCTION  = 'function';\nexport const NULL      = 'null';\nexport const NUMBER    = 'number';\nexport const OBJECT    = 'object';\nexport const STRING    = 'string';\nexport const SYMBOL    = 'symbol';\nexport const UNDEFINED = 'undefined';\n","// ⚠️ AUTOMATICALLY GENERATED - DO NOT CHANGE\nexport const CHANNEL = '64e10b34-2bf7-4616-9668-f99de5aa046e';\n\nexport const MAIN = 'M' + CHANNEL;\nexport const THREAD = 'T' + CHANNEL;\n","// The goal of this file is to normalize SAB\n// at least in main -> worker() use cases.\n// This still cannot possibly solve the sync\n// worker -> main() use case if SharedArrayBuffer\n// is not available or usable.\n\nimport {CHANNEL} from './channel.js';\n\nconst {isArray} = Array;\n\nlet {SharedArrayBuffer, window} = globalThis;\nlet {notify, wait, waitAsync} = Atomics;\nlet postPatched = null;\n\n// This is needed for some version of Firefox\nif (!waitAsync) {\n  waitAsync = buffer => ({\n    value: new Promise(onmessage => {\n      // encodeURIComponent('onmessage=({data:b})=>(Atomics.wait(b,0),postMessage(0))')\n      let w = new Worker('data:application/javascript,onmessage%3D(%7Bdata%3Ab%7D)%3D%3E(Atomics.wait(b%2C0)%2CpostMessage(0))');\n      w.onmessage = onmessage;\n      w.postMessage(buffer);\n    })\n  });\n}\n\n// Monkey-patch SharedArrayBuffer if needed\ntry {\n  new SharedArrayBuffer(4);\n}\ncatch (_) {\n  SharedArrayBuffer = ArrayBuffer;\n\n  const ids = new WeakMap;\n  // patch only main -> worker():async use case\n  if (window) {\n    const resolvers = new Map;\n    const {prototype: {postMessage}} = Worker;\n\n    const listener = event => {\n      const details = event.data?.[CHANNEL];\n      if (!isArray(details)) {\n        event.stopImmediatePropagation();\n        const { id, sb } = details;\n        resolvers.get(id)(sb);\n      }\n    };\n\n    postPatched = function (data, ...rest) {\n      const details = data?.[CHANNEL];\n      if (isArray(details)) {\n        const [id, sb] = details;\n        ids.set(sb, id);\n        this.addEventListener('message', listener);\n      }\n      return postMessage.call(this, data, ...rest);\n    };\n\n    waitAsync = sb => ({\n      value: new Promise(resolve => {\n        resolvers.set(ids.get(sb), resolve);\n      }).then(buff => {\n        resolvers.delete(ids.get(sb));\n        ids.delete(sb);\n        for (let i = 0; i < buff.length; i++) sb[i] = buff[i];\n        return 'ok';\n      })\n    });\n  }\n  else {\n    const as = (id, sb) => ({[CHANNEL]: { id, sb }});\n\n    notify = sb => {\n      postMessage(as(ids.get(sb), sb));\n    };\n\n    addEventListener('message', event => {\n      const details = event.data?.[CHANNEL];\n      if (isArray(details)) {\n        const [id, sb] = details;\n        ids.set(sb, id);\n      }\n    });\n  }\n}\n\nexport {SharedArrayBuffer, isArray, notify, postPatched, wait, waitAsync};\n","/*! (c) Andrea Giammarchi - ISC */\n\nimport {FUNCTION} from 'proxy-target/types';\n\nimport {CHANNEL} from './channel.js';\nimport {GET, HAS, SET} from './shared/traps.js';\n\nimport {SharedArrayBuffer, isArray, notify, postPatched, wait, waitAsync} from './bridge.js';\n\n// just minifier friendly for Blob Workers' cases\nconst {Int32Array, Map, Uint16Array} = globalThis;\n\n// common constants / utilities for repeated operations\nconst {BYTES_PER_ELEMENT: I32_BYTES} = Int32Array;\nconst {BYTES_PER_ELEMENT: UI16_BYTES} = Uint16Array;\n\nconst waitInterrupt = (sb, delay, handler) => {\n  while (wait(sb, 0, 0, delay) === 'timed-out')\n    handler();\n};\n\n// retain buffers to transfer\nconst buffers = new WeakSet;\n\n// retain either main threads or workers global context\nconst context = new WeakMap;\n\nconst syncResult = {value: {then: fn => fn()}};\n\n// used to generate a unique `id` per each worker `postMessage` \"transaction\"\nlet uid = 0;\n\n/**\n * @typedef {Object} Interrupt used to sanity-check interrupts while waiting synchronously.\n * @prop {function} [handler] a callback invoked every `delay` milliseconds.\n * @prop {number} [delay=42] define `handler` invokes in terms of milliseconds.\n */\n\n/**\n * Create once a `Proxy` able to orchestrate synchronous `postMessage` out of the box.\n * @param {globalThis | Worker} self the context in which code should run\n * @param {{parse: (serialized: string) => any, stringify: (serializable: any) => string, transform?: (value:any) => any, interrupt?: () => void | Interrupt}} [JSON] an optional `JSON` like interface to `parse` or `stringify` content with extra `transform` ability.\n * @returns {ProxyHandler<globalThis> | ProxyHandler<Worker>}\n */\nconst coincident = (self, {parse = JSON.parse, stringify = JSON.stringify, transform, interrupt} = JSON) => {\n  // create a Proxy once for the given context (globalThis or Worker instance)\n  if (!context.has(self)) {\n    // ensure no SAB gets a chance to pass through this call\n    const sendMessage = postPatched || self.postMessage;\n    // ensure the CHANNEL and data are posted correctly\n    const post = (transfer, ...args) => sendMessage.call(self, {[CHANNEL]: args}, {transfer});\n\n    const handler = typeof interrupt === FUNCTION ? interrupt : interrupt?.handler;\n    const delay = interrupt?.delay || 42;\n    const decoder = new TextDecoder('utf-16');\n\n    // automatically uses sync wait (worker -> main)\n    // or fallback to async wait (main -> worker)\n    const waitFor = (isAsync, sb) => isAsync ?\n      waitAsync(sb, 0) :\n      ((handler ? waitInterrupt(sb, delay, handler) : wait(sb, 0)), syncResult);\n\n    // prevent Harakiri https://github.com/WebReflection/coincident/issues/18\n    let seppuku = false;\n\n    context.set(self, new Proxy(new Map, {\n      // there is very little point in checking prop in proxy for this very specific case\n      // and I don't want to orchestrate a whole roundtrip neither, as stuff would fail\n      // regardless if from Worker we access non existent Main callback, and vice-versa.\n      // This is here mostly to guarantee that if such check is performed, at least the\n      // get trap goes through and then it's up to developers guarantee they are accessing\n      // stuff that actually exists elsewhere.\n      [HAS]: (_, action) => typeof action === 'string' && !action.startsWith('_'),\n\n      // worker related: get any utility that should be available on the main thread\n      [GET]: (_, action) => action === 'then' ? null : ((...args) => {\n        // transaction id\n        const id = uid++;\n\n        // first contact: just ask for how big the buffer should be\n        // the value would be stored at index [1] while [0] is just control\n        let sb = new Int32Array(new SharedArrayBuffer(I32_BYTES * 2));\n\n        // if a transfer list has been passed, drop it from args\n        let transfer = [];\n        if (buffers.has(args.at(-1) || transfer))\n          buffers.delete(transfer = args.pop());\n\n        // ask for invoke with arguments and wait for it\n        post(transfer, id, sb, action, transform ? args.map(transform) : args);\n\n        // helps deciding how to wait for results\n        const isAsync = self !== globalThis;\n\n        // warn users about possible deadlock still allowing them\n        // to explicitly `proxy.invoke().then(...)` without blocking\n        let deadlock = 0;\n        if (seppuku && isAsync)\n          deadlock = setTimeout(console.warn, 1000, `💀🔒 - Possible deadlock if proxy.${action}(...args) is awaited`);\n\n        return waitFor(isAsync, sb).value.then(() => {\n          clearTimeout(deadlock);\n\n          // commit transaction using the returned / needed buffer length\n          const length = sb[1];\n\n          // filter undefined results\n          if (!length) return;\n\n          // calculate the needed ui16 bytes length to store the result string\n          const bytes = UI16_BYTES * length;\n\n          // round up to the next amount of bytes divided by 4 to allow i32 operations\n          sb = new Int32Array(new SharedArrayBuffer(bytes + (bytes % I32_BYTES)));\n\n          // ask for results and wait for it\n          post([], id, sb);\n          return waitFor(isAsync, sb).value.then(() => parse(\n            decoder.decode(new Uint16Array(sb.buffer).slice(0, length)))\n          );\n        });\n      }),\n\n      // main thread related: react to any utility a worker is asking for\n      [SET](actions, action, callback) {\n        const type = typeof callback;\n        if (type !== FUNCTION)\n          throw new Error(`Unable to assign ${action} as ${type}`);\n        // lazy event listener and logic handling, triggered once by setters actions\n        if (!actions.size) {\n          // maps results by `id` as they are asked for\n          const results = new Map;\n          // add the event listener once (first defined setter, all others work the same)\n          self.addEventListener('message', async (event) => {\n            // grub the very same library CHANNEL; ignore otherwise\n            const details = event.data?.[CHANNEL];\n            if (isArray(details)) {\n              // if early enough, avoid leaking data to other listeners\n              event.stopImmediatePropagation();\n              const [id, sb, ...rest] = details;\n              let error;\n              // action available: it must be defined/known on the main thread\n              if (rest.length) {\n                const [action, args] = rest;\n                if (actions.has(action)) {\n                  seppuku = true;\n                  try {\n                    // await for result either sync or async and serialize it\n                    const result = await actions.get(action)(...args);\n                    if (result !== void 0) {\n                      const serialized = stringify(transform ? transform(result) : result);\n                      // store the result for \"the very next\" event listener call\n                      results.set(id, serialized);\n                      // communicate the required SharedArrayBuffer length out of the\n                      // resulting serialized string\n                      sb[1] = serialized.length;\n                    }\n                  }\n                  catch (_) {\n                    error = _;\n                  }\n                  finally {\n                    seppuku = false;\n                  }\n                }\n                // unknown action should be notified as missing on the main thread\n                else {\n                  error = new Error(`Unsupported action: ${action}`);\n                }\n                // unlock the wait lock later on\n                sb[0] = 1;\n              }\n              // no action means: get results out of the well known `id`\n              // wait lock automatically unlocked here as no `0` value would\n              // possibly ever land at index `0`\n              else {\n                const result = results.get(id);\n                results.delete(id);\n                // populate the SharedArrayBuffer with utf-16 chars code\n                for (let ui16a = new Uint16Array(sb.buffer), i = 0; i < result.length; i++)\n                  ui16a[i] = result.charCodeAt(i);\n              }\n              // release te worker waiting either the length or the result\n              notify(sb, 0);\n              if (error) throw error;\n            }\n          });\n        }\n        // store this action callback allowing the setter in the process\n        return !!actions.set(action, callback);\n      }\n    }));\n  }\n  return context.get(self);\n};\n\ncoincident.transfer = (...args) => (buffers.add(args), args);\n\nexport default coincident;\n","export const APPLY                        = 'apply';\nexport const CONSTRUCT                    = 'construct';\nexport const DEFINE_PROPERTY              = 'defineProperty';\nexport const DELETE_PROPERTY              = 'deleteProperty';\nexport const GET                          = 'get';\nexport const GET_OWN_PROPERTY_DESCRIPTOR  = 'getOwnPropertyDescriptor';\nexport const GET_PROTOTYPE_OF             = 'getPrototypeOf';\nexport const HAS                          = 'has';\nexport const IS_EXTENSIBLE                = 'isExtensible';\nexport const OWN_KEYS                     = 'ownKeys';\nexport const PREVENT_EXTENSION            = 'preventExtensions';\nexport const SET                          = 'set';\nexport const SET_PROTOTYPE_OF             = 'setPrototypeOf';\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"names":["FUNCTION","CHANNEL","isArray","Array","SharedArrayBuffer","window","globalThis","notify","wait","waitAsync","Atomics","postPatched","buffer","value","Promise","onmessage","w","Worker","postMessage","_","ArrayBuffer","ids","WeakMap","resolvers","Map","prototype","listener","event","details","data","stopImmediatePropagation","id","sb","get","rest","set","this","addEventListener","call","resolve","then","buff","delete","i","length","as","Int32Array","BYTES_PER_ELEMENT","I32_BYTES","UI16_BYTES","Uint16Array","buffers","WeakSet","context","syncResult","fn","uid","coincident","self","parse","JSON","stringify","transform","interrupt","has","sendMessage","post","transfer","args","handler","delay","decoder","TextDecoder","waitFor","isAsync","waitInterrupt","seppuku","Proxy","action","startsWith","at","pop","map","deadlock","setTimeout","console","warn","clearTimeout","bytes","decode","slice","actions","callback","type","Error","size","results","async","error","result","serialized","ui16a","charCodeAt","add","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","isError","message","name","stack","Object","assign","ep","allowedOrigins","ev","origin","allowedOrigin","RegExp","test","isAllowedOrigin","path","argumentList","fromWireValue","returnValue","parent","reduce","prop","rawValue","apply","proxy","transfers","transferCache","undefined","catch","wireValue","transferables","toWireValue","removeEventListener","closeEndPoint","TypeError","endpoint","constructor","isMessagePort","close","target","pendingListeners","resolver","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","_target","unregister","unregisterProxy","clear","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","concat","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","defaultClearTimeout","runTimeout","fun","e","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","arguments","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"sourceRoot":""}