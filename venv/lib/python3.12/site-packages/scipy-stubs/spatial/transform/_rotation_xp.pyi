from _typeshed import Incomplete
from types import EllipsisType, ModuleType
from typing import Protocol, TypeVar, overload, type_check_only

@type_check_only
class _HasArrayNamespace(Protocol):
    def __array_namespace__(self, /) -> Incomplete: ...

_ArrayT = TypeVar("_ArrayT", bound=_HasArrayNamespace)

###
# for the sake of simplicity, we assume that the array types do no include shape-typing information,
# and have the same input/output dtype

def from_quat(quat: _ArrayT, normalize: bool = True, copy: bool = True, *, scalar_first: bool = False) -> _ArrayT: ...
def from_matrix(matrix: _ArrayT, assume_valid: bool = False) -> _ArrayT: ...
def _from_matrix_orthogonal(matrix: _ArrayT) -> _ArrayT: ...
def from_rotvec(rotvec: _ArrayT, degrees: bool = False) -> _ArrayT: ...
def from_mrp(mrp: _ArrayT) -> _ArrayT: ...
def from_euler(seq: str, angles: _ArrayT, degrees: bool = False) -> _ArrayT: ...
def from_davenport(axes: _ArrayT, order: str, angles: _ArrayT | float, degrees: bool = False) -> _ArrayT: ...
def as_quat(quat: _ArrayT, canonical: bool = False, *, scalar_first: bool = False) -> _ArrayT: ...
def as_matrix(quat: _ArrayT) -> _ArrayT: ...
def as_rotvec(quat: _ArrayT, degrees: bool = False) -> _ArrayT: ...
def as_mrp(quat: _ArrayT) -> _ArrayT: ...
def as_euler(quat: _ArrayT, seq: str, degrees: bool = False, *, suppress_warnings: bool = False) -> _ArrayT: ...
def as_davenport(
    quat: _ArrayT, axes: _ArrayT, order: str, degrees: bool = False, *, suppress_warnings: bool = False
) -> _ArrayT: ...
def inv(quat: _ArrayT) -> _ArrayT: ...
def magnitude(quat: _ArrayT) -> _ArrayT: ...
def approx_equal(quat: _ArrayT, other: _ArrayT, atol: float | None = None, degrees: bool = False) -> Incomplete: ...
def mean(quat: _ArrayT, weights: _ArrayT | None = None, axis: int | tuple[int, ...] | None = None) -> _ArrayT: ...

#
@overload
def reduce(quat: _ArrayT, left: None = None, right: None = None) -> tuple[_ArrayT, None, None]: ...
@overload
def reduce(quat: _ArrayT, left: _ArrayT, right: _ArrayT | None = None) -> tuple[_ArrayT, _ArrayT, _ArrayT]: ...
@overload
def reduce(quat: _ArrayT, left: _ArrayT | None, right: _ArrayT) -> tuple[_ArrayT, _ArrayT, _ArrayT]: ...
@overload
def reduce(quat: _ArrayT, left: _ArrayT | None = None, *, right: _ArrayT) -> tuple[_ArrayT, _ArrayT, _ArrayT]: ...

#
def apply(quat: _ArrayT, points: _ArrayT, inverse: bool = False) -> _ArrayT: ...
def setitem(quat: _ArrayT, value: _ArrayT, indexer: int | slice | EllipsisType | None) -> _ArrayT: ...
def align_vectors(
    a: _ArrayT, b: _ArrayT, weights: _ArrayT | None = None, return_sensitivity: bool = False
) -> tuple[_ArrayT, _ArrayT, _ArrayT]: ...
def _align_vectors(a: _ArrayT, b: _ArrayT, weights: _ArrayT) -> tuple[_ArrayT, _ArrayT, _ArrayT]: ...
def _align_vectors_fixed(a: _ArrayT, b: _ArrayT, weights: _ArrayT) -> tuple[_ArrayT, _ArrayT, _ArrayT]: ...
def pow(quat: _ArrayT, n: float | _ArrayT) -> _ArrayT: ...
def _normalize_quaternion(quat: _ArrayT) -> _ArrayT: ...
def _quat_canonical(quat: _ArrayT) -> _ArrayT: ...
def _elementary_basis_index(axis: str) -> int: ...
def _compute_davenport_from_quat(
    quat: _ArrayT, n1: _ArrayT, n2: _ArrayT, n3: _ArrayT, extrinsic: bool, suppress_warnings: bool
) -> _ArrayT: ...
def _elementary_quat_compose(axes: list[int], angles: _ArrayT, intrinsic: bool) -> _ArrayT: ...
def _make_elementary_quat(axis: int, angle: _ArrayT, device: object, xp: ModuleType) -> _ArrayT: ...
def _get_angles(
    extrinsic: bool,
    symmetric: bool,
    sign: int,
    lamb: float,
    a: _ArrayT,
    b: _ArrayT,
    c: _ArrayT,
    d: _ArrayT,
    suppress_warnings: bool,
) -> _ArrayT: ...
def compose_quat(p: _ArrayT, q: _ArrayT) -> _ArrayT: ...
def _split_rotation(q: _ArrayT, xp: ModuleType) -> tuple[_ArrayT, _ArrayT]: ...
def _deg2rad(angles: _ArrayT) -> _ArrayT: ...
def _rad2deg(angles: _ArrayT) -> _ArrayT: ...
