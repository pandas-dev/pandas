from types import EllipsisType
from typing import Literal, TypeAlias, overload

import numpy as np
import optype.numpy as onp

_bint: TypeAlias = bool | Literal[0, 1]  # noqa: PYI042

_f64_1d: TypeAlias = onp.Array1D[np.float64]  # noqa: PYI042
_f64_2d: TypeAlias = onp.Array2D[np.float64]  # noqa: PYI042
_f64_3d: TypeAlias = onp.Array3D[np.float64]  # noqa: PYI042

_Indexer: TypeAlias = int | slice | EllipsisType | None

###

def from_matrix(matrix: _f64_3d, normalize: _bint = True, copy: _bint = True) -> _f64_3d: ...

#
@overload
def from_rotation(quat: _f64_1d) -> _f64_1d: ...
@overload
def from_rotation(quat: _f64_2d) -> _f64_2d: ...

#
@overload
def from_translation(translation: _f64_1d) -> _f64_1d: ...
@overload
def from_translation(translation: _f64_2d) -> _f64_2d: ...

#
@overload
def from_exp_coords(exp_coords: _f64_1d) -> _f64_1d: ...
@overload
def from_exp_coords(exp_coords: _f64_2d) -> _f64_2d: ...

#
@overload
def from_dual_quat(dual_quat: onp.ToFloatStrict1D, *, scalar_first: _bint = False) -> _f64_2d: ...
@overload
def from_dual_quat(dual_quat: onp.ToFloatStrict2D, *, scalar_first: _bint = False) -> _f64_3d: ...

#
def as_exp_coords(matrix: _f64_3d) -> _f64_2d: ...
def as_dual_quat(matrix: _f64_3d, *, scalar_first: _bint = False) -> _f64_3d: ...
def compose_transforms(tf_matrix: _f64_3d, other_tf_matrix: _f64_3d) -> _f64_3d: ...
def inv(matrix: _f64_3d) -> _f64_3d: ...
def apply(matrix: _f64_3d, vector: onp.ToFloatStrict1D | onp.ToFloatStrict2D, inverse: _bint = False) -> _f64_2d: ...
def pow(matrix: _f64_3d, n: float) -> _f64_3d: ...
def mean(
    matrix: _f64_3d, weights: onp.ToFloatStrict1D | None = None, axis: Literal[0] | tuple[Literal[0]] | None = None
) -> _f64_2d: ...
def setitem(matrix: _f64_3d, indexer: _Indexer, value: _f64_3d) -> _f64_3d: ...
def normalize_dual_quaternion(dual_quat: _f64_2d) -> _f64_2d: ...

#
@overload
def _create_transformation_matrix(
    translations: _f64_1d | _f64_2d, rotation_matrices: _f64_2d | _f64_3d, single: Literal[True, 1]
) -> _f64_2d: ...
@overload
def _create_transformation_matrix(
    translations: _f64_1d | _f64_2d, rotation_matrices: _f64_2d | _f64_3d, single: Literal[False, 0]
) -> _f64_3d: ...
