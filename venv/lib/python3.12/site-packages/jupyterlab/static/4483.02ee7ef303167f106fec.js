"use strict";(self["webpackChunk_jupyterlab_application_top"]=self["webpackChunk_jupyterlab_application_top"]||[]).push([[4483],{85054:(e,t,a)=>{a.d(t,{S:()=>n});var i=a(70416);function n(e,t){if(e.accDescr){t.setAccDescription?.(e.accDescr)}if(e.accTitle){t.setAccTitle?.(e.accTitle)}if(e.title){t.setDiagramTitle?.(e.title)}}(0,i.K2)(n,"populateCommonDb")},14483:(e,t,a)=>{a.d(t,{diagram:()=>K});var i=a(29479);var n=a(85054);var r=a(29131);var l=a(42418);var s=a(70416);var o=a(24010);var c=a(1218);var p=l.UI.pie;var d={sections:new Map,showData:false,config:p};var u=d.sections;var v=d.showData;var f=structuredClone(p);var g=(0,s.K2)((()=>structuredClone(f)),"getConfig");var h=(0,s.K2)((()=>{u=new Map;v=d.showData;(0,l.IU)()}),"clear");var m=(0,s.K2)((({label:e,value:t})=>{if(t<0){throw new Error(`"${e}" has invalid value: ${t}. Negative values are not allowed in pie charts. All slice values must be >= 0.`)}if(!u.has(e)){u.set(e,t);s.Rm.debug(`added new section: ${e}, with value: ${t}`)}}),"addSection");var w=(0,s.K2)((()=>u),"getSections");var S=(0,s.K2)((e=>{v=e}),"setShowData");var x=(0,s.K2)((()=>v),"getShowData");var $={getConfig:g,clear:h,setDiagramTitle:l.ke,getDiagramTitle:l.ab,setAccTitle:l.SV,getAccTitle:l.iN,setAccDescription:l.EI,getAccDescription:l.m7,addSection:m,getSections:w,setShowData:S,getShowData:x};var D=(0,s.K2)(((e,t)=>{(0,n.S)(e,t);t.setShowData(e.showData);e.sections.map(t.addSection)}),"populateDb");var b={parse:(0,s.K2)((async e=>{const t=await(0,o.qg)("pie",e);s.Rm.debug(t);D(t,$)}),"parse")};var y=(0,s.K2)((e=>`\n  .pieCircle{\n    stroke: ${e.pieStrokeColor};\n    stroke-width : ${e.pieStrokeWidth};\n    opacity : ${e.pieOpacity};\n  }\n  .pieOuterCircle{\n    stroke: ${e.pieOuterStrokeColor};\n    stroke-width: ${e.pieOuterStrokeWidth};\n    fill: none;\n  }\n  .pieTitleText {\n    text-anchor: middle;\n    font-size: ${e.pieTitleTextSize};\n    fill: ${e.pieTitleTextColor};\n    font-family: ${e.fontFamily};\n  }\n  .slice {\n    font-family: ${e.fontFamily};\n    fill: ${e.pieSectionTextColor};\n    font-size:${e.pieSectionTextSize};\n    // fill: white;\n  }\n  .legend text {\n    fill: ${e.pieLegendTextColor};\n    font-family: ${e.fontFamily};\n    font-size: ${e.pieLegendTextSize};\n  }\n`),"getStyles");var T=y;var C=(0,s.K2)((e=>{const t=[...e.values()].reduce(((e,t)=>e+t),0);const a=[...e.entries()].map((([e,t])=>({label:e,value:t}))).filter((e=>e.value/t*100>=1)).sort(((e,t)=>t.value-e.value));const i=(0,c.rLf)().value((e=>e.value));return i(a)}),"createPieArcs");var k=(0,s.K2)(((e,t,a,n)=>{s.Rm.debug("rendering pie chart\n"+e);const o=n.db;const p=(0,l.D7)();const d=(0,r.$t)(o.getConfig(),p.pie);const u=40;const v=18;const f=4;const g=450;const h=g;const m=(0,i.D)(t);const w=m.append("g");w.attr("transform","translate("+h/2+","+g/2+")");const{themeVariables:S}=p;let[x]=(0,r.I5)(S.pieOuterStrokeWidth);x??=2;const $=d.textPosition;const D=Math.min(h,g)/2-u;const b=(0,c.JLW)().innerRadius(0).outerRadius(D);const y=(0,c.JLW)().innerRadius(D*$).outerRadius(D*$);w.append("circle").attr("cx",0).attr("cy",0).attr("r",D+x/2).attr("class","pieOuterCircle");const T=o.getSections();const k=C(T);const A=[S.pie1,S.pie2,S.pie3,S.pie4,S.pie5,S.pie6,S.pie7,S.pie8,S.pie9,S.pie10,S.pie11,S.pie12];let K=0;T.forEach((e=>{K+=e}));const R=k.filter((e=>(e.data.value/K*100).toFixed(0)!=="0"));const z=(0,c.UMr)(A);w.selectAll("mySlices").data(R).enter().append("path").attr("d",b).attr("fill",(e=>z(e.data.label))).attr("class","pieCircle");w.selectAll("mySlices").data(R).enter().append("text").text((e=>(e.data.value/K*100).toFixed(0)+"%")).attr("transform",(e=>"translate("+y.centroid(e)+")")).style("text-anchor","middle").attr("class","slice");w.append("text").text(o.getDiagramTitle()).attr("x",0).attr("y",-(g-50)/2).attr("class","pieTitleText");const M=[...T.entries()].map((([e,t])=>({label:e,value:t})));const O=w.selectAll(".legend").data(M).enter().append("g").attr("class","legend").attr("transform",((e,t)=>{const a=v+f;const i=a*M.length/2;const n=12*v;const r=t*a-i;return"translate("+n+","+r+")"}));O.append("rect").attr("width",v).attr("height",v).style("fill",(e=>z(e.label))).style("stroke",(e=>z(e.label)));O.append("text").attr("x",v+f).attr("y",v-f).text((e=>{if(o.getShowData()){return`${e.label} [${e.value}]`}return e.label}));const W=Math.max(...O.selectAll("text").nodes().map((e=>e?.getBoundingClientRect().width??0)));const _=h+u+v+f+W;m.attr("viewBox",`0 0 ${_} ${g}`);(0,l.a$)(m,g,_,d.useMaxWidth)}),"draw");var A={draw:k};var K={parser:b,db:$,renderer:A,styles:T}}}]);