"use strict";(self["webpackChunk_jupyterlab_application_top"]=self["webpackChunk_jupyterlab_application_top"]||[]).push([[8366],{51916:(e,t,a)=>{a.d(t,{S:()=>n});var i=a(6047);function n(e,t){if(e.accDescr){t.setAccDescription?.(e.accDescr)}if(e.accTitle){t.setAccTitle?.(e.accTitle)}if(e.title){t.setDiagramTitle?.(e.title)}}(0,i.K2)(n,"populateCommonDb")},58366:(e,t,a)=>{a.d(t,{diagram:()=>A});var i=a(51916);var n=a(52724);var r=a(84222);var l=a(6047);var s=a(24010);var o=a(1218);var c=l.UI.pie;var p={sections:new Map,showData:false,config:c};var d=p.sections;var u=p.showData;var v=structuredClone(c);var f=(0,l.K2)((()=>structuredClone(v)),"getConfig");var g=(0,l.K2)((()=>{d=new Map;u=p.showData;(0,l.IU)()}),"clear");var h=(0,l.K2)((({label:e,value:t})=>{if(t<0){throw new Error(`"${e}" has invalid value: ${t}. Negative values are not allowed in pie charts. All slice values must be >= 0.`)}if(!d.has(e)){d.set(e,t);l.Rm.debug(`added new section: ${e}, with value: ${t}`)}}),"addSection");var m=(0,l.K2)((()=>d),"getSections");var w=(0,l.K2)((e=>{u=e}),"setShowData");var S=(0,l.K2)((()=>u),"getShowData");var x={getConfig:f,clear:g,setDiagramTitle:l.ke,getDiagramTitle:l.ab,setAccTitle:l.SV,getAccTitle:l.iN,setAccDescription:l.EI,getAccDescription:l.m7,addSection:h,getSections:m,setShowData:w,getShowData:S};var $=(0,l.K2)(((e,t)=>{(0,i.S)(e,t);t.setShowData(e.showData);e.sections.map(t.addSection)}),"populateDb");var D={parse:(0,l.K2)((async e=>{const t=await(0,s.qg)("pie",e);l.Rm.debug(t);$(t,x)}),"parse")};var b=(0,l.K2)((e=>`\n  .pieCircle{\n    stroke: ${e.pieStrokeColor};\n    stroke-width : ${e.pieStrokeWidth};\n    opacity : ${e.pieOpacity};\n  }\n  .pieOuterCircle{\n    stroke: ${e.pieOuterStrokeColor};\n    stroke-width: ${e.pieOuterStrokeWidth};\n    fill: none;\n  }\n  .pieTitleText {\n    text-anchor: middle;\n    font-size: ${e.pieTitleTextSize};\n    fill: ${e.pieTitleTextColor};\n    font-family: ${e.fontFamily};\n  }\n  .slice {\n    font-family: ${e.fontFamily};\n    fill: ${e.pieSectionTextColor};\n    font-size:${e.pieSectionTextSize};\n    // fill: white;\n  }\n  .legend text {\n    fill: ${e.pieLegendTextColor};\n    font-family: ${e.fontFamily};\n    font-size: ${e.pieLegendTextSize};\n  }\n`),"getStyles");var y=b;var T=(0,l.K2)((e=>{const t=[...e.values()].reduce(((e,t)=>e+t),0);const a=[...e.entries()].map((([e,t])=>({label:e,value:t}))).filter((e=>e.value/t*100>=1)).sort(((e,t)=>t.value-e.value));const i=(0,o.rLf)().value((e=>e.value));return i(a)}),"createPieArcs");var C=(0,l.K2)(((e,t,a,i)=>{l.Rm.debug("rendering pie chart\n"+e);const s=i.db;const c=(0,l.D7)();const p=(0,n.$t)(s.getConfig(),c.pie);const d=40;const u=18;const v=4;const f=450;const g=f;const h=(0,r.D)(t);const m=h.append("g");m.attr("transform","translate("+g/2+","+f/2+")");const{themeVariables:w}=c;let[S]=(0,n.I5)(w.pieOuterStrokeWidth);S??=2;const x=p.textPosition;const $=Math.min(g,f)/2-d;const D=(0,o.JLW)().innerRadius(0).outerRadius($);const b=(0,o.JLW)().innerRadius($*x).outerRadius($*x);m.append("circle").attr("cx",0).attr("cy",0).attr("r",$+S/2).attr("class","pieOuterCircle");const y=s.getSections();const C=T(y);const k=[w.pie1,w.pie2,w.pie3,w.pie4,w.pie5,w.pie6,w.pie7,w.pie8,w.pie9,w.pie10,w.pie11,w.pie12];let A=0;y.forEach((e=>{A+=e}));const K=C.filter((e=>(e.data.value/A*100).toFixed(0)!=="0"));const R=(0,o.UMr)(k);m.selectAll("mySlices").data(K).enter().append("path").attr("d",D).attr("fill",(e=>R(e.data.label))).attr("class","pieCircle");m.selectAll("mySlices").data(K).enter().append("text").text((e=>(e.data.value/A*100).toFixed(0)+"%")).attr("transform",(e=>"translate("+b.centroid(e)+")")).style("text-anchor","middle").attr("class","slice");m.append("text").text(s.getDiagramTitle()).attr("x",0).attr("y",-(f-50)/2).attr("class","pieTitleText");const z=[...y.entries()].map((([e,t])=>({label:e,value:t})));const M=m.selectAll(".legend").data(z).enter().append("g").attr("class","legend").attr("transform",((e,t)=>{const a=u+v;const i=a*z.length/2;const n=12*u;const r=t*a-i;return"translate("+n+","+r+")"}));M.append("rect").attr("width",u).attr("height",u).style("fill",(e=>R(e.label))).style("stroke",(e=>R(e.label)));M.append("text").attr("x",u+v).attr("y",u-v).text((e=>{if(s.getShowData()){return`${e.label} [${e.value}]`}return e.label}));const O=Math.max(...M.selectAll("text").nodes().map((e=>e?.getBoundingClientRect().width??0)));const W=g+d+u+v+O;h.attr("viewBox",`0 0 ${W} ${f}`);(0,l.a$)(h,f,W,p.useMaxWidth)}),"draw");var k={draw:C};var A={parser:D,db:x,renderer:k,styles:y}}}]);