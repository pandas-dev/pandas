#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an
#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#  KIND, either express or implied.  See the License for the
#  specific language governing permissions and limitations
#  under the License.
#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import logging
import sys

import fb303.FacebookService
from thrift.Thrift import (
    TApplicationException,
    TMessageType,
    TProcessor,
    TType,
)
from thrift.transport import TTransport
from thrift.TRecursive import fix_spec

from .ttypes import *

all_structs = []


class Iface(fb303.FacebookService.Iface):
    """
    This interface is live.

    """

    def getMetaConf(self, key):
        """
        Parameters:
         - key

        """
        pass

    def setMetaConf(self, key, value):
        """
        Parameters:
         - key
         - value

        """
        pass

    def create_catalog(self, catalog):
        """
        Parameters:
         - catalog

        """
        pass

    def alter_catalog(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_catalog(self, catName):
        """
        Parameters:
         - catName

        """
        pass

    def get_catalogs(self):
        pass

    def drop_catalog(self, catName):
        """
        Parameters:
         - catName

        """
        pass

    def create_database(self, database):
        """
        Parameters:
         - database

        """
        pass

    def get_database(self, name):
        """
        Parameters:
         - name

        """
        pass

    def get_database_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_database(self, name, deleteData, cascade):
        """
        Parameters:
         - name
         - deleteData
         - cascade

        """
        pass

    def drop_database_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_databases(self, pattern):
        """
        Parameters:
         - pattern

        """
        pass

    def get_all_databases(self):
        pass

    def alter_database(self, dbname, db):
        """
        Parameters:
         - dbname
         - db

        """
        pass

    def create_dataconnector(self, connector):
        """
        Parameters:
         - connector

        """
        pass

    def get_dataconnector_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_dataconnector(self, name, ifNotExists, checkReferences):
        """
        Parameters:
         - name
         - ifNotExists
         - checkReferences

        """
        pass

    def get_dataconnectors(self):
        pass

    def alter_dataconnector(self, name, connector):
        """
        Parameters:
         - name
         - connector

        """
        pass

    def get_type(self, name):
        """
        Parameters:
         - name

        """
        pass

    def create_type(self, type):
        """
        Parameters:
         - type

        """
        pass

    def drop_type(self, type):
        """
        Parameters:
         - type

        """
        pass

    def get_type_all(self, name):
        """
        Parameters:
         - name

        """
        pass

    def get_fields(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        pass

    def get_fields_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        pass

    def get_fields_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_schema(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        pass

    def get_schema_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        pass

    def get_schema_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def create_table(self, tbl):
        """
        Parameters:
         - tbl

        """
        pass

    def create_table_with_environment_context(self, tbl, environment_context):
        """
        Parameters:
         - tbl
         - environment_context

        """
        pass

    def create_table_with_constraints(
        self, tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints, defaultConstraints, checkConstraints
    ):
        """
        Parameters:
         - tbl
         - primaryKeys
         - foreignKeys
         - uniqueConstraints
         - notNullConstraints
         - defaultConstraints
         - checkConstraints

        """
        pass

    def create_table_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_constraint(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_primary_key(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_foreign_key(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_unique_constraint(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_not_null_constraint(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_default_constraint(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_check_constraint(self, req):
        """
        Parameters:
         - req

        """
        pass

    def translate_table_dryrun(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_table(self, dbname, name, deleteData):
        """
        Parameters:
         - dbname
         - name
         - deleteData

        """
        pass

    def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        """
        Parameters:
         - dbname
         - name
         - deleteData
         - environment_context

        """
        pass

    def truncate_table(self, dbName, tableName, partNames):
        """
        Parameters:
         - dbName
         - tableName
         - partNames

        """
        pass

    def truncate_table_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_tables(self, db_name, pattern):
        """
        Parameters:
         - db_name
         - pattern

        """
        pass

    def get_tables_by_type(self, db_name, pattern, tableType):
        """
        Parameters:
         - db_name
         - pattern
         - tableType

        """
        pass

    def get_all_materialized_view_objects_for_rewriting(self):
        pass

    def get_materialized_views_for_rewriting(self, db_name):
        """
        Parameters:
         - db_name

        """
        pass

    def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        """
        Parameters:
         - db_patterns
         - tbl_patterns
         - tbl_types

        """
        pass

    def get_all_tables(self, db_name):
        """
        Parameters:
         - db_name

        """
        pass

    def get_table(self, dbname, tbl_name):
        """
        Parameters:
         - dbname
         - tbl_name

        """
        pass

    def get_table_objects_by_name(self, dbname, tbl_names):
        """
        Parameters:
         - dbname
         - tbl_names

        """
        pass

    def get_tables_ext(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_table_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_table_objects_by_name_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_materialization_invalidation_info(self, creation_metadata, validTxnList):
        """
        Parameters:
         - creation_metadata
         - validTxnList

        """
        pass

    def update_creation_metadata(self, catName, dbname, tbl_name, creation_metadata):
        """
        Parameters:
         - catName
         - dbname
         - tbl_name
         - creation_metadata

        """
        pass

    def get_table_names_by_filter(self, dbname, filter, max_tables):
        """
        Parameters:
         - dbname
         - filter
         - max_tables

        """
        pass

    def alter_table(self, dbname, tbl_name, new_tbl):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl

        """
        pass

    def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - environment_context

        """
        pass

    def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - cascade

        """
        pass

    def alter_table_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_partition(self, new_part):
        """
        Parameters:
         - new_part

        """
        pass

    def add_partition_with_environment_context(self, new_part, environment_context):
        """
        Parameters:
         - new_part
         - environment_context

        """
        pass

    def add_partitions(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        pass

    def add_partitions_pspec(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        pass

    def append_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        pass

    def add_partitions_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - environment_context

        """
        pass

    def append_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        pass

    def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - environment_context

        """
        pass

    def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData

        """
        pass

    def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
         - environment_context

        """
        pass

    def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData

        """
        pass

    def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
         - environment_context

        """
        pass

    def drop_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        pass

    def get_partition_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        pass

    def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        pass

    def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - user_name
         - group_names

        """
        pass

    def get_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        pass

    def get_partitions(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        pass

    def get_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
         - user_name
         - group_names

        """
        pass

    def get_partitions_pspec(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        pass

    def get_partition_names(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        pass

    def get_partition_values(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        pass

    def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
         - user_name
         - group_names

        """
        pass

    def get_partitions_ps_with_auth_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        pass

    def get_partition_names_ps_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_partition_names_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        pass

    def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        pass

    def get_partitions_by_expr(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_partitions_spec_by_expr(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_num_partitions_by_filter(self, db_name, tbl_name, filter):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter

        """
        pass

    def get_partitions_by_names(self, db_name, tbl_name, names):
        """
        Parameters:
         - db_name
         - tbl_name
         - names

        """
        pass

    def get_partitions_by_names_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def alter_partition(self, db_name, tbl_name, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part

        """
        pass

    def alter_partitions(self, db_name, tbl_name, new_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts

        """
        pass

    def alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts
         - environment_context

        """
        pass

    def alter_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
         - environment_context

        """
        pass

    def rename_partition(self, db_name, tbl_name, part_vals, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - new_part

        """
        pass

    def rename_partition_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def partition_name_has_valid_characters(self, part_vals, throw_exception):
        """
        Parameters:
         - part_vals
         - throw_exception

        """
        pass

    def get_config_value(self, name, defaultValue):
        """
        Parameters:
         - name
         - defaultValue

        """
        pass

    def partition_name_to_vals(self, part_name):
        """
        Parameters:
         - part_name

        """
        pass

    def partition_name_to_spec(self, part_name):
        """
        Parameters:
         - part_name

        """
        pass

    def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        pass

    def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        pass

    def get_primary_keys(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_foreign_keys(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_unique_constraints(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_not_null_constraints(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_default_constraints(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_check_constraints(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_all_table_constraints(self, request):
        """
        Parameters:
         - request

        """
        pass

    def update_table_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        pass

    def update_partition_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        pass

    def update_table_column_statistics_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def update_partition_column_statistics_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def update_transaction_statistics(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name

        """
        pass

    def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name

        """
        pass

    def get_table_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_partitions_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        pass

    def set_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        pass

    def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name, engine):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name
         - engine

        """
        pass

    def delete_table_column_statistics(self, db_name, tbl_name, col_name, engine):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name
         - engine

        """
        pass

    def create_function(self, func):
        """
        Parameters:
         - func

        """
        pass

    def drop_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        pass

    def alter_function(self, dbName, funcName, newFunc):
        """
        Parameters:
         - dbName
         - funcName
         - newFunc

        """
        pass

    def get_functions(self, dbName, pattern):
        """
        Parameters:
         - dbName
         - pattern

        """
        pass

    def get_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        pass

    def get_all_functions(self):
        pass

    def create_role(self, role):
        """
        Parameters:
         - role

        """
        pass

    def drop_role(self, role_name):
        """
        Parameters:
         - role_name

        """
        pass

    def get_role_names(self):
        pass

    def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
         - grantor
         - grantorType
         - grant_option

        """
        pass

    def revoke_role(self, role_name, principal_name, principal_type):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type

        """
        pass

    def list_roles(self, principal_name, principal_type):
        """
        Parameters:
         - principal_name
         - principal_type

        """
        pass

    def grant_revoke_role(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_principals_in_role(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_role_grants_for_principal(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_privilege_set(self, hiveObject, user_name, group_names):
        """
        Parameters:
         - hiveObject
         - user_name
         - group_names

        """
        pass

    def list_privileges(self, principal_name, principal_type, hiveObject):
        """
        Parameters:
         - principal_name
         - principal_type
         - hiveObject

        """
        pass

    def grant_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        pass

    def revoke_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        pass

    def grant_revoke_privileges(self, request):
        """
        Parameters:
         - request

        """
        pass

    def refresh_privileges(self, objToRefresh, authorizer, grantRequest):
        """
        Parameters:
         - objToRefresh
         - authorizer
         - grantRequest

        """
        pass

    def set_ugi(self, user_name, group_names):
        """
        Parameters:
         - user_name
         - group_names

        """
        pass

    def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        """
        Parameters:
         - token_owner
         - renewer_kerberos_principal_name

        """
        pass

    def renew_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        pass

    def cancel_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        pass

    def add_token(self, token_identifier, delegation_token):
        """
        Parameters:
         - token_identifier
         - delegation_token

        """
        pass

    def remove_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        pass

    def get_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        pass

    def get_all_token_identifiers(self):
        pass

    def add_master_key(self, key):
        """
        Parameters:
         - key

        """
        pass

    def update_master_key(self, seq_number, key):
        """
        Parameters:
         - seq_number
         - key

        """
        pass

    def remove_master_key(self, key_seq):
        """
        Parameters:
         - key_seq

        """
        pass

    def get_master_keys(self):
        pass

    def get_open_txns(self):
        pass

    def get_open_txns_info(self):
        pass

    def open_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def abort_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def abort_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def commit_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_latest_txnid_in_conflict(self, txnId):
        """
        Parameters:
         - txnId

        """
        pass

    def repl_tbl_writeid_state(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_valid_write_ids(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def allocate_table_write_ids(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_max_allocated_table_write_id(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def seed_write_id(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def seed_txn_id(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def check_lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def unlock(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def show_locks(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def heartbeat(self, ids):
        """
        Parameters:
         - ids

        """
        pass

    def heartbeat_txn_range(self, txns):
        """
        Parameters:
         - txns

        """
        pass

    def compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def compact2(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def show_compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def add_dynamic_partitions(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def find_next_compact(self, workerId):
        """
        Parameters:
         - workerId

        """
        pass

    def find_next_compact2(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def update_compactor_state(self, cr, txn_id):
        """
        Parameters:
         - cr
         - txn_id

        """
        pass

    def find_columns_with_stats(self, cr):
        """
        Parameters:
         - cr

        """
        pass

    def mark_cleaned(self, cr):
        """
        Parameters:
         - cr

        """
        pass

    def mark_compacted(self, cr):
        """
        Parameters:
         - cr

        """
        pass

    def mark_failed(self, cr):
        """
        Parameters:
         - cr

        """
        pass

    def mark_refused(self, cr):
        """
        Parameters:
         - cr

        """
        pass

    def update_compaction_metrics_data(self, data):
        """
        Parameters:
         - data

        """
        pass

    def remove_compaction_metrics_data(self, request):
        """
        Parameters:
         - request

        """
        pass

    def set_hadoop_jobid(self, jobId, cq_id):
        """
        Parameters:
         - jobId
         - cq_id

        """
        pass

    def get_latest_committed_compaction_info(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_next_notification(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_current_notificationEventId(self):
        pass

    def get_notification_events_count(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def fire_listener_event(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def flushCache(self):
        pass

    def add_write_notification_log(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def add_write_notification_log_in_batch(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def cm_recycle(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_file_metadata_by_expr(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass

    def put_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass

    def clear_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass

    def cache_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_metastore_db_uuid(self):
        pass

    def create_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_active_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_all_resource_plans(self, request):
        """
        Parameters:
         - request

        """
        pass

    def alter_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        pass

    def validate_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        pass

    def create_wm_trigger(self, request):
        """
        Parameters:
         - request

        """
        pass

    def alter_wm_trigger(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_wm_trigger(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_triggers_for_resourceplan(self, request):
        """
        Parameters:
         - request

        """
        pass

    def create_wm_pool(self, request):
        """
        Parameters:
         - request

        """
        pass

    def alter_wm_pool(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_wm_pool(self, request):
        """
        Parameters:
         - request

        """
        pass

    def create_or_update_wm_mapping(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_wm_mapping(self, request):
        """
        Parameters:
         - request

        """
        pass

    def create_or_drop_wm_trigger_to_pool_mapping(self, request):
        """
        Parameters:
         - request

        """
        pass

    def create_ischema(self, schema):
        """
        Parameters:
         - schema

        """
        pass

    def alter_ischema(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_ischema(self, name):
        """
        Parameters:
         - name

        """
        pass

    def drop_ischema(self, name):
        """
        Parameters:
         - name

        """
        pass

    def add_schema_version(self, schemaVersion):
        """
        Parameters:
         - schemaVersion

        """
        pass

    def get_schema_version(self, schemaVersion):
        """
        Parameters:
         - schemaVersion

        """
        pass

    def get_schema_latest_version(self, schemaName):
        """
        Parameters:
         - schemaName

        """
        pass

    def get_schema_all_versions(self, schemaName):
        """
        Parameters:
         - schemaName

        """
        pass

    def drop_schema_version(self, schemaVersion):
        """
        Parameters:
         - schemaVersion

        """
        pass

    def get_schemas_by_cols(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def map_schema_version_to_serde(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def set_schema_version_state(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def add_serde(self, serde):
        """
        Parameters:
         - serde

        """
        pass

    def get_serde(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_lock_materialization_rebuild(self, dbName, tableName, txnId):
        """
        Parameters:
         - dbName
         - tableName
         - txnId

        """
        pass

    def heartbeat_lock_materialization_rebuild(self, dbName, tableName, txnId):
        """
        Parameters:
         - dbName
         - tableName
         - txnId

        """
        pass

    def add_runtime_stats(self, stat):
        """
        Parameters:
         - stat

        """
        pass

    def get_runtime_stats(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_partitions_with_specs(self, request):
        """
        Parameters:
         - request

        """
        pass

    def scheduled_query_poll(self, request):
        """
        Parameters:
         - request

        """
        pass

    def scheduled_query_maintenance(self, request):
        """
        Parameters:
         - request

        """
        pass

    def scheduled_query_progress(self, info):
        """
        Parameters:
         - info

        """
        pass

    def get_scheduled_query(self, scheduleKey):
        """
        Parameters:
         - scheduleKey

        """
        pass

    def add_replication_metrics(self, replicationMetricList):
        """
        Parameters:
         - replicationMetricList

        """
        pass

    def get_replication_metrics(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_open_txns_req(self, getOpenTxnsRequest):
        """
        Parameters:
         - getOpenTxnsRequest

        """
        pass

    def create_stored_procedure(self, proc):
        """
        Parameters:
         - proc

        """
        pass

    def get_stored_procedure(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_stored_procedure(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_all_stored_procedures(self, request):
        """
        Parameters:
         - request

        """
        pass

    def find_package(self, request):
        """
        Parameters:
         - request

        """
        pass

    def add_package(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_all_packages(self, request):
        """
        Parameters:
         - request

        """
        pass

    def drop_package(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_all_write_event_info(self, request):
        """
        Parameters:
         - request

        """
        pass


class Client(fb303.FacebookService.Client, Iface):
    """
    This interface is live.

    """

    def __init__(self, iprot, oprot=None):
        fb303.FacebookService.Client.__init__(self, iprot, oprot)

    def getMetaConf(self, key):
        """
        Parameters:
         - key

        """
        self.send_getMetaConf(key)
        return self.recv_getMetaConf()

    def send_getMetaConf(self, key):
        self._oprot.writeMessageBegin("getMetaConf", TMessageType.CALL, self._seqid)
        args = getMetaConf_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetaConf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetaConf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMetaConf failed: unknown result")

    def setMetaConf(self, key, value):
        """
        Parameters:
         - key
         - value

        """
        self.send_setMetaConf(key, value)
        self.recv_setMetaConf()

    def send_setMetaConf(self, key, value):
        self._oprot.writeMessageBegin("setMetaConf", TMessageType.CALL, self._seqid)
        args = setMetaConf_args()
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setMetaConf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setMetaConf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def create_catalog(self, catalog):
        """
        Parameters:
         - catalog

        """
        self.send_create_catalog(catalog)
        self.recv_create_catalog()

    def send_create_catalog(self, catalog):
        self._oprot.writeMessageBegin("create_catalog", TMessageType.CALL, self._seqid)
        args = create_catalog_args()
        args.catalog = catalog
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_catalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_catalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def alter_catalog(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_alter_catalog(rqst)
        self.recv_alter_catalog()

    def send_alter_catalog(self, rqst):
        self._oprot.writeMessageBegin("alter_catalog", TMessageType.CALL, self._seqid)
        args = alter_catalog_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_catalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_catalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_catalog(self, catName):
        """
        Parameters:
         - catName

        """
        self.send_get_catalog(catName)
        return self.recv_get_catalog()

    def send_get_catalog(self, catName):
        self._oprot.writeMessageBegin("get_catalog", TMessageType.CALL, self._seqid)
        args = get_catalog_args()
        args.catName = catName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_catalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_catalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_catalog failed: unknown result")

    def get_catalogs(self):
        self.send_get_catalogs()
        return self.recv_get_catalogs()

    def send_get_catalogs(self):
        self._oprot.writeMessageBegin("get_catalogs", TMessageType.CALL, self._seqid)
        args = get_catalogs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_catalogs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_catalogs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_catalogs failed: unknown result")

    def drop_catalog(self, catName):
        """
        Parameters:
         - catName

        """
        self.send_drop_catalog(catName)
        self.recv_drop_catalog()

    def send_drop_catalog(self, catName):
        self._oprot.writeMessageBegin("drop_catalog", TMessageType.CALL, self._seqid)
        args = drop_catalog_args()
        args.catName = catName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_catalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_catalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def create_database(self, database):
        """
        Parameters:
         - database

        """
        self.send_create_database(database)
        self.recv_create_database()

    def send_create_database(self, database):
        self._oprot.writeMessageBegin("create_database", TMessageType.CALL, self._seqid)
        args = create_database_args()
        args.database = database
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_database(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_database(name)
        return self.recv_get_database()

    def send_get_database(self, name):
        self._oprot.writeMessageBegin("get_database", TMessageType.CALL, self._seqid)
        args = get_database_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result")

    def get_database_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_database_req(request)
        return self.recv_get_database_req()

    def send_get_database_req(self, request):
        self._oprot.writeMessageBegin("get_database_req", TMessageType.CALL, self._seqid)
        args = get_database_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_database_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_database_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database_req failed: unknown result")

    def drop_database(self, name, deleteData, cascade):
        """
        Parameters:
         - name
         - deleteData
         - cascade

        """
        self.send_drop_database(name, deleteData, cascade)
        self.recv_drop_database()

    def send_drop_database(self, name, deleteData, cascade):
        self._oprot.writeMessageBegin("drop_database", TMessageType.CALL, self._seqid)
        args = drop_database_args()
        args.name = name
        args.deleteData = deleteData
        args.cascade = cascade
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def drop_database_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_drop_database_req(req)
        self.recv_drop_database_req()

    def send_drop_database_req(self, req):
        self._oprot.writeMessageBegin("drop_database_req", TMessageType.CALL, self._seqid)
        args = drop_database_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_database_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_database_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_databases(self, pattern):
        """
        Parameters:
         - pattern

        """
        self.send_get_databases(pattern)
        return self.recv_get_databases()

    def send_get_databases(self, pattern):
        self._oprot.writeMessageBegin("get_databases", TMessageType.CALL, self._seqid)
        args = get_databases_args()
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_databases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_databases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result")

    def get_all_databases(self):
        self.send_get_all_databases()
        return self.recv_get_all_databases()

    def send_get_all_databases(self):
        self._oprot.writeMessageBegin("get_all_databases", TMessageType.CALL, self._seqid)
        args = get_all_databases_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_databases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_databases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result")

    def alter_database(self, dbname, db):
        """
        Parameters:
         - dbname
         - db

        """
        self.send_alter_database(dbname, db)
        self.recv_alter_database()

    def send_alter_database(self, dbname, db):
        self._oprot.writeMessageBegin("alter_database", TMessageType.CALL, self._seqid)
        args = alter_database_args()
        args.dbname = dbname
        args.db = db
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def create_dataconnector(self, connector):
        """
        Parameters:
         - connector

        """
        self.send_create_dataconnector(connector)
        self.recv_create_dataconnector()

    def send_create_dataconnector(self, connector):
        self._oprot.writeMessageBegin("create_dataconnector", TMessageType.CALL, self._seqid)
        args = create_dataconnector_args()
        args.connector = connector
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_dataconnector(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_dataconnector_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_dataconnector_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_dataconnector_req(request)
        return self.recv_get_dataconnector_req()

    def send_get_dataconnector_req(self, request):
        self._oprot.writeMessageBegin("get_dataconnector_req", TMessageType.CALL, self._seqid)
        args = get_dataconnector_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dataconnector_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dataconnector_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dataconnector_req failed: unknown result")

    def drop_dataconnector(self, name, ifNotExists, checkReferences):
        """
        Parameters:
         - name
         - ifNotExists
         - checkReferences

        """
        self.send_drop_dataconnector(name, ifNotExists, checkReferences)
        self.recv_drop_dataconnector()

    def send_drop_dataconnector(self, name, ifNotExists, checkReferences):
        self._oprot.writeMessageBegin("drop_dataconnector", TMessageType.CALL, self._seqid)
        args = drop_dataconnector_args()
        args.name = name
        args.ifNotExists = ifNotExists
        args.checkReferences = checkReferences
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_dataconnector(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_dataconnector_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_dataconnectors(self):
        self.send_get_dataconnectors()
        return self.recv_get_dataconnectors()

    def send_get_dataconnectors(self):
        self._oprot.writeMessageBegin("get_dataconnectors", TMessageType.CALL, self._seqid)
        args = get_dataconnectors_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dataconnectors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dataconnectors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dataconnectors failed: unknown result")

    def alter_dataconnector(self, name, connector):
        """
        Parameters:
         - name
         - connector

        """
        self.send_alter_dataconnector(name, connector)
        self.recv_alter_dataconnector()

    def send_alter_dataconnector(self, name, connector):
        self._oprot.writeMessageBegin("alter_dataconnector", TMessageType.CALL, self._seqid)
        args = alter_dataconnector_args()
        args.name = name
        args.connector = connector
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_dataconnector(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_dataconnector_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_type(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_type(name)
        return self.recv_get_type()

    def send_get_type(self, name):
        self._oprot.writeMessageBegin("get_type", TMessageType.CALL, self._seqid)
        args = get_type_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result")

    def create_type(self, type):
        """
        Parameters:
         - type

        """
        self.send_create_type(type)
        return self.recv_create_type()

    def send_create_type(self, type):
        self._oprot.writeMessageBegin("create_type", TMessageType.CALL, self._seqid)
        args = create_type_args()
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result")

    def drop_type(self, type):
        """
        Parameters:
         - type

        """
        self.send_drop_type(type)
        return self.recv_drop_type()

    def send_drop_type(self, type):
        self._oprot.writeMessageBegin("drop_type", TMessageType.CALL, self._seqid)
        args = drop_type_args()
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result")

    def get_type_all(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_type_all(name)
        return self.recv_get_type_all()

    def send_get_type_all(self, name):
        self._oprot.writeMessageBegin("get_type_all", TMessageType.CALL, self._seqid)
        args = get_type_all_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_type_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_type_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result")

    def get_fields(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        self.send_get_fields(db_name, table_name)
        return self.recv_get_fields()

    def send_get_fields(self, db_name, table_name):
        self._oprot.writeMessageBegin("get_fields", TMessageType.CALL, self._seqid)
        args = get_fields_args()
        args.db_name = db_name
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fields(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fields_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result")

    def get_fields_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        self.send_get_fields_with_environment_context(db_name, table_name, environment_context)
        return self.recv_get_fields_with_environment_context()

    def send_get_fields_with_environment_context(self, db_name, table_name, environment_context):
        self._oprot.writeMessageBegin("get_fields_with_environment_context", TMessageType.CALL, self._seqid)
        args = get_fields_with_environment_context_args()
        args.db_name = db_name
        args.table_name = table_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fields_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fields_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_fields_with_environment_context failed: unknown result"
        )

    def get_fields_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_fields_req(req)
        return self.recv_get_fields_req()

    def send_get_fields_req(self, req):
        self._oprot.writeMessageBegin("get_fields_req", TMessageType.CALL, self._seqid)
        args = get_fields_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fields_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fields_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields_req failed: unknown result")

    def get_schema(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        self.send_get_schema(db_name, table_name)
        return self.recv_get_schema()

    def send_get_schema(self, db_name, table_name):
        self._oprot.writeMessageBegin("get_schema", TMessageType.CALL, self._seqid)
        args = get_schema_args()
        args.db_name = db_name
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result")

    def get_schema_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        self.send_get_schema_with_environment_context(db_name, table_name, environment_context)
        return self.recv_get_schema_with_environment_context()

    def send_get_schema_with_environment_context(self, db_name, table_name, environment_context):
        self._oprot.writeMessageBegin("get_schema_with_environment_context", TMessageType.CALL, self._seqid)
        args = get_schema_with_environment_context_args()
        args.db_name = db_name
        args.table_name = table_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_schema_with_environment_context failed: unknown result"
        )

    def get_schema_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_schema_req(req)
        return self.recv_get_schema_req()

    def send_get_schema_req(self, req):
        self._oprot.writeMessageBegin("get_schema_req", TMessageType.CALL, self._seqid)
        args = get_schema_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_req failed: unknown result")

    def create_table(self, tbl):
        """
        Parameters:
         - tbl

        """
        self.send_create_table(tbl)
        self.recv_create_table()

    def send_create_table(self, tbl):
        self._oprot.writeMessageBegin("create_table", TMessageType.CALL, self._seqid)
        args = create_table_args()
        args.tbl = tbl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def create_table_with_environment_context(self, tbl, environment_context):
        """
        Parameters:
         - tbl
         - environment_context

        """
        self.send_create_table_with_environment_context(tbl, environment_context)
        self.recv_create_table_with_environment_context()

    def send_create_table_with_environment_context(self, tbl, environment_context):
        self._oprot.writeMessageBegin("create_table_with_environment_context", TMessageType.CALL, self._seqid)
        args = create_table_with_environment_context_args()
        args.tbl = tbl
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def create_table_with_constraints(
        self, tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints, defaultConstraints, checkConstraints
    ):
        """
        Parameters:
         - tbl
         - primaryKeys
         - foreignKeys
         - uniqueConstraints
         - notNullConstraints
         - defaultConstraints
         - checkConstraints

        """
        self.send_create_table_with_constraints(
            tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints, defaultConstraints, checkConstraints
        )
        self.recv_create_table_with_constraints()

    def send_create_table_with_constraints(
        self, tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints, defaultConstraints, checkConstraints
    ):
        self._oprot.writeMessageBegin("create_table_with_constraints", TMessageType.CALL, self._seqid)
        args = create_table_with_constraints_args()
        args.tbl = tbl
        args.primaryKeys = primaryKeys
        args.foreignKeys = foreignKeys
        args.uniqueConstraints = uniqueConstraints
        args.notNullConstraints = notNullConstraints
        args.defaultConstraints = defaultConstraints
        args.checkConstraints = checkConstraints
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table_with_constraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_with_constraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def create_table_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_create_table_req(request)
        self.recv_create_table_req()

    def send_create_table_req(self, request):
        self._oprot.writeMessageBegin("create_table_req", TMessageType.CALL, self._seqid)
        args = create_table_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def drop_constraint(self, req):
        """
        Parameters:
         - req

        """
        self.send_drop_constraint(req)
        self.recv_drop_constraint()

    def send_drop_constraint(self, req):
        self._oprot.writeMessageBegin("drop_constraint", TMessageType.CALL, self._seqid)
        args = drop_constraint_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_constraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_constraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def add_primary_key(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_primary_key(req)
        self.recv_add_primary_key()

    def send_add_primary_key(self, req):
        self._oprot.writeMessageBegin("add_primary_key", TMessageType.CALL, self._seqid)
        args = add_primary_key_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_primary_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_primary_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_foreign_key(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_foreign_key(req)
        self.recv_add_foreign_key()

    def send_add_foreign_key(self, req):
        self._oprot.writeMessageBegin("add_foreign_key", TMessageType.CALL, self._seqid)
        args = add_foreign_key_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_foreign_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_foreign_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_unique_constraint(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_unique_constraint(req)
        self.recv_add_unique_constraint()

    def send_add_unique_constraint(self, req):
        self._oprot.writeMessageBegin("add_unique_constraint", TMessageType.CALL, self._seqid)
        args = add_unique_constraint_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_unique_constraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_unique_constraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_not_null_constraint(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_not_null_constraint(req)
        self.recv_add_not_null_constraint()

    def send_add_not_null_constraint(self, req):
        self._oprot.writeMessageBegin("add_not_null_constraint", TMessageType.CALL, self._seqid)
        args = add_not_null_constraint_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_not_null_constraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_not_null_constraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_default_constraint(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_default_constraint(req)
        self.recv_add_default_constraint()

    def send_add_default_constraint(self, req):
        self._oprot.writeMessageBegin("add_default_constraint", TMessageType.CALL, self._seqid)
        args = add_default_constraint_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_default_constraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_default_constraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_check_constraint(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_check_constraint(req)
        self.recv_add_check_constraint()

    def send_add_check_constraint(self, req):
        self._oprot.writeMessageBegin("add_check_constraint", TMessageType.CALL, self._seqid)
        args = add_check_constraint_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_check_constraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_check_constraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def translate_table_dryrun(self, request):
        """
        Parameters:
         - request

        """
        self.send_translate_table_dryrun(request)
        return self.recv_translate_table_dryrun()

    def send_translate_table_dryrun(self, request):
        self._oprot.writeMessageBegin("translate_table_dryrun", TMessageType.CALL, self._seqid)
        args = translate_table_dryrun_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_translate_table_dryrun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = translate_table_dryrun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "translate_table_dryrun failed: unknown result")

    def drop_table(self, dbname, name, deleteData):
        """
        Parameters:
         - dbname
         - name
         - deleteData

        """
        self.send_drop_table(dbname, name, deleteData)
        self.recv_drop_table()

    def send_drop_table(self, dbname, name, deleteData):
        self._oprot.writeMessageBegin("drop_table", TMessageType.CALL, self._seqid)
        args = drop_table_args()
        args.dbname = dbname
        args.name = name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        """
        Parameters:
         - dbname
         - name
         - deleteData
         - environment_context

        """
        self.send_drop_table_with_environment_context(dbname, name, deleteData, environment_context)
        self.recv_drop_table_with_environment_context()

    def send_drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        self._oprot.writeMessageBegin("drop_table_with_environment_context", TMessageType.CALL, self._seqid)
        args = drop_table_with_environment_context_args()
        args.dbname = dbname
        args.name = name
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def truncate_table(self, dbName, tableName, partNames):
        """
        Parameters:
         - dbName
         - tableName
         - partNames

        """
        self.send_truncate_table(dbName, tableName, partNames)
        self.recv_truncate_table()

    def send_truncate_table(self, dbName, tableName, partNames):
        self._oprot.writeMessageBegin("truncate_table", TMessageType.CALL, self._seqid)
        args = truncate_table_args()
        args.dbName = dbName
        args.tableName = tableName
        args.partNames = partNames
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_truncate_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = truncate_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def truncate_table_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_truncate_table_req(req)
        return self.recv_truncate_table_req()

    def send_truncate_table_req(self, req):
        self._oprot.writeMessageBegin("truncate_table_req", TMessageType.CALL, self._seqid)
        args = truncate_table_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_truncate_table_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = truncate_table_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "truncate_table_req failed: unknown result")

    def get_tables(self, db_name, pattern):
        """
        Parameters:
         - db_name
         - pattern

        """
        self.send_get_tables(db_name, pattern)
        return self.recv_get_tables()

    def send_get_tables(self, db_name, pattern):
        self._oprot.writeMessageBegin("get_tables", TMessageType.CALL, self._seqid)
        args = get_tables_args()
        args.db_name = db_name
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result")

    def get_tables_by_type(self, db_name, pattern, tableType):
        """
        Parameters:
         - db_name
         - pattern
         - tableType

        """
        self.send_get_tables_by_type(db_name, pattern, tableType)
        return self.recv_get_tables_by_type()

    def send_get_tables_by_type(self, db_name, pattern, tableType):
        self._oprot.writeMessageBegin("get_tables_by_type", TMessageType.CALL, self._seqid)
        args = get_tables_by_type_args()
        args.db_name = db_name
        args.pattern = pattern
        args.tableType = tableType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables_by_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_by_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables_by_type failed: unknown result")

    def get_all_materialized_view_objects_for_rewriting(self):
        self.send_get_all_materialized_view_objects_for_rewriting()
        return self.recv_get_all_materialized_view_objects_for_rewriting()

    def send_get_all_materialized_view_objects_for_rewriting(self):
        self._oprot.writeMessageBegin("get_all_materialized_view_objects_for_rewriting", TMessageType.CALL, self._seqid)
        args = get_all_materialized_view_objects_for_rewriting_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_materialized_view_objects_for_rewriting(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_materialized_view_objects_for_rewriting_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_all_materialized_view_objects_for_rewriting failed: unknown result"
        )

    def get_materialized_views_for_rewriting(self, db_name):
        """
        Parameters:
         - db_name

        """
        self.send_get_materialized_views_for_rewriting(db_name)
        return self.recv_get_materialized_views_for_rewriting()

    def send_get_materialized_views_for_rewriting(self, db_name):
        self._oprot.writeMessageBegin("get_materialized_views_for_rewriting", TMessageType.CALL, self._seqid)
        args = get_materialized_views_for_rewriting_args()
        args.db_name = db_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_materialized_views_for_rewriting(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_materialized_views_for_rewriting_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_materialized_views_for_rewriting failed: unknown result"
        )

    def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        """
        Parameters:
         - db_patterns
         - tbl_patterns
         - tbl_types

        """
        self.send_get_table_meta(db_patterns, tbl_patterns, tbl_types)
        return self.recv_get_table_meta()

    def send_get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        self._oprot.writeMessageBegin("get_table_meta", TMessageType.CALL, self._seqid)
        args = get_table_meta_args()
        args.db_patterns = db_patterns
        args.tbl_patterns = tbl_patterns
        args.tbl_types = tbl_types
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_meta(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_meta_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_meta failed: unknown result")

    def get_all_tables(self, db_name):
        """
        Parameters:
         - db_name

        """
        self.send_get_all_tables(db_name)
        return self.recv_get_all_tables()

    def send_get_all_tables(self, db_name):
        self._oprot.writeMessageBegin("get_all_tables", TMessageType.CALL, self._seqid)
        args = get_all_tables_args()
        args.db_name = db_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result")

    def get_table(self, dbname, tbl_name):
        """
        Parameters:
         - dbname
         - tbl_name

        """
        self.send_get_table(dbname, tbl_name)
        return self.recv_get_table()

    def send_get_table(self, dbname, tbl_name):
        self._oprot.writeMessageBegin("get_table", TMessageType.CALL, self._seqid)
        args = get_table_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result")

    def get_table_objects_by_name(self, dbname, tbl_names):
        """
        Parameters:
         - dbname
         - tbl_names

        """
        self.send_get_table_objects_by_name(dbname, tbl_names)
        return self.recv_get_table_objects_by_name()

    def send_get_table_objects_by_name(self, dbname, tbl_names):
        self._oprot.writeMessageBegin("get_table_objects_by_name", TMessageType.CALL, self._seqid)
        args = get_table_objects_by_name_args()
        args.dbname = dbname
        args.tbl_names = tbl_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_objects_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_objects_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name failed: unknown result")

    def get_tables_ext(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_tables_ext(req)
        return self.recv_get_tables_ext()

    def send_get_tables_ext(self, req):
        self._oprot.writeMessageBegin("get_tables_ext", TMessageType.CALL, self._seqid)
        args = get_tables_ext_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables_ext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_ext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables_ext failed: unknown result")

    def get_table_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_table_req(req)
        return self.recv_get_table_req()

    def send_get_table_req(self, req):
        self._oprot.writeMessageBegin("get_table_req", TMessageType.CALL, self._seqid)
        args = get_table_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_req failed: unknown result")

    def get_table_objects_by_name_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_table_objects_by_name_req(req)
        return self.recv_get_table_objects_by_name_req()

    def send_get_table_objects_by_name_req(self, req):
        self._oprot.writeMessageBegin("get_table_objects_by_name_req", TMessageType.CALL, self._seqid)
        args = get_table_objects_by_name_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_objects_by_name_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_objects_by_name_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name_req failed: unknown result")

    def get_materialization_invalidation_info(self, creation_metadata, validTxnList):
        """
        Parameters:
         - creation_metadata
         - validTxnList

        """
        self.send_get_materialization_invalidation_info(creation_metadata, validTxnList)
        return self.recv_get_materialization_invalidation_info()

    def send_get_materialization_invalidation_info(self, creation_metadata, validTxnList):
        self._oprot.writeMessageBegin("get_materialization_invalidation_info", TMessageType.CALL, self._seqid)
        args = get_materialization_invalidation_info_args()
        args.creation_metadata = creation_metadata
        args.validTxnList = validTxnList
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_materialization_invalidation_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_materialization_invalidation_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_materialization_invalidation_info failed: unknown result"
        )

    def update_creation_metadata(self, catName, dbname, tbl_name, creation_metadata):
        """
        Parameters:
         - catName
         - dbname
         - tbl_name
         - creation_metadata

        """
        self.send_update_creation_metadata(catName, dbname, tbl_name, creation_metadata)
        self.recv_update_creation_metadata()

    def send_update_creation_metadata(self, catName, dbname, tbl_name, creation_metadata):
        self._oprot.writeMessageBegin("update_creation_metadata", TMessageType.CALL, self._seqid)
        args = update_creation_metadata_args()
        args.catName = catName
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.creation_metadata = creation_metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_creation_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_creation_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_table_names_by_filter(self, dbname, filter, max_tables):
        """
        Parameters:
         - dbname
         - filter
         - max_tables

        """
        self.send_get_table_names_by_filter(dbname, filter, max_tables)
        return self.recv_get_table_names_by_filter()

    def send_get_table_names_by_filter(self, dbname, filter, max_tables):
        self._oprot.writeMessageBegin("get_table_names_by_filter", TMessageType.CALL, self._seqid)
        args = get_table_names_by_filter_args()
        args.dbname = dbname
        args.filter = filter
        args.max_tables = max_tables
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_names_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_names_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_names_by_filter failed: unknown result")

    def alter_table(self, dbname, tbl_name, new_tbl):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl

        """
        self.send_alter_table(dbname, tbl_name, new_tbl)
        self.recv_alter_table()

    def send_alter_table(self, dbname, tbl_name, new_tbl):
        self._oprot.writeMessageBegin("alter_table", TMessageType.CALL, self._seqid)
        args = alter_table_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - environment_context

        """
        self.send_alter_table_with_environment_context(dbname, tbl_name, new_tbl, environment_context)
        self.recv_alter_table_with_environment_context()

    def send_alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        self._oprot.writeMessageBegin("alter_table_with_environment_context", TMessageType.CALL, self._seqid)
        args = alter_table_with_environment_context_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - cascade

        """
        self.send_alter_table_with_cascade(dbname, tbl_name, new_tbl, cascade)
        self.recv_alter_table_with_cascade()

    def send_alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        self._oprot.writeMessageBegin("alter_table_with_cascade", TMessageType.CALL, self._seqid)
        args = alter_table_with_cascade_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.cascade = cascade
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table_with_cascade(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_with_cascade_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_table_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_alter_table_req(req)
        return self.recv_alter_table_req()

    def send_alter_table_req(self, req):
        self._oprot.writeMessageBegin("alter_table_req", TMessageType.CALL, self._seqid)
        args = alter_table_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_table_req failed: unknown result")

    def add_partition(self, new_part):
        """
        Parameters:
         - new_part

        """
        self.send_add_partition(new_part)
        return self.recv_add_partition()

    def send_add_partition(self, new_part):
        self._oprot.writeMessageBegin("add_partition", TMessageType.CALL, self._seqid)
        args = add_partition_args()
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result")

    def add_partition_with_environment_context(self, new_part, environment_context):
        """
        Parameters:
         - new_part
         - environment_context

        """
        self.send_add_partition_with_environment_context(new_part, environment_context)
        return self.recv_add_partition_with_environment_context()

    def send_add_partition_with_environment_context(self, new_part, environment_context):
        self._oprot.writeMessageBegin("add_partition_with_environment_context", TMessageType.CALL, self._seqid)
        args = add_partition_with_environment_context_args()
        args.new_part = new_part
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "add_partition_with_environment_context failed: unknown result"
        )

    def add_partitions(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        self.send_add_partitions(new_parts)
        return self.recv_add_partitions()

    def send_add_partitions(self, new_parts):
        self._oprot.writeMessageBegin("add_partitions", TMessageType.CALL, self._seqid)
        args = add_partitions_args()
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions failed: unknown result")

    def add_partitions_pspec(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        self.send_add_partitions_pspec(new_parts)
        return self.recv_add_partitions_pspec()

    def send_add_partitions_pspec(self, new_parts):
        self._oprot.writeMessageBegin("add_partitions_pspec", TMessageType.CALL, self._seqid)
        args = add_partitions_pspec_args()
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions_pspec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_pspec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_pspec failed: unknown result")

    def append_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        self.send_append_partition(db_name, tbl_name, part_vals)
        return self.recv_append_partition()

    def send_append_partition(self, db_name, tbl_name, part_vals):
        self._oprot.writeMessageBegin("append_partition", TMessageType.CALL, self._seqid)
        args = append_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result")

    def add_partitions_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_add_partitions_req(request)
        return self.recv_add_partitions_req()

    def send_add_partitions_req(self, request):
        self._oprot.writeMessageBegin("add_partitions_req", TMessageType.CALL, self._seqid)
        args = add_partitions_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_req failed: unknown result")

    def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - environment_context

        """
        self.send_append_partition_with_environment_context(db_name, tbl_name, part_vals, environment_context)
        return self.recv_append_partition_with_environment_context()

    def send_append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        self._oprot.writeMessageBegin("append_partition_with_environment_context", TMessageType.CALL, self._seqid)
        args = append_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "append_partition_with_environment_context failed: unknown result"
        )

    def append_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        self.send_append_partition_by_name(db_name, tbl_name, part_name)
        return self.recv_append_partition_by_name()

    def send_append_partition_by_name(self, db_name, tbl_name, part_name):
        self._oprot.writeMessageBegin("append_partition_by_name", TMessageType.CALL, self._seqid)
        args = append_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result")

    def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - environment_context

        """
        self.send_append_partition_by_name_with_environment_context(db_name, tbl_name, part_name, environment_context)
        return self.recv_append_partition_by_name_with_environment_context()

    def send_append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        self._oprot.writeMessageBegin("append_partition_by_name_with_environment_context", TMessageType.CALL, self._seqid)
        args = append_partition_by_name_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_by_name_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_by_name_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "append_partition_by_name_with_environment_context failed: unknown result"
        )

    def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData

        """
        self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
        return self.recv_drop_partition()

    def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        self._oprot.writeMessageBegin("drop_partition", TMessageType.CALL, self._seqid)
        args = drop_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result")

    def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
         - environment_context

        """
        self.send_drop_partition_with_environment_context(db_name, tbl_name, part_vals, deleteData, environment_context)
        return self.recv_drop_partition_with_environment_context()

    def send_drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        self._oprot.writeMessageBegin("drop_partition_with_environment_context", TMessageType.CALL, self._seqid)
        args = drop_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "drop_partition_with_environment_context failed: unknown result"
        )

    def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData

        """
        self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
        return self.recv_drop_partition_by_name()

    def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        self._oprot.writeMessageBegin("drop_partition_by_name", TMessageType.CALL, self._seqid)
        args = drop_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result")

    def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
         - environment_context

        """
        self.send_drop_partition_by_name_with_environment_context(db_name, tbl_name, part_name, deleteData, environment_context)
        return self.recv_drop_partition_by_name_with_environment_context()

    def send_drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        self._oprot.writeMessageBegin("drop_partition_by_name_with_environment_context", TMessageType.CALL, self._seqid)
        args = drop_partition_by_name_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_by_name_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_by_name_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "drop_partition_by_name_with_environment_context failed: unknown result"
        )

    def drop_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_drop_partitions_req(req)
        return self.recv_drop_partitions_req()

    def send_drop_partitions_req(self, req):
        self._oprot.writeMessageBegin("drop_partitions_req", TMessageType.CALL, self._seqid)
        args = drop_partitions_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partitions_req failed: unknown result")

    def get_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        self.send_get_partition(db_name, tbl_name, part_vals)
        return self.recv_get_partition()

    def send_get_partition(self, db_name, tbl_name, part_vals):
        self._oprot.writeMessageBegin("get_partition", TMessageType.CALL, self._seqid)
        args = get_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result")

    def get_partition_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partition_req(req)
        return self.recv_get_partition_req()

    def send_get_partition_req(self, req):
        self._oprot.writeMessageBegin("get_partition_req", TMessageType.CALL, self._seqid)
        args = get_partition_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_req failed: unknown result")

    def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        self.send_exchange_partition(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
        return self.recv_exchange_partition()

    def send_exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        self._oprot.writeMessageBegin("exchange_partition", TMessageType.CALL, self._seqid)
        args = exchange_partition_args()
        args.partitionSpecs = partitionSpecs
        args.source_db = source_db
        args.source_table_name = source_table_name
        args.dest_db = dest_db
        args.dest_table_name = dest_table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exchange_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exchange_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partition failed: unknown result")

    def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        self.send_exchange_partitions(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
        return self.recv_exchange_partitions()

    def send_exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        self._oprot.writeMessageBegin("exchange_partitions", TMessageType.CALL, self._seqid)
        args = exchange_partitions_args()
        args.partitionSpecs = partitionSpecs
        args.source_db = source_db
        args.source_table_name = source_table_name
        args.dest_db = dest_db
        args.dest_table_name = dest_table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exchange_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exchange_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partitions failed: unknown result")

    def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - user_name
         - group_names

        """
        self.send_get_partition_with_auth(db_name, tbl_name, part_vals, user_name, group_names)
        return self.recv_get_partition_with_auth()

    def send_get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        self._oprot.writeMessageBegin("get_partition_with_auth", TMessageType.CALL, self._seqid)
        args = get_partition_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_with_auth failed: unknown result")

    def get_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        self.send_get_partition_by_name(db_name, tbl_name, part_name)
        return self.recv_get_partition_by_name()

    def send_get_partition_by_name(self, db_name, tbl_name, part_name):
        self._oprot.writeMessageBegin("get_partition_by_name", TMessageType.CALL, self._seqid)
        args = get_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result")

    def get_partitions(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        self.send_get_partitions(db_name, tbl_name, max_parts)
        return self.recv_get_partitions()

    def send_get_partitions(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin("get_partitions", TMessageType.CALL, self._seqid)
        args = get_partitions_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result")

    def get_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partitions_req(req)
        return self.recv_get_partitions_req()

    def send_get_partitions_req(self, req):
        self._oprot.writeMessageBegin("get_partitions_req", TMessageType.CALL, self._seqid)
        args = get_partitions_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_req failed: unknown result")

    def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
         - user_name
         - group_names

        """
        self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)
        return self.recv_get_partitions_with_auth()

    def send_get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        self._oprot.writeMessageBegin("get_partitions_with_auth", TMessageType.CALL, self._seqid)
        args = get_partitions_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_auth failed: unknown result")

    def get_partitions_pspec(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        self.send_get_partitions_pspec(db_name, tbl_name, max_parts)
        return self.recv_get_partitions_pspec()

    def send_get_partitions_pspec(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin("get_partitions_pspec", TMessageType.CALL, self._seqid)
        args = get_partitions_pspec_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_pspec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_pspec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_pspec failed: unknown result")

    def get_partition_names(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        self.send_get_partition_names(db_name, tbl_name, max_parts)
        return self.recv_get_partition_names()

    def send_get_partition_names(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin("get_partition_names", TMessageType.CALL, self._seqid)
        args = get_partition_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result")

    def get_partition_values(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_partition_values(request)
        return self.recv_get_partition_values()

    def send_get_partition_values(self, request):
        self._oprot.writeMessageBegin("get_partition_values", TMessageType.CALL, self._seqid)
        args = get_partition_values_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_values(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_values_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_values failed: unknown result")

    def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
        return self.recv_get_partitions_ps()

    def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        self._oprot.writeMessageBegin("get_partitions_ps", TMessageType.CALL, self._seqid)
        args = get_partitions_ps_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_ps(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_ps_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result")

    def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
         - user_name
         - group_names

        """
        self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)
        return self.recv_get_partitions_ps_with_auth()

    def send_get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        self._oprot.writeMessageBegin("get_partitions_ps_with_auth", TMessageType.CALL, self._seqid)
        args = get_partitions_ps_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_ps_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_ps_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth failed: unknown result")

    def get_partitions_ps_with_auth_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partitions_ps_with_auth_req(req)
        return self.recv_get_partitions_ps_with_auth_req()

    def send_get_partitions_ps_with_auth_req(self, req):
        self._oprot.writeMessageBegin("get_partitions_ps_with_auth_req", TMessageType.CALL, self._seqid)
        args = get_partitions_ps_with_auth_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_ps_with_auth_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_ps_with_auth_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth_req failed: unknown result"
        )

    def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
        return self.recv_get_partition_names_ps()

    def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        self._oprot.writeMessageBegin("get_partition_names_ps", TMessageType.CALL, self._seqid)
        args = get_partition_names_ps_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names_ps(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_ps_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result")

    def get_partition_names_ps_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partition_names_ps_req(req)
        return self.recv_get_partition_names_ps_req()

    def send_get_partition_names_ps_req(self, req):
        self._oprot.writeMessageBegin("get_partition_names_ps_req", TMessageType.CALL, self._seqid)
        args = get_partition_names_ps_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names_ps_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_ps_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps_req failed: unknown result")

    def get_partition_names_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partition_names_req(req)
        return self.recv_get_partition_names_req()

    def send_get_partition_names_req(self, req):
        self._oprot.writeMessageBegin("get_partition_names_req", TMessageType.CALL, self._seqid)
        args = get_partition_names_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_req failed: unknown result")

    def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)
        return self.recv_get_partitions_by_filter()

    def send_get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        self._oprot.writeMessageBegin("get_partitions_by_filter", TMessageType.CALL, self._seqid)
        args = get_partitions_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result")

    def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        self.send_get_part_specs_by_filter(db_name, tbl_name, filter, max_parts)
        return self.recv_get_part_specs_by_filter()

    def send_get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        self._oprot.writeMessageBegin("get_part_specs_by_filter", TMessageType.CALL, self._seqid)
        args = get_part_specs_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_part_specs_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_part_specs_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_part_specs_by_filter failed: unknown result")

    def get_partitions_by_expr(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partitions_by_expr(req)
        return self.recv_get_partitions_by_expr()

    def send_get_partitions_by_expr(self, req):
        self._oprot.writeMessageBegin("get_partitions_by_expr", TMessageType.CALL, self._seqid)
        args = get_partitions_by_expr_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_expr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_expr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_expr failed: unknown result")

    def get_partitions_spec_by_expr(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partitions_spec_by_expr(req)
        return self.recv_get_partitions_spec_by_expr()

    def send_get_partitions_spec_by_expr(self, req):
        self._oprot.writeMessageBegin("get_partitions_spec_by_expr", TMessageType.CALL, self._seqid)
        args = get_partitions_spec_by_expr_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_spec_by_expr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_spec_by_expr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_spec_by_expr failed: unknown result")

    def get_num_partitions_by_filter(self, db_name, tbl_name, filter):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter

        """
        self.send_get_num_partitions_by_filter(db_name, tbl_name, filter)
        return self.recv_get_num_partitions_by_filter()

    def send_get_num_partitions_by_filter(self, db_name, tbl_name, filter):
        self._oprot.writeMessageBegin("get_num_partitions_by_filter", TMessageType.CALL, self._seqid)
        args = get_num_partitions_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_num_partitions_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_num_partitions_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_num_partitions_by_filter failed: unknown result")

    def get_partitions_by_names(self, db_name, tbl_name, names):
        """
        Parameters:
         - db_name
         - tbl_name
         - names

        """
        self.send_get_partitions_by_names(db_name, tbl_name, names)
        return self.recv_get_partitions_by_names()

    def send_get_partitions_by_names(self, db_name, tbl_name, names):
        self._oprot.writeMessageBegin("get_partitions_by_names", TMessageType.CALL, self._seqid)
        args = get_partitions_by_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.names = names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names failed: unknown result")

    def get_partitions_by_names_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partitions_by_names_req(req)
        return self.recv_get_partitions_by_names_req()

    def send_get_partitions_by_names_req(self, req):
        self._oprot.writeMessageBegin("get_partitions_by_names_req", TMessageType.CALL, self._seqid)
        args = get_partitions_by_names_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_names_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_names_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names_req failed: unknown result")

    def alter_partition(self, db_name, tbl_name, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part

        """
        self.send_alter_partition(db_name, tbl_name, new_part)
        self.recv_alter_partition()

    def send_alter_partition(self, db_name, tbl_name, new_part):
        self._oprot.writeMessageBegin("alter_partition", TMessageType.CALL, self._seqid)
        args = alter_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partitions(self, db_name, tbl_name, new_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts

        """
        self.send_alter_partitions(db_name, tbl_name, new_parts)
        self.recv_alter_partitions()

    def send_alter_partitions(self, db_name, tbl_name, new_parts):
        self._oprot.writeMessageBegin("alter_partitions", TMessageType.CALL, self._seqid)
        args = alter_partitions_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts
         - environment_context

        """
        self.send_alter_partitions_with_environment_context(db_name, tbl_name, new_parts, environment_context)
        self.recv_alter_partitions_with_environment_context()

    def send_alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
        self._oprot.writeMessageBegin("alter_partitions_with_environment_context", TMessageType.CALL, self._seqid)
        args = alter_partitions_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_parts = new_parts
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partitions_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partitions_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_alter_partitions_req(req)
        return self.recv_alter_partitions_req()

    def send_alter_partitions_req(self, req):
        self._oprot.writeMessageBegin("alter_partitions_req", TMessageType.CALL, self._seqid)
        args = alter_partitions_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_partitions_req failed: unknown result")

    def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
         - environment_context

        """
        self.send_alter_partition_with_environment_context(db_name, tbl_name, new_part, environment_context)
        self.recv_alter_partition_with_environment_context()

    def send_alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        self._oprot.writeMessageBegin("alter_partition_with_environment_context", TMessageType.CALL, self._seqid)
        args = alter_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_part = new_part
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def rename_partition(self, db_name, tbl_name, part_vals, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - new_part

        """
        self.send_rename_partition(db_name, tbl_name, part_vals, new_part)
        self.recv_rename_partition()

    def send_rename_partition(self, db_name, tbl_name, part_vals, new_part):
        self._oprot.writeMessageBegin("rename_partition", TMessageType.CALL, self._seqid)
        args = rename_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rename_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rename_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def rename_partition_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_rename_partition_req(req)
        return self.recv_rename_partition_req()

    def send_rename_partition_req(self, req):
        self._oprot.writeMessageBegin("rename_partition_req", TMessageType.CALL, self._seqid)
        args = rename_partition_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rename_partition_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rename_partition_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rename_partition_req failed: unknown result")

    def partition_name_has_valid_characters(self, part_vals, throw_exception):
        """
        Parameters:
         - part_vals
         - throw_exception

        """
        self.send_partition_name_has_valid_characters(part_vals, throw_exception)
        return self.recv_partition_name_has_valid_characters()

    def send_partition_name_has_valid_characters(self, part_vals, throw_exception):
        self._oprot.writeMessageBegin("partition_name_has_valid_characters", TMessageType.CALL, self._seqid)
        args = partition_name_has_valid_characters_args()
        args.part_vals = part_vals
        args.throw_exception = throw_exception
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_has_valid_characters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_has_valid_characters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "partition_name_has_valid_characters failed: unknown result"
        )

    def get_config_value(self, name, defaultValue):
        """
        Parameters:
         - name
         - defaultValue

        """
        self.send_get_config_value(name, defaultValue)
        return self.recv_get_config_value()

    def send_get_config_value(self, name, defaultValue):
        self._oprot.writeMessageBegin("get_config_value", TMessageType.CALL, self._seqid)
        args = get_config_value_args()
        args.name = name
        args.defaultValue = defaultValue
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_config_value(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_config_value_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result")

    def partition_name_to_vals(self, part_name):
        """
        Parameters:
         - part_name

        """
        self.send_partition_name_to_vals(part_name)
        return self.recv_partition_name_to_vals()

    def send_partition_name_to_vals(self, part_name):
        self._oprot.writeMessageBegin("partition_name_to_vals", TMessageType.CALL, self._seqid)
        args = partition_name_to_vals_args()
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_to_vals(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_to_vals_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result")

    def partition_name_to_spec(self, part_name):
        """
        Parameters:
         - part_name

        """
        self.send_partition_name_to_spec(part_name)
        return self.recv_partition_name_to_spec()

    def send_partition_name_to_spec(self, part_name):
        self._oprot.writeMessageBegin("partition_name_to_spec", TMessageType.CALL, self._seqid)
        args = partition_name_to_spec_args()
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_to_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_to_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result")

    def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)
        self.recv_markPartitionForEvent()

    def send_markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        self._oprot.writeMessageBegin("markPartitionForEvent", TMessageType.CALL, self._seqid)
        args = markPartitionForEvent_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.eventType = eventType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_markPartitionForEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = markPartitionForEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        if result.o5 is not None:
            raise result.o5
        if result.o6 is not None:
            raise result.o6
        return

    def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)
        return self.recv_isPartitionMarkedForEvent()

    def send_isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        self._oprot.writeMessageBegin("isPartitionMarkedForEvent", TMessageType.CALL, self._seqid)
        args = isPartitionMarkedForEvent_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.eventType = eventType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isPartitionMarkedForEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isPartitionMarkedForEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        if result.o5 is not None:
            raise result.o5
        if result.o6 is not None:
            raise result.o6
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isPartitionMarkedForEvent failed: unknown result")

    def get_primary_keys(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_primary_keys(request)
        return self.recv_get_primary_keys()

    def send_get_primary_keys(self, request):
        self._oprot.writeMessageBegin("get_primary_keys", TMessageType.CALL, self._seqid)
        args = get_primary_keys_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_primary_keys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_primary_keys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_primary_keys failed: unknown result")

    def get_foreign_keys(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_foreign_keys(request)
        return self.recv_get_foreign_keys()

    def send_get_foreign_keys(self, request):
        self._oprot.writeMessageBegin("get_foreign_keys", TMessageType.CALL, self._seqid)
        args = get_foreign_keys_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_foreign_keys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_foreign_keys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_foreign_keys failed: unknown result")

    def get_unique_constraints(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_unique_constraints(request)
        return self.recv_get_unique_constraints()

    def send_get_unique_constraints(self, request):
        self._oprot.writeMessageBegin("get_unique_constraints", TMessageType.CALL, self._seqid)
        args = get_unique_constraints_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_unique_constraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_unique_constraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_unique_constraints failed: unknown result")

    def get_not_null_constraints(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_not_null_constraints(request)
        return self.recv_get_not_null_constraints()

    def send_get_not_null_constraints(self, request):
        self._oprot.writeMessageBegin("get_not_null_constraints", TMessageType.CALL, self._seqid)
        args = get_not_null_constraints_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_not_null_constraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_not_null_constraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_not_null_constraints failed: unknown result")

    def get_default_constraints(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_default_constraints(request)
        return self.recv_get_default_constraints()

    def send_get_default_constraints(self, request):
        self._oprot.writeMessageBegin("get_default_constraints", TMessageType.CALL, self._seqid)
        args = get_default_constraints_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_default_constraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_default_constraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_default_constraints failed: unknown result")

    def get_check_constraints(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_check_constraints(request)
        return self.recv_get_check_constraints()

    def send_get_check_constraints(self, request):
        self._oprot.writeMessageBegin("get_check_constraints", TMessageType.CALL, self._seqid)
        args = get_check_constraints_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_check_constraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_check_constraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_check_constraints failed: unknown result")

    def get_all_table_constraints(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_all_table_constraints(request)
        return self.recv_get_all_table_constraints()

    def send_get_all_table_constraints(self, request):
        self._oprot.writeMessageBegin("get_all_table_constraints", TMessageType.CALL, self._seqid)
        args = get_all_table_constraints_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_table_constraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_table_constraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_table_constraints failed: unknown result")

    def update_table_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        self.send_update_table_column_statistics(stats_obj)
        return self.recv_update_table_column_statistics()

    def send_update_table_column_statistics(self, stats_obj):
        self._oprot.writeMessageBegin("update_table_column_statistics", TMessageType.CALL, self._seqid)
        args = update_table_column_statistics_args()
        args.stats_obj = stats_obj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "update_table_column_statistics failed: unknown result")

    def update_partition_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        self.send_update_partition_column_statistics(stats_obj)
        return self.recv_update_partition_column_statistics()

    def send_update_partition_column_statistics(self, stats_obj):
        self._oprot.writeMessageBegin("update_partition_column_statistics", TMessageType.CALL, self._seqid)
        args = update_partition_column_statistics_args()
        args.stats_obj = stats_obj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "update_partition_column_statistics failed: unknown result"
        )

    def update_table_column_statistics_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_update_table_column_statistics_req(req)
        return self.recv_update_table_column_statistics_req()

    def send_update_table_column_statistics_req(self, req):
        self._oprot.writeMessageBegin("update_table_column_statistics_req", TMessageType.CALL, self._seqid)
        args = update_table_column_statistics_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_table_column_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_table_column_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "update_table_column_statistics_req failed: unknown result"
        )

    def update_partition_column_statistics_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_update_partition_column_statistics_req(req)
        return self.recv_update_partition_column_statistics_req()

    def send_update_partition_column_statistics_req(self, req):
        self._oprot.writeMessageBegin("update_partition_column_statistics_req", TMessageType.CALL, self._seqid)
        args = update_partition_column_statistics_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_partition_column_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_partition_column_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "update_partition_column_statistics_req failed: unknown result"
        )

    def update_transaction_statistics(self, req):
        """
        Parameters:
         - req

        """
        self.send_update_transaction_statistics(req)
        self.recv_update_transaction_statistics()

    def send_update_transaction_statistics(self, req):
        self._oprot.writeMessageBegin("update_transaction_statistics", TMessageType.CALL, self._seqid)
        args = update_transaction_statistics_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_transaction_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_transaction_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def get_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name

        """
        self.send_get_table_column_statistics(db_name, tbl_name, col_name)
        return self.recv_get_table_column_statistics()

    def send_get_table_column_statistics(self, db_name, tbl_name, col_name):
        self._oprot.writeMessageBegin("get_table_column_statistics", TMessageType.CALL, self._seqid)
        args = get_table_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_column_statistics failed: unknown result")

    def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name

        """
        self.send_get_partition_column_statistics(db_name, tbl_name, part_name, col_name)
        return self.recv_get_partition_column_statistics()

    def send_get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        self._oprot.writeMessageBegin("get_partition_column_statistics", TMessageType.CALL, self._seqid)
        args = get_partition_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_partition_column_statistics failed: unknown result"
        )

    def get_table_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_table_statistics_req(request)
        return self.recv_get_table_statistics_req()

    def send_get_table_statistics_req(self, request):
        self._oprot.writeMessageBegin("get_table_statistics_req", TMessageType.CALL, self._seqid)
        args = get_table_statistics_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_statistics_req failed: unknown result")

    def get_partitions_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_partitions_statistics_req(request)
        return self.recv_get_partitions_statistics_req()

    def send_get_partitions_statistics_req(self, request):
        self._oprot.writeMessageBegin("get_partitions_statistics_req", TMessageType.CALL, self._seqid)
        args = get_partitions_statistics_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_statistics_req failed: unknown result")

    def get_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_aggr_stats_for(request)
        return self.recv_get_aggr_stats_for()

    def send_get_aggr_stats_for(self, request):
        self._oprot.writeMessageBegin("get_aggr_stats_for", TMessageType.CALL, self._seqid)
        args = get_aggr_stats_for_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_aggr_stats_for(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_aggr_stats_for_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_aggr_stats_for failed: unknown result")

    def set_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        self.send_set_aggr_stats_for(request)
        return self.recv_set_aggr_stats_for()

    def send_set_aggr_stats_for(self, request):
        self._oprot.writeMessageBegin("set_aggr_stats_for", TMessageType.CALL, self._seqid)
        args = set_aggr_stats_for_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_aggr_stats_for(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_aggr_stats_for_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_aggr_stats_for failed: unknown result")

    def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name, engine):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name
         - engine

        """
        self.send_delete_partition_column_statistics(db_name, tbl_name, part_name, col_name, engine)
        return self.recv_delete_partition_column_statistics()

    def send_delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name, engine):
        self._oprot.writeMessageBegin("delete_partition_column_statistics", TMessageType.CALL, self._seqid)
        args = delete_partition_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.col_name = col_name
        args.engine = engine
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "delete_partition_column_statistics failed: unknown result"
        )

    def delete_table_column_statistics(self, db_name, tbl_name, col_name, engine):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name
         - engine

        """
        self.send_delete_table_column_statistics(db_name, tbl_name, col_name, engine)
        return self.recv_delete_table_column_statistics()

    def send_delete_table_column_statistics(self, db_name, tbl_name, col_name, engine):
        self._oprot.writeMessageBegin("delete_table_column_statistics", TMessageType.CALL, self._seqid)
        args = delete_table_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.col_name = col_name
        args.engine = engine
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_table_column_statistics failed: unknown result")

    def create_function(self, func):
        """
        Parameters:
         - func

        """
        self.send_create_function(func)
        self.recv_create_function()

    def send_create_function(self, func):
        self._oprot.writeMessageBegin("create_function", TMessageType.CALL, self._seqid)
        args = create_function_args()
        args.func = func
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def drop_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        self.send_drop_function(dbName, funcName)
        self.recv_drop_function()

    def send_drop_function(self, dbName, funcName):
        self._oprot.writeMessageBegin("drop_function", TMessageType.CALL, self._seqid)
        args = drop_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def alter_function(self, dbName, funcName, newFunc):
        """
        Parameters:
         - dbName
         - funcName
         - newFunc

        """
        self.send_alter_function(dbName, funcName, newFunc)
        self.recv_alter_function()

    def send_alter_function(self, dbName, funcName, newFunc):
        self._oprot.writeMessageBegin("alter_function", TMessageType.CALL, self._seqid)
        args = alter_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.newFunc = newFunc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_functions(self, dbName, pattern):
        """
        Parameters:
         - dbName
         - pattern

        """
        self.send_get_functions(dbName, pattern)
        return self.recv_get_functions()

    def send_get_functions(self, dbName, pattern):
        self._oprot.writeMessageBegin("get_functions", TMessageType.CALL, self._seqid)
        args = get_functions_args()
        args.dbName = dbName
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_functions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_functions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_functions failed: unknown result")

    def get_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        self.send_get_function(dbName, funcName)
        return self.recv_get_function()

    def send_get_function(self, dbName, funcName):
        self._oprot.writeMessageBegin("get_function", TMessageType.CALL, self._seqid)
        args = get_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function failed: unknown result")

    def get_all_functions(self):
        self.send_get_all_functions()
        return self.recv_get_all_functions()

    def send_get_all_functions(self):
        self._oprot.writeMessageBegin("get_all_functions", TMessageType.CALL, self._seqid)
        args = get_all_functions_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_functions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_functions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_functions failed: unknown result")

    def create_role(self, role):
        """
        Parameters:
         - role

        """
        self.send_create_role(role)
        return self.recv_create_role()

    def send_create_role(self, role):
        self._oprot.writeMessageBegin("create_role", TMessageType.CALL, self._seqid)
        args = create_role_args()
        args.role = role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_role failed: unknown result")

    def drop_role(self, role_name):
        """
        Parameters:
         - role_name

        """
        self.send_drop_role(role_name)
        return self.recv_drop_role()

    def send_drop_role(self, role_name):
        self._oprot.writeMessageBegin("drop_role", TMessageType.CALL, self._seqid)
        args = drop_role_args()
        args.role_name = role_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_role failed: unknown result")

    def get_role_names(self):
        self.send_get_role_names()
        return self.recv_get_role_names()

    def send_get_role_names(self):
        self._oprot.writeMessageBegin("get_role_names", TMessageType.CALL, self._seqid)
        args = get_role_names_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_role_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_role_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_names failed: unknown result")

    def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
         - grantor
         - grantorType
         - grant_option

        """
        self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)
        return self.recv_grant_role()

    def send_grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        self._oprot.writeMessageBegin("grant_role", TMessageType.CALL, self._seqid)
        args = grant_role_args()
        args.role_name = role_name
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.grantor = grantor
        args.grantorType = grantorType
        args.grant_option = grant_option
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_role failed: unknown result")

    def revoke_role(self, role_name, principal_name, principal_type):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type

        """
        self.send_revoke_role(role_name, principal_name, principal_type)
        return self.recv_revoke_role()

    def send_revoke_role(self, role_name, principal_name, principal_type):
        self._oprot.writeMessageBegin("revoke_role", TMessageType.CALL, self._seqid)
        args = revoke_role_args()
        args.role_name = role_name
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revoke_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revoke_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_role failed: unknown result")

    def list_roles(self, principal_name, principal_type):
        """
        Parameters:
         - principal_name
         - principal_type

        """
        self.send_list_roles(principal_name, principal_type)
        return self.recv_list_roles()

    def send_list_roles(self, principal_name, principal_type):
        self._oprot.writeMessageBegin("list_roles", TMessageType.CALL, self._seqid)
        args = list_roles_args()
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_list_roles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = list_roles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "list_roles failed: unknown result")

    def grant_revoke_role(self, request):
        """
        Parameters:
         - request

        """
        self.send_grant_revoke_role(request)
        return self.recv_grant_revoke_role()

    def send_grant_revoke_role(self, request):
        self._oprot.writeMessageBegin("grant_revoke_role", TMessageType.CALL, self._seqid)
        args = grant_revoke_role_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_revoke_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_revoke_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_role failed: unknown result")

    def get_principals_in_role(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_principals_in_role(request)
        return self.recv_get_principals_in_role()

    def send_get_principals_in_role(self, request):
        self._oprot.writeMessageBegin("get_principals_in_role", TMessageType.CALL, self._seqid)
        args = get_principals_in_role_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_principals_in_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_principals_in_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_principals_in_role failed: unknown result")

    def get_role_grants_for_principal(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_role_grants_for_principal(request)
        return self.recv_get_role_grants_for_principal()

    def send_get_role_grants_for_principal(self, request):
        self._oprot.writeMessageBegin("get_role_grants_for_principal", TMessageType.CALL, self._seqid)
        args = get_role_grants_for_principal_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_role_grants_for_principal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_role_grants_for_principal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_grants_for_principal failed: unknown result")

    def get_privilege_set(self, hiveObject, user_name, group_names):
        """
        Parameters:
         - hiveObject
         - user_name
         - group_names

        """
        self.send_get_privilege_set(hiveObject, user_name, group_names)
        return self.recv_get_privilege_set()

    def send_get_privilege_set(self, hiveObject, user_name, group_names):
        self._oprot.writeMessageBegin("get_privilege_set", TMessageType.CALL, self._seqid)
        args = get_privilege_set_args()
        args.hiveObject = hiveObject
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_privilege_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_privilege_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_privilege_set failed: unknown result")

    def list_privileges(self, principal_name, principal_type, hiveObject):
        """
        Parameters:
         - principal_name
         - principal_type
         - hiveObject

        """
        self.send_list_privileges(principal_name, principal_type, hiveObject)
        return self.recv_list_privileges()

    def send_list_privileges(self, principal_name, principal_type, hiveObject):
        self._oprot.writeMessageBegin("list_privileges", TMessageType.CALL, self._seqid)
        args = list_privileges_args()
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.hiveObject = hiveObject
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_list_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = list_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "list_privileges failed: unknown result")

    def grant_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        self.send_grant_privileges(privileges)
        return self.recv_grant_privileges()

    def send_grant_privileges(self, privileges):
        self._oprot.writeMessageBegin("grant_privileges", TMessageType.CALL, self._seqid)
        args = grant_privileges_args()
        args.privileges = privileges
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_privileges failed: unknown result")

    def revoke_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        self.send_revoke_privileges(privileges)
        return self.recv_revoke_privileges()

    def send_revoke_privileges(self, privileges):
        self._oprot.writeMessageBegin("revoke_privileges", TMessageType.CALL, self._seqid)
        args = revoke_privileges_args()
        args.privileges = privileges
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revoke_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revoke_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_privileges failed: unknown result")

    def grant_revoke_privileges(self, request):
        """
        Parameters:
         - request

        """
        self.send_grant_revoke_privileges(request)
        return self.recv_grant_revoke_privileges()

    def send_grant_revoke_privileges(self, request):
        self._oprot.writeMessageBegin("grant_revoke_privileges", TMessageType.CALL, self._seqid)
        args = grant_revoke_privileges_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_revoke_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_revoke_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_privileges failed: unknown result")

    def refresh_privileges(self, objToRefresh, authorizer, grantRequest):
        """
        Parameters:
         - objToRefresh
         - authorizer
         - grantRequest

        """
        self.send_refresh_privileges(objToRefresh, authorizer, grantRequest)
        return self.recv_refresh_privileges()

    def send_refresh_privileges(self, objToRefresh, authorizer, grantRequest):
        self._oprot.writeMessageBegin("refresh_privileges", TMessageType.CALL, self._seqid)
        args = refresh_privileges_args()
        args.objToRefresh = objToRefresh
        args.authorizer = authorizer
        args.grantRequest = grantRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_refresh_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = refresh_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "refresh_privileges failed: unknown result")

    def set_ugi(self, user_name, group_names):
        """
        Parameters:
         - user_name
         - group_names

        """
        self.send_set_ugi(user_name, group_names)
        return self.recv_set_ugi()

    def send_set_ugi(self, user_name, group_names):
        self._oprot.writeMessageBegin("set_ugi", TMessageType.CALL, self._seqid)
        args = set_ugi_args()
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_ugi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_ugi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_ugi failed: unknown result")

    def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        """
        Parameters:
         - token_owner
         - renewer_kerberos_principal_name

        """
        self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)
        return self.recv_get_delegation_token()

    def send_get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        self._oprot.writeMessageBegin("get_delegation_token", TMessageType.CALL, self._seqid)
        args = get_delegation_token_args()
        args.token_owner = token_owner
        args.renewer_kerberos_principal_name = renewer_kerberos_principal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_delegation_token failed: unknown result")

    def renew_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        self.send_renew_delegation_token(token_str_form)
        return self.recv_renew_delegation_token()

    def send_renew_delegation_token(self, token_str_form):
        self._oprot.writeMessageBegin("renew_delegation_token", TMessageType.CALL, self._seqid)
        args = renew_delegation_token_args()
        args.token_str_form = token_str_form
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_renew_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = renew_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "renew_delegation_token failed: unknown result")

    def cancel_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        self.send_cancel_delegation_token(token_str_form)
        self.recv_cancel_delegation_token()

    def send_cancel_delegation_token(self, token_str_form):
        self._oprot.writeMessageBegin("cancel_delegation_token", TMessageType.CALL, self._seqid)
        args = cancel_delegation_token_args()
        args.token_str_form = token_str_form
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def add_token(self, token_identifier, delegation_token):
        """
        Parameters:
         - token_identifier
         - delegation_token

        """
        self.send_add_token(token_identifier, delegation_token)
        return self.recv_add_token()

    def send_add_token(self, token_identifier, delegation_token):
        self._oprot.writeMessageBegin("add_token", TMessageType.CALL, self._seqid)
        args = add_token_args()
        args.token_identifier = token_identifier
        args.delegation_token = delegation_token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_token failed: unknown result")

    def remove_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        self.send_remove_token(token_identifier)
        return self.recv_remove_token()

    def send_remove_token(self, token_identifier):
        self._oprot.writeMessageBegin("remove_token", TMessageType.CALL, self._seqid)
        args = remove_token_args()
        args.token_identifier = token_identifier
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_token failed: unknown result")

    def get_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        self.send_get_token(token_identifier)
        return self.recv_get_token()

    def send_get_token(self, token_identifier):
        self._oprot.writeMessageBegin("get_token", TMessageType.CALL, self._seqid)
        args = get_token_args()
        args.token_identifier = token_identifier
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_token failed: unknown result")

    def get_all_token_identifiers(self):
        self.send_get_all_token_identifiers()
        return self.recv_get_all_token_identifiers()

    def send_get_all_token_identifiers(self):
        self._oprot.writeMessageBegin("get_all_token_identifiers", TMessageType.CALL, self._seqid)
        args = get_all_token_identifiers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_token_identifiers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_token_identifiers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_token_identifiers failed: unknown result")

    def add_master_key(self, key):
        """
        Parameters:
         - key

        """
        self.send_add_master_key(key)
        return self.recv_add_master_key()

    def send_add_master_key(self, key):
        self._oprot.writeMessageBegin("add_master_key", TMessageType.CALL, self._seqid)
        args = add_master_key_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_master_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_master_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_master_key failed: unknown result")

    def update_master_key(self, seq_number, key):
        """
        Parameters:
         - seq_number
         - key

        """
        self.send_update_master_key(seq_number, key)
        self.recv_update_master_key()

    def send_update_master_key(self, seq_number, key):
        self._oprot.writeMessageBegin("update_master_key", TMessageType.CALL, self._seqid)
        args = update_master_key_args()
        args.seq_number = seq_number
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_master_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_master_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def remove_master_key(self, key_seq):
        """
        Parameters:
         - key_seq

        """
        self.send_remove_master_key(key_seq)
        return self.recv_remove_master_key()

    def send_remove_master_key(self, key_seq):
        self._oprot.writeMessageBegin("remove_master_key", TMessageType.CALL, self._seqid)
        args = remove_master_key_args()
        args.key_seq = key_seq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_master_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_master_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_master_key failed: unknown result")

    def get_master_keys(self):
        self.send_get_master_keys()
        return self.recv_get_master_keys()

    def send_get_master_keys(self):
        self._oprot.writeMessageBegin("get_master_keys", TMessageType.CALL, self._seqid)
        args = get_master_keys_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_master_keys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_master_keys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_master_keys failed: unknown result")

    def get_open_txns(self):
        self.send_get_open_txns()
        return self.recv_get_open_txns()

    def send_get_open_txns(self):
        self._oprot.writeMessageBegin("get_open_txns", TMessageType.CALL, self._seqid)
        args = get_open_txns_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_open_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_open_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns failed: unknown result")

    def get_open_txns_info(self):
        self.send_get_open_txns_info()
        return self.recv_get_open_txns_info()

    def send_get_open_txns_info(self):
        self._oprot.writeMessageBegin("get_open_txns_info", TMessageType.CALL, self._seqid)
        args = get_open_txns_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_open_txns_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_open_txns_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns_info failed: unknown result")

    def open_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_open_txns(rqst)
        return self.recv_open_txns()

    def send_open_txns(self, rqst):
        self._oprot.writeMessageBegin("open_txns", TMessageType.CALL, self._seqid)
        args = open_txns_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_txns failed: unknown result")

    def abort_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_abort_txn(rqst)
        self.recv_abort_txn()

    def send_abort_txn(self, rqst):
        self._oprot.writeMessageBegin("abort_txn", TMessageType.CALL, self._seqid)
        args = abort_txn_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def abort_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_abort_txns(rqst)
        self.recv_abort_txns()

    def send_abort_txns(self, rqst):
        self._oprot.writeMessageBegin("abort_txns", TMessageType.CALL, self._seqid)
        args = abort_txns_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def commit_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_commit_txn(rqst)
        self.recv_commit_txn()

    def send_commit_txn(self, rqst):
        self._oprot.writeMessageBegin("commit_txn", TMessageType.CALL, self._seqid)
        args = commit_txn_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_latest_txnid_in_conflict(self, txnId):
        """
        Parameters:
         - txnId

        """
        self.send_get_latest_txnid_in_conflict(txnId)
        return self.recv_get_latest_txnid_in_conflict()

    def send_get_latest_txnid_in_conflict(self, txnId):
        self._oprot.writeMessageBegin("get_latest_txnid_in_conflict", TMessageType.CALL, self._seqid)
        args = get_latest_txnid_in_conflict_args()
        args.txnId = txnId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_latest_txnid_in_conflict(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_latest_txnid_in_conflict_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_latest_txnid_in_conflict failed: unknown result")

    def repl_tbl_writeid_state(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_repl_tbl_writeid_state(rqst)
        self.recv_repl_tbl_writeid_state()

    def send_repl_tbl_writeid_state(self, rqst):
        self._oprot.writeMessageBegin("repl_tbl_writeid_state", TMessageType.CALL, self._seqid)
        args = repl_tbl_writeid_state_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_repl_tbl_writeid_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = repl_tbl_writeid_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_valid_write_ids(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_valid_write_ids(rqst)
        return self.recv_get_valid_write_ids()

    def send_get_valid_write_ids(self, rqst):
        self._oprot.writeMessageBegin("get_valid_write_ids", TMessageType.CALL, self._seqid)
        args = get_valid_write_ids_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_valid_write_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_valid_write_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_valid_write_ids failed: unknown result")

    def allocate_table_write_ids(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_allocate_table_write_ids(rqst)
        return self.recv_allocate_table_write_ids()

    def send_allocate_table_write_ids(self, rqst):
        self._oprot.writeMessageBegin("allocate_table_write_ids", TMessageType.CALL, self._seqid)
        args = allocate_table_write_ids_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_allocate_table_write_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = allocate_table_write_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "allocate_table_write_ids failed: unknown result")

    def get_max_allocated_table_write_id(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_max_allocated_table_write_id(rqst)
        return self.recv_get_max_allocated_table_write_id()

    def send_get_max_allocated_table_write_id(self, rqst):
        self._oprot.writeMessageBegin("get_max_allocated_table_write_id", TMessageType.CALL, self._seqid)
        args = get_max_allocated_table_write_id_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_max_allocated_table_write_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_max_allocated_table_write_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_max_allocated_table_write_id failed: unknown result"
        )

    def seed_write_id(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_seed_write_id(rqst)
        self.recv_seed_write_id()

    def send_seed_write_id(self, rqst):
        self._oprot.writeMessageBegin("seed_write_id", TMessageType.CALL, self._seqid)
        args = seed_write_id_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_seed_write_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = seed_write_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def seed_txn_id(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_seed_txn_id(rqst)
        self.recv_seed_txn_id()

    def send_seed_txn_id(self, rqst):
        self._oprot.writeMessageBegin("seed_txn_id", TMessageType.CALL, self._seqid)
        args = seed_txn_id_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_seed_txn_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = seed_txn_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_lock(rqst)
        return self.recv_lock()

    def send_lock(self, rqst):
        self._oprot.writeMessageBegin("lock", TMessageType.CALL, self._seqid)
        args = lock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_lock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = lock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "lock failed: unknown result")

    def check_lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_check_lock(rqst)
        return self.recv_check_lock()

    def send_check_lock(self, rqst):
        self._oprot.writeMessageBegin("check_lock", TMessageType.CALL, self._seqid)
        args = check_lock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_lock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_lock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_lock failed: unknown result")

    def unlock(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_unlock(rqst)
        self.recv_unlock()

    def send_unlock(self, rqst):
        self._oprot.writeMessageBegin("unlock", TMessageType.CALL, self._seqid)
        args = unlock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unlock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unlock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def show_locks(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_show_locks(rqst)
        return self.recv_show_locks()

    def send_show_locks(self, rqst):
        self._oprot.writeMessageBegin("show_locks", TMessageType.CALL, self._seqid)
        args = show_locks_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_show_locks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = show_locks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "show_locks failed: unknown result")

    def heartbeat(self, ids):
        """
        Parameters:
         - ids

        """
        self.send_heartbeat(ids)
        self.recv_heartbeat()

    def send_heartbeat(self, ids):
        self._oprot.writeMessageBegin("heartbeat", TMessageType.CALL, self._seqid)
        args = heartbeat_args()
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_heartbeat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = heartbeat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def heartbeat_txn_range(self, txns):
        """
        Parameters:
         - txns

        """
        self.send_heartbeat_txn_range(txns)
        return self.recv_heartbeat_txn_range()

    def send_heartbeat_txn_range(self, txns):
        self._oprot.writeMessageBegin("heartbeat_txn_range", TMessageType.CALL, self._seqid)
        args = heartbeat_txn_range_args()
        args.txns = txns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_heartbeat_txn_range(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = heartbeat_txn_range_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "heartbeat_txn_range failed: unknown result")

    def compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_compact(rqst)
        self.recv_compact()

    def send_compact(self, rqst):
        self._oprot.writeMessageBegin("compact", TMessageType.CALL, self._seqid)
        args = compact_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def compact2(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_compact2(rqst)
        return self.recv_compact2()

    def send_compact2(self, rqst):
        self._oprot.writeMessageBegin("compact2", TMessageType.CALL, self._seqid)
        args = compact2_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compact2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compact2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compact2 failed: unknown result")

    def show_compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_show_compact(rqst)
        return self.recv_show_compact()

    def send_show_compact(self, rqst):
        self._oprot.writeMessageBegin("show_compact", TMessageType.CALL, self._seqid)
        args = show_compact_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_show_compact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = show_compact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "show_compact failed: unknown result")

    def add_dynamic_partitions(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_add_dynamic_partitions(rqst)
        self.recv_add_dynamic_partitions()

    def send_add_dynamic_partitions(self, rqst):
        self._oprot.writeMessageBegin("add_dynamic_partitions", TMessageType.CALL, self._seqid)
        args = add_dynamic_partitions_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_dynamic_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_dynamic_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def find_next_compact(self, workerId):
        """
        Parameters:
         - workerId

        """
        self.send_find_next_compact(workerId)
        return self.recv_find_next_compact()

    def send_find_next_compact(self, workerId):
        self._oprot.writeMessageBegin("find_next_compact", TMessageType.CALL, self._seqid)
        args = find_next_compact_args()
        args.workerId = workerId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_find_next_compact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = find_next_compact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "find_next_compact failed: unknown result")

    def find_next_compact2(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_find_next_compact2(rqst)
        return self.recv_find_next_compact2()

    def send_find_next_compact2(self, rqst):
        self._oprot.writeMessageBegin("find_next_compact2", TMessageType.CALL, self._seqid)
        args = find_next_compact2_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_find_next_compact2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = find_next_compact2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "find_next_compact2 failed: unknown result")

    def update_compactor_state(self, cr, txn_id):
        """
        Parameters:
         - cr
         - txn_id

        """
        self.send_update_compactor_state(cr, txn_id)
        self.recv_update_compactor_state()

    def send_update_compactor_state(self, cr, txn_id):
        self._oprot.writeMessageBegin("update_compactor_state", TMessageType.CALL, self._seqid)
        args = update_compactor_state_args()
        args.cr = cr
        args.txn_id = txn_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_compactor_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_compactor_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def find_columns_with_stats(self, cr):
        """
        Parameters:
         - cr

        """
        self.send_find_columns_with_stats(cr)
        return self.recv_find_columns_with_stats()

    def send_find_columns_with_stats(self, cr):
        self._oprot.writeMessageBegin("find_columns_with_stats", TMessageType.CALL, self._seqid)
        args = find_columns_with_stats_args()
        args.cr = cr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_find_columns_with_stats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = find_columns_with_stats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "find_columns_with_stats failed: unknown result")

    def mark_cleaned(self, cr):
        """
        Parameters:
         - cr

        """
        self.send_mark_cleaned(cr)
        self.recv_mark_cleaned()

    def send_mark_cleaned(self, cr):
        self._oprot.writeMessageBegin("mark_cleaned", TMessageType.CALL, self._seqid)
        args = mark_cleaned_args()
        args.cr = cr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mark_cleaned(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mark_cleaned_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def mark_compacted(self, cr):
        """
        Parameters:
         - cr

        """
        self.send_mark_compacted(cr)
        self.recv_mark_compacted()

    def send_mark_compacted(self, cr):
        self._oprot.writeMessageBegin("mark_compacted", TMessageType.CALL, self._seqid)
        args = mark_compacted_args()
        args.cr = cr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mark_compacted(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mark_compacted_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def mark_failed(self, cr):
        """
        Parameters:
         - cr

        """
        self.send_mark_failed(cr)
        self.recv_mark_failed()

    def send_mark_failed(self, cr):
        self._oprot.writeMessageBegin("mark_failed", TMessageType.CALL, self._seqid)
        args = mark_failed_args()
        args.cr = cr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mark_failed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mark_failed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def mark_refused(self, cr):
        """
        Parameters:
         - cr

        """
        self.send_mark_refused(cr)
        self.recv_mark_refused()

    def send_mark_refused(self, cr):
        self._oprot.writeMessageBegin("mark_refused", TMessageType.CALL, self._seqid)
        args = mark_refused_args()
        args.cr = cr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mark_refused(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mark_refused_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def update_compaction_metrics_data(self, data):
        """
        Parameters:
         - data

        """
        self.send_update_compaction_metrics_data(data)
        return self.recv_update_compaction_metrics_data()

    def send_update_compaction_metrics_data(self, data):
        self._oprot.writeMessageBegin("update_compaction_metrics_data", TMessageType.CALL, self._seqid)
        args = update_compaction_metrics_data_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_compaction_metrics_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_compaction_metrics_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "update_compaction_metrics_data failed: unknown result")

    def remove_compaction_metrics_data(self, request):
        """
        Parameters:
         - request

        """
        self.send_remove_compaction_metrics_data(request)
        self.recv_remove_compaction_metrics_data()

    def send_remove_compaction_metrics_data(self, request):
        self._oprot.writeMessageBegin("remove_compaction_metrics_data", TMessageType.CALL, self._seqid)
        args = remove_compaction_metrics_data_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_compaction_metrics_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_compaction_metrics_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def set_hadoop_jobid(self, jobId, cq_id):
        """
        Parameters:
         - jobId
         - cq_id

        """
        self.send_set_hadoop_jobid(jobId, cq_id)
        self.recv_set_hadoop_jobid()

    def send_set_hadoop_jobid(self, jobId, cq_id):
        self._oprot.writeMessageBegin("set_hadoop_jobid", TMessageType.CALL, self._seqid)
        args = set_hadoop_jobid_args()
        args.jobId = jobId
        args.cq_id = cq_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_hadoop_jobid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_hadoop_jobid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_latest_committed_compaction_info(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_latest_committed_compaction_info(rqst)
        return self.recv_get_latest_committed_compaction_info()

    def send_get_latest_committed_compaction_info(self, rqst):
        self._oprot.writeMessageBegin("get_latest_committed_compaction_info", TMessageType.CALL, self._seqid)
        args = get_latest_committed_compaction_info_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_latest_committed_compaction_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_latest_committed_compaction_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_latest_committed_compaction_info failed: unknown result"
        )

    def get_next_notification(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_next_notification(rqst)
        return self.recv_get_next_notification()

    def send_get_next_notification(self, rqst):
        self._oprot.writeMessageBegin("get_next_notification", TMessageType.CALL, self._seqid)
        args = get_next_notification_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_next_notification(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_next_notification_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_next_notification failed: unknown result")

    def get_current_notificationEventId(self):
        self.send_get_current_notificationEventId()
        return self.recv_get_current_notificationEventId()

    def send_get_current_notificationEventId(self):
        self._oprot.writeMessageBegin("get_current_notificationEventId", TMessageType.CALL, self._seqid)
        args = get_current_notificationEventId_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_current_notificationEventId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_current_notificationEventId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_current_notificationEventId failed: unknown result"
        )

    def get_notification_events_count(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_notification_events_count(rqst)
        return self.recv_get_notification_events_count()

    def send_get_notification_events_count(self, rqst):
        self._oprot.writeMessageBegin("get_notification_events_count", TMessageType.CALL, self._seqid)
        args = get_notification_events_count_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_notification_events_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_notification_events_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_notification_events_count failed: unknown result")

    def fire_listener_event(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_fire_listener_event(rqst)
        return self.recv_fire_listener_event()

    def send_fire_listener_event(self, rqst):
        self._oprot.writeMessageBegin("fire_listener_event", TMessageType.CALL, self._seqid)
        args = fire_listener_event_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fire_listener_event(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fire_listener_event_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fire_listener_event failed: unknown result")

    def flushCache(self):
        self.send_flushCache()
        self.recv_flushCache()

    def send_flushCache(self):
        self._oprot.writeMessageBegin("flushCache", TMessageType.CALL, self._seqid)
        args = flushCache_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_flushCache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = flushCache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def add_write_notification_log(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_add_write_notification_log(rqst)
        return self.recv_add_write_notification_log()

    def send_add_write_notification_log(self, rqst):
        self._oprot.writeMessageBegin("add_write_notification_log", TMessageType.CALL, self._seqid)
        args = add_write_notification_log_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_write_notification_log(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_write_notification_log_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_write_notification_log failed: unknown result")

    def add_write_notification_log_in_batch(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_add_write_notification_log_in_batch(rqst)
        return self.recv_add_write_notification_log_in_batch()

    def send_add_write_notification_log_in_batch(self, rqst):
        self._oprot.writeMessageBegin("add_write_notification_log_in_batch", TMessageType.CALL, self._seqid)
        args = add_write_notification_log_in_batch_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_write_notification_log_in_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_write_notification_log_in_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "add_write_notification_log_in_batch failed: unknown result"
        )

    def cm_recycle(self, request):
        """
        Parameters:
         - request

        """
        self.send_cm_recycle(request)
        return self.recv_cm_recycle()

    def send_cm_recycle(self, request):
        self._oprot.writeMessageBegin("cm_recycle", TMessageType.CALL, self._seqid)
        args = cm_recycle_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cm_recycle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cm_recycle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cm_recycle failed: unknown result")

    def get_file_metadata_by_expr(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_file_metadata_by_expr(req)
        return self.recv_get_file_metadata_by_expr()

    def send_get_file_metadata_by_expr(self, req):
        self._oprot.writeMessageBegin("get_file_metadata_by_expr", TMessageType.CALL, self._seqid)
        args = get_file_metadata_by_expr_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_file_metadata_by_expr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_file_metadata_by_expr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata_by_expr failed: unknown result")

    def get_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_file_metadata(req)
        return self.recv_get_file_metadata()

    def send_get_file_metadata(self, req):
        self._oprot.writeMessageBegin("get_file_metadata", TMessageType.CALL, self._seqid)
        args = get_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata failed: unknown result")

    def put_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_put_file_metadata(req)
        return self.recv_put_file_metadata()

    def send_put_file_metadata(self, req):
        self._oprot.writeMessageBegin("put_file_metadata", TMessageType.CALL, self._seqid)
        args = put_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_put_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = put_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "put_file_metadata failed: unknown result")

    def clear_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_clear_file_metadata(req)
        return self.recv_clear_file_metadata()

    def send_clear_file_metadata(self, req):
        self._oprot.writeMessageBegin("clear_file_metadata", TMessageType.CALL, self._seqid)
        args = clear_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clear_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clear_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "clear_file_metadata failed: unknown result")

    def cache_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_cache_file_metadata(req)
        return self.recv_cache_file_metadata()

    def send_cache_file_metadata(self, req):
        self._oprot.writeMessageBegin("cache_file_metadata", TMessageType.CALL, self._seqid)
        args = cache_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cache_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cache_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cache_file_metadata failed: unknown result")

    def get_metastore_db_uuid(self):
        self.send_get_metastore_db_uuid()
        return self.recv_get_metastore_db_uuid()

    def send_get_metastore_db_uuid(self):
        self._oprot.writeMessageBegin("get_metastore_db_uuid", TMessageType.CALL, self._seqid)
        args = get_metastore_db_uuid_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_metastore_db_uuid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_metastore_db_uuid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_metastore_db_uuid failed: unknown result")

    def create_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        self.send_create_resource_plan(request)
        return self.recv_create_resource_plan()

    def send_create_resource_plan(self, request):
        self._oprot.writeMessageBegin("create_resource_plan", TMessageType.CALL, self._seqid)
        args = create_resource_plan_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_resource_plan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_resource_plan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_resource_plan failed: unknown result")

    def get_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_resource_plan(request)
        return self.recv_get_resource_plan()

    def send_get_resource_plan(self, request):
        self._oprot.writeMessageBegin("get_resource_plan", TMessageType.CALL, self._seqid)
        args = get_resource_plan_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_resource_plan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_resource_plan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_resource_plan failed: unknown result")

    def get_active_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_active_resource_plan(request)
        return self.recv_get_active_resource_plan()

    def send_get_active_resource_plan(self, request):
        self._oprot.writeMessageBegin("get_active_resource_plan", TMessageType.CALL, self._seqid)
        args = get_active_resource_plan_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_active_resource_plan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_active_resource_plan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_active_resource_plan failed: unknown result")

    def get_all_resource_plans(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_all_resource_plans(request)
        return self.recv_get_all_resource_plans()

    def send_get_all_resource_plans(self, request):
        self._oprot.writeMessageBegin("get_all_resource_plans", TMessageType.CALL, self._seqid)
        args = get_all_resource_plans_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_resource_plans(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_resource_plans_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_resource_plans failed: unknown result")

    def alter_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        self.send_alter_resource_plan(request)
        return self.recv_alter_resource_plan()

    def send_alter_resource_plan(self, request):
        self._oprot.writeMessageBegin("alter_resource_plan", TMessageType.CALL, self._seqid)
        args = alter_resource_plan_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_resource_plan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_resource_plan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_resource_plan failed: unknown result")

    def validate_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        self.send_validate_resource_plan(request)
        return self.recv_validate_resource_plan()

    def send_validate_resource_plan(self, request):
        self._oprot.writeMessageBegin("validate_resource_plan", TMessageType.CALL, self._seqid)
        args = validate_resource_plan_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_validate_resource_plan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = validate_resource_plan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "validate_resource_plan failed: unknown result")

    def drop_resource_plan(self, request):
        """
        Parameters:
         - request

        """
        self.send_drop_resource_plan(request)
        return self.recv_drop_resource_plan()

    def send_drop_resource_plan(self, request):
        self._oprot.writeMessageBegin("drop_resource_plan", TMessageType.CALL, self._seqid)
        args = drop_resource_plan_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_resource_plan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_resource_plan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_resource_plan failed: unknown result")

    def create_wm_trigger(self, request):
        """
        Parameters:
         - request

        """
        self.send_create_wm_trigger(request)
        return self.recv_create_wm_trigger()

    def send_create_wm_trigger(self, request):
        self._oprot.writeMessageBegin("create_wm_trigger", TMessageType.CALL, self._seqid)
        args = create_wm_trigger_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_wm_trigger(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_wm_trigger_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_wm_trigger failed: unknown result")

    def alter_wm_trigger(self, request):
        """
        Parameters:
         - request

        """
        self.send_alter_wm_trigger(request)
        return self.recv_alter_wm_trigger()

    def send_alter_wm_trigger(self, request):
        self._oprot.writeMessageBegin("alter_wm_trigger", TMessageType.CALL, self._seqid)
        args = alter_wm_trigger_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_wm_trigger(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_wm_trigger_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_wm_trigger failed: unknown result")

    def drop_wm_trigger(self, request):
        """
        Parameters:
         - request

        """
        self.send_drop_wm_trigger(request)
        return self.recv_drop_wm_trigger()

    def send_drop_wm_trigger(self, request):
        self._oprot.writeMessageBegin("drop_wm_trigger", TMessageType.CALL, self._seqid)
        args = drop_wm_trigger_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_wm_trigger(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_wm_trigger_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_wm_trigger failed: unknown result")

    def get_triggers_for_resourceplan(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_triggers_for_resourceplan(request)
        return self.recv_get_triggers_for_resourceplan()

    def send_get_triggers_for_resourceplan(self, request):
        self._oprot.writeMessageBegin("get_triggers_for_resourceplan", TMessageType.CALL, self._seqid)
        args = get_triggers_for_resourceplan_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_triggers_for_resourceplan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_triggers_for_resourceplan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_triggers_for_resourceplan failed: unknown result")

    def create_wm_pool(self, request):
        """
        Parameters:
         - request

        """
        self.send_create_wm_pool(request)
        return self.recv_create_wm_pool()

    def send_create_wm_pool(self, request):
        self._oprot.writeMessageBegin("create_wm_pool", TMessageType.CALL, self._seqid)
        args = create_wm_pool_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_wm_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_wm_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_wm_pool failed: unknown result")

    def alter_wm_pool(self, request):
        """
        Parameters:
         - request

        """
        self.send_alter_wm_pool(request)
        return self.recv_alter_wm_pool()

    def send_alter_wm_pool(self, request):
        self._oprot.writeMessageBegin("alter_wm_pool", TMessageType.CALL, self._seqid)
        args = alter_wm_pool_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_wm_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_wm_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_wm_pool failed: unknown result")

    def drop_wm_pool(self, request):
        """
        Parameters:
         - request

        """
        self.send_drop_wm_pool(request)
        return self.recv_drop_wm_pool()

    def send_drop_wm_pool(self, request):
        self._oprot.writeMessageBegin("drop_wm_pool", TMessageType.CALL, self._seqid)
        args = drop_wm_pool_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_wm_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_wm_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_wm_pool failed: unknown result")

    def create_or_update_wm_mapping(self, request):
        """
        Parameters:
         - request

        """
        self.send_create_or_update_wm_mapping(request)
        return self.recv_create_or_update_wm_mapping()

    def send_create_or_update_wm_mapping(self, request):
        self._oprot.writeMessageBegin("create_or_update_wm_mapping", TMessageType.CALL, self._seqid)
        args = create_or_update_wm_mapping_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_or_update_wm_mapping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_or_update_wm_mapping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_or_update_wm_mapping failed: unknown result")

    def drop_wm_mapping(self, request):
        """
        Parameters:
         - request

        """
        self.send_drop_wm_mapping(request)
        return self.recv_drop_wm_mapping()

    def send_drop_wm_mapping(self, request):
        self._oprot.writeMessageBegin("drop_wm_mapping", TMessageType.CALL, self._seqid)
        args = drop_wm_mapping_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_wm_mapping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_wm_mapping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_wm_mapping failed: unknown result")

    def create_or_drop_wm_trigger_to_pool_mapping(self, request):
        """
        Parameters:
         - request

        """
        self.send_create_or_drop_wm_trigger_to_pool_mapping(request)
        return self.recv_create_or_drop_wm_trigger_to_pool_mapping()

    def send_create_or_drop_wm_trigger_to_pool_mapping(self, request):
        self._oprot.writeMessageBegin("create_or_drop_wm_trigger_to_pool_mapping", TMessageType.CALL, self._seqid)
        args = create_or_drop_wm_trigger_to_pool_mapping_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_or_drop_wm_trigger_to_pool_mapping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_or_drop_wm_trigger_to_pool_mapping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "create_or_drop_wm_trigger_to_pool_mapping failed: unknown result"
        )

    def create_ischema(self, schema):
        """
        Parameters:
         - schema

        """
        self.send_create_ischema(schema)
        self.recv_create_ischema()

    def send_create_ischema(self, schema):
        self._oprot.writeMessageBegin("create_ischema", TMessageType.CALL, self._seqid)
        args = create_ischema_args()
        args.schema = schema
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_ischema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_ischema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def alter_ischema(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_alter_ischema(rqst)
        self.recv_alter_ischema()

    def send_alter_ischema(self, rqst):
        self._oprot.writeMessageBegin("alter_ischema", TMessageType.CALL, self._seqid)
        args = alter_ischema_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_ischema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_ischema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_ischema(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_ischema(name)
        return self.recv_get_ischema()

    def send_get_ischema(self, name):
        self._oprot.writeMessageBegin("get_ischema", TMessageType.CALL, self._seqid)
        args = get_ischema_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_ischema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_ischema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_ischema failed: unknown result")

    def drop_ischema(self, name):
        """
        Parameters:
         - name

        """
        self.send_drop_ischema(name)
        self.recv_drop_ischema()

    def send_drop_ischema(self, name):
        self._oprot.writeMessageBegin("drop_ischema", TMessageType.CALL, self._seqid)
        args = drop_ischema_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_ischema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_ischema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def add_schema_version(self, schemaVersion):
        """
        Parameters:
         - schemaVersion

        """
        self.send_add_schema_version(schemaVersion)
        self.recv_add_schema_version()

    def send_add_schema_version(self, schemaVersion):
        self._oprot.writeMessageBegin("add_schema_version", TMessageType.CALL, self._seqid)
        args = add_schema_version_args()
        args.schemaVersion = schemaVersion
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_schema_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_schema_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_schema_version(self, schemaVersion):
        """
        Parameters:
         - schemaVersion

        """
        self.send_get_schema_version(schemaVersion)
        return self.recv_get_schema_version()

    def send_get_schema_version(self, schemaVersion):
        self._oprot.writeMessageBegin("get_schema_version", TMessageType.CALL, self._seqid)
        args = get_schema_version_args()
        args.schemaVersion = schemaVersion
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_version failed: unknown result")

    def get_schema_latest_version(self, schemaName):
        """
        Parameters:
         - schemaName

        """
        self.send_get_schema_latest_version(schemaName)
        return self.recv_get_schema_latest_version()

    def send_get_schema_latest_version(self, schemaName):
        self._oprot.writeMessageBegin("get_schema_latest_version", TMessageType.CALL, self._seqid)
        args = get_schema_latest_version_args()
        args.schemaName = schemaName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_latest_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_latest_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_latest_version failed: unknown result")

    def get_schema_all_versions(self, schemaName):
        """
        Parameters:
         - schemaName

        """
        self.send_get_schema_all_versions(schemaName)
        return self.recv_get_schema_all_versions()

    def send_get_schema_all_versions(self, schemaName):
        self._oprot.writeMessageBegin("get_schema_all_versions", TMessageType.CALL, self._seqid)
        args = get_schema_all_versions_args()
        args.schemaName = schemaName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_all_versions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_all_versions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_all_versions failed: unknown result")

    def drop_schema_version(self, schemaVersion):
        """
        Parameters:
         - schemaVersion

        """
        self.send_drop_schema_version(schemaVersion)
        self.recv_drop_schema_version()

    def send_drop_schema_version(self, schemaVersion):
        self._oprot.writeMessageBegin("drop_schema_version", TMessageType.CALL, self._seqid)
        args = drop_schema_version_args()
        args.schemaVersion = schemaVersion
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_schema_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_schema_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_schemas_by_cols(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_schemas_by_cols(rqst)
        return self.recv_get_schemas_by_cols()

    def send_get_schemas_by_cols(self, rqst):
        self._oprot.writeMessageBegin("get_schemas_by_cols", TMessageType.CALL, self._seqid)
        args = get_schemas_by_cols_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schemas_by_cols(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schemas_by_cols_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schemas_by_cols failed: unknown result")

    def map_schema_version_to_serde(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_map_schema_version_to_serde(rqst)
        self.recv_map_schema_version_to_serde()

    def send_map_schema_version_to_serde(self, rqst):
        self._oprot.writeMessageBegin("map_schema_version_to_serde", TMessageType.CALL, self._seqid)
        args = map_schema_version_to_serde_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_map_schema_version_to_serde(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = map_schema_version_to_serde_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def set_schema_version_state(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_set_schema_version_state(rqst)
        self.recv_set_schema_version_state()

    def send_set_schema_version_state(self, rqst):
        self._oprot.writeMessageBegin("set_schema_version_state", TMessageType.CALL, self._seqid)
        args = set_schema_version_state_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_schema_version_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_schema_version_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def add_serde(self, serde):
        """
        Parameters:
         - serde

        """
        self.send_add_serde(serde)
        self.recv_add_serde()

    def send_add_serde(self, serde):
        self._oprot.writeMessageBegin("add_serde", TMessageType.CALL, self._seqid)
        args = add_serde_args()
        args.serde = serde
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_serde(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_serde_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_serde(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_serde(rqst)
        return self.recv_get_serde()

    def send_get_serde(self, rqst):
        self._oprot.writeMessageBegin("get_serde", TMessageType.CALL, self._seqid)
        args = get_serde_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_serde(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_serde_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_serde failed: unknown result")

    def get_lock_materialization_rebuild(self, dbName, tableName, txnId):
        """
        Parameters:
         - dbName
         - tableName
         - txnId

        """
        self.send_get_lock_materialization_rebuild(dbName, tableName, txnId)
        return self.recv_get_lock_materialization_rebuild()

    def send_get_lock_materialization_rebuild(self, dbName, tableName, txnId):
        self._oprot.writeMessageBegin("get_lock_materialization_rebuild", TMessageType.CALL, self._seqid)
        args = get_lock_materialization_rebuild_args()
        args.dbName = dbName
        args.tableName = tableName
        args.txnId = txnId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_lock_materialization_rebuild(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_lock_materialization_rebuild_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_lock_materialization_rebuild failed: unknown result"
        )

    def heartbeat_lock_materialization_rebuild(self, dbName, tableName, txnId):
        """
        Parameters:
         - dbName
         - tableName
         - txnId

        """
        self.send_heartbeat_lock_materialization_rebuild(dbName, tableName, txnId)
        return self.recv_heartbeat_lock_materialization_rebuild()

    def send_heartbeat_lock_materialization_rebuild(self, dbName, tableName, txnId):
        self._oprot.writeMessageBegin("heartbeat_lock_materialization_rebuild", TMessageType.CALL, self._seqid)
        args = heartbeat_lock_materialization_rebuild_args()
        args.dbName = dbName
        args.tableName = tableName
        args.txnId = txnId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_heartbeat_lock_materialization_rebuild(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = heartbeat_lock_materialization_rebuild_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "heartbeat_lock_materialization_rebuild failed: unknown result"
        )

    def add_runtime_stats(self, stat):
        """
        Parameters:
         - stat

        """
        self.send_add_runtime_stats(stat)
        self.recv_add_runtime_stats()

    def send_add_runtime_stats(self, stat):
        self._oprot.writeMessageBegin("add_runtime_stats", TMessageType.CALL, self._seqid)
        args = add_runtime_stats_args()
        args.stat = stat
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_runtime_stats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_runtime_stats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def get_runtime_stats(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_runtime_stats(rqst)
        return self.recv_get_runtime_stats()

    def send_get_runtime_stats(self, rqst):
        self._oprot.writeMessageBegin("get_runtime_stats", TMessageType.CALL, self._seqid)
        args = get_runtime_stats_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_runtime_stats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_runtime_stats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_runtime_stats failed: unknown result")

    def get_partitions_with_specs(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_partitions_with_specs(request)
        return self.recv_get_partitions_with_specs()

    def send_get_partitions_with_specs(self, request):
        self._oprot.writeMessageBegin("get_partitions_with_specs", TMessageType.CALL, self._seqid)
        args = get_partitions_with_specs_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_with_specs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_with_specs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_specs failed: unknown result")

    def scheduled_query_poll(self, request):
        """
        Parameters:
         - request

        """
        self.send_scheduled_query_poll(request)
        return self.recv_scheduled_query_poll()

    def send_scheduled_query_poll(self, request):
        self._oprot.writeMessageBegin("scheduled_query_poll", TMessageType.CALL, self._seqid)
        args = scheduled_query_poll_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scheduled_query_poll(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scheduled_query_poll_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scheduled_query_poll failed: unknown result")

    def scheduled_query_maintenance(self, request):
        """
        Parameters:
         - request

        """
        self.send_scheduled_query_maintenance(request)
        self.recv_scheduled_query_maintenance()

    def send_scheduled_query_maintenance(self, request):
        self._oprot.writeMessageBegin("scheduled_query_maintenance", TMessageType.CALL, self._seqid)
        args = scheduled_query_maintenance_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scheduled_query_maintenance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scheduled_query_maintenance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def scheduled_query_progress(self, info):
        """
        Parameters:
         - info

        """
        self.send_scheduled_query_progress(info)
        self.recv_scheduled_query_progress()

    def send_scheduled_query_progress(self, info):
        self._oprot.writeMessageBegin("scheduled_query_progress", TMessageType.CALL, self._seqid)
        args = scheduled_query_progress_args()
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scheduled_query_progress(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scheduled_query_progress_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_scheduled_query(self, scheduleKey):
        """
        Parameters:
         - scheduleKey

        """
        self.send_get_scheduled_query(scheduleKey)
        return self.recv_get_scheduled_query()

    def send_get_scheduled_query(self, scheduleKey):
        self._oprot.writeMessageBegin("get_scheduled_query", TMessageType.CALL, self._seqid)
        args = get_scheduled_query_args()
        args.scheduleKey = scheduleKey
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_scheduled_query(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_scheduled_query_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_scheduled_query failed: unknown result")

    def add_replication_metrics(self, replicationMetricList):
        """
        Parameters:
         - replicationMetricList

        """
        self.send_add_replication_metrics(replicationMetricList)
        self.recv_add_replication_metrics()

    def send_add_replication_metrics(self, replicationMetricList):
        self._oprot.writeMessageBegin("add_replication_metrics", TMessageType.CALL, self._seqid)
        args = add_replication_metrics_args()
        args.replicationMetricList = replicationMetricList
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_replication_metrics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_replication_metrics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def get_replication_metrics(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_replication_metrics(rqst)
        return self.recv_get_replication_metrics()

    def send_get_replication_metrics(self, rqst):
        self._oprot.writeMessageBegin("get_replication_metrics", TMessageType.CALL, self._seqid)
        args = get_replication_metrics_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_replication_metrics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_replication_metrics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_replication_metrics failed: unknown result")

    def get_open_txns_req(self, getOpenTxnsRequest):
        """
        Parameters:
         - getOpenTxnsRequest

        """
        self.send_get_open_txns_req(getOpenTxnsRequest)
        return self.recv_get_open_txns_req()

    def send_get_open_txns_req(self, getOpenTxnsRequest):
        self._oprot.writeMessageBegin("get_open_txns_req", TMessageType.CALL, self._seqid)
        args = get_open_txns_req_args()
        args.getOpenTxnsRequest = getOpenTxnsRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_open_txns_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_open_txns_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns_req failed: unknown result")

    def create_stored_procedure(self, proc):
        """
        Parameters:
         - proc

        """
        self.send_create_stored_procedure(proc)
        self.recv_create_stored_procedure()

    def send_create_stored_procedure(self, proc):
        self._oprot.writeMessageBegin("create_stored_procedure", TMessageType.CALL, self._seqid)
        args = create_stored_procedure_args()
        args.proc = proc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_stored_procedure(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_stored_procedure_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_stored_procedure(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_stored_procedure(request)
        return self.recv_get_stored_procedure()

    def send_get_stored_procedure(self, request):
        self._oprot.writeMessageBegin("get_stored_procedure", TMessageType.CALL, self._seqid)
        args = get_stored_procedure_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_stored_procedure(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_stored_procedure_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_stored_procedure failed: unknown result")

    def drop_stored_procedure(self, request):
        """
        Parameters:
         - request

        """
        self.send_drop_stored_procedure(request)
        self.recv_drop_stored_procedure()

    def send_drop_stored_procedure(self, request):
        self._oprot.writeMessageBegin("drop_stored_procedure", TMessageType.CALL, self._seqid)
        args = drop_stored_procedure_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_stored_procedure(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_stored_procedure_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def get_all_stored_procedures(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_all_stored_procedures(request)
        return self.recv_get_all_stored_procedures()

    def send_get_all_stored_procedures(self, request):
        self._oprot.writeMessageBegin("get_all_stored_procedures", TMessageType.CALL, self._seqid)
        args = get_all_stored_procedures_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_stored_procedures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_stored_procedures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_stored_procedures failed: unknown result")

    def find_package(self, request):
        """
        Parameters:
         - request

        """
        self.send_find_package(request)
        return self.recv_find_package()

    def send_find_package(self, request):
        self._oprot.writeMessageBegin("find_package", TMessageType.CALL, self._seqid)
        args = find_package_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_find_package(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = find_package_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "find_package failed: unknown result")

    def add_package(self, request):
        """
        Parameters:
         - request

        """
        self.send_add_package(request)
        self.recv_add_package()

    def send_add_package(self, request):
        self._oprot.writeMessageBegin("add_package", TMessageType.CALL, self._seqid)
        args = add_package_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_package(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_package_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def get_all_packages(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_all_packages(request)
        return self.recv_get_all_packages()

    def send_get_all_packages(self, request):
        self._oprot.writeMessageBegin("get_all_packages", TMessageType.CALL, self._seqid)
        args = get_all_packages_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_packages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_packages_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_packages failed: unknown result")

    def drop_package(self, request):
        """
        Parameters:
         - request

        """
        self.send_drop_package(request)
        self.recv_drop_package()

    def send_drop_package(self, request):
        self._oprot.writeMessageBegin("drop_package", TMessageType.CALL, self._seqid)
        args = drop_package_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_package(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_package_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def get_all_write_event_info(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_all_write_event_info(request)
        return self.recv_get_all_write_event_info()

    def send_get_all_write_event_info(self, request):
        self._oprot.writeMessageBegin("get_all_write_event_info", TMessageType.CALL, self._seqid)
        args = get_all_write_event_info_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_write_event_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_write_event_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_write_event_info failed: unknown result")


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
    def __init__(self, handler):
        fb303.FacebookService.Processor.__init__(self, handler)
        self._processMap["getMetaConf"] = Processor.process_getMetaConf
        self._processMap["setMetaConf"] = Processor.process_setMetaConf
        self._processMap["create_catalog"] = Processor.process_create_catalog
        self._processMap["alter_catalog"] = Processor.process_alter_catalog
        self._processMap["get_catalog"] = Processor.process_get_catalog
        self._processMap["get_catalogs"] = Processor.process_get_catalogs
        self._processMap["drop_catalog"] = Processor.process_drop_catalog
        self._processMap["create_database"] = Processor.process_create_database
        self._processMap["get_database"] = Processor.process_get_database
        self._processMap["get_database_req"] = Processor.process_get_database_req
        self._processMap["drop_database"] = Processor.process_drop_database
        self._processMap["drop_database_req"] = Processor.process_drop_database_req
        self._processMap["get_databases"] = Processor.process_get_databases
        self._processMap["get_all_databases"] = Processor.process_get_all_databases
        self._processMap["alter_database"] = Processor.process_alter_database
        self._processMap["create_dataconnector"] = Processor.process_create_dataconnector
        self._processMap["get_dataconnector_req"] = Processor.process_get_dataconnector_req
        self._processMap["drop_dataconnector"] = Processor.process_drop_dataconnector
        self._processMap["get_dataconnectors"] = Processor.process_get_dataconnectors
        self._processMap["alter_dataconnector"] = Processor.process_alter_dataconnector
        self._processMap["get_type"] = Processor.process_get_type
        self._processMap["create_type"] = Processor.process_create_type
        self._processMap["drop_type"] = Processor.process_drop_type
        self._processMap["get_type_all"] = Processor.process_get_type_all
        self._processMap["get_fields"] = Processor.process_get_fields
        self._processMap["get_fields_with_environment_context"] = Processor.process_get_fields_with_environment_context
        self._processMap["get_fields_req"] = Processor.process_get_fields_req
        self._processMap["get_schema"] = Processor.process_get_schema
        self._processMap["get_schema_with_environment_context"] = Processor.process_get_schema_with_environment_context
        self._processMap["get_schema_req"] = Processor.process_get_schema_req
        self._processMap["create_table"] = Processor.process_create_table
        self._processMap["create_table_with_environment_context"] = Processor.process_create_table_with_environment_context
        self._processMap["create_table_with_constraints"] = Processor.process_create_table_with_constraints
        self._processMap["create_table_req"] = Processor.process_create_table_req
        self._processMap["drop_constraint"] = Processor.process_drop_constraint
        self._processMap["add_primary_key"] = Processor.process_add_primary_key
        self._processMap["add_foreign_key"] = Processor.process_add_foreign_key
        self._processMap["add_unique_constraint"] = Processor.process_add_unique_constraint
        self._processMap["add_not_null_constraint"] = Processor.process_add_not_null_constraint
        self._processMap["add_default_constraint"] = Processor.process_add_default_constraint
        self._processMap["add_check_constraint"] = Processor.process_add_check_constraint
        self._processMap["translate_table_dryrun"] = Processor.process_translate_table_dryrun
        self._processMap["drop_table"] = Processor.process_drop_table
        self._processMap["drop_table_with_environment_context"] = Processor.process_drop_table_with_environment_context
        self._processMap["truncate_table"] = Processor.process_truncate_table
        self._processMap["truncate_table_req"] = Processor.process_truncate_table_req
        self._processMap["get_tables"] = Processor.process_get_tables
        self._processMap["get_tables_by_type"] = Processor.process_get_tables_by_type
        self._processMap[
            "get_all_materialized_view_objects_for_rewriting"
        ] = Processor.process_get_all_materialized_view_objects_for_rewriting
        self._processMap["get_materialized_views_for_rewriting"] = Processor.process_get_materialized_views_for_rewriting
        self._processMap["get_table_meta"] = Processor.process_get_table_meta
        self._processMap["get_all_tables"] = Processor.process_get_all_tables
        self._processMap["get_table"] = Processor.process_get_table
        self._processMap["get_table_objects_by_name"] = Processor.process_get_table_objects_by_name
        self._processMap["get_tables_ext"] = Processor.process_get_tables_ext
        self._processMap["get_table_req"] = Processor.process_get_table_req
        self._processMap["get_table_objects_by_name_req"] = Processor.process_get_table_objects_by_name_req
        self._processMap["get_materialization_invalidation_info"] = Processor.process_get_materialization_invalidation_info
        self._processMap["update_creation_metadata"] = Processor.process_update_creation_metadata
        self._processMap["get_table_names_by_filter"] = Processor.process_get_table_names_by_filter
        self._processMap["alter_table"] = Processor.process_alter_table
        self._processMap["alter_table_with_environment_context"] = Processor.process_alter_table_with_environment_context
        self._processMap["alter_table_with_cascade"] = Processor.process_alter_table_with_cascade
        self._processMap["alter_table_req"] = Processor.process_alter_table_req
        self._processMap["add_partition"] = Processor.process_add_partition
        self._processMap["add_partition_with_environment_context"] = Processor.process_add_partition_with_environment_context
        self._processMap["add_partitions"] = Processor.process_add_partitions
        self._processMap["add_partitions_pspec"] = Processor.process_add_partitions_pspec
        self._processMap["append_partition"] = Processor.process_append_partition
        self._processMap["add_partitions_req"] = Processor.process_add_partitions_req
        self._processMap[
            "append_partition_with_environment_context"
        ] = Processor.process_append_partition_with_environment_context
        self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
        self._processMap[
            "append_partition_by_name_with_environment_context"
        ] = Processor.process_append_partition_by_name_with_environment_context
        self._processMap["drop_partition"] = Processor.process_drop_partition
        self._processMap["drop_partition_with_environment_context"] = Processor.process_drop_partition_with_environment_context
        self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
        self._processMap[
            "drop_partition_by_name_with_environment_context"
        ] = Processor.process_drop_partition_by_name_with_environment_context
        self._processMap["drop_partitions_req"] = Processor.process_drop_partitions_req
        self._processMap["get_partition"] = Processor.process_get_partition
        self._processMap["get_partition_req"] = Processor.process_get_partition_req
        self._processMap["exchange_partition"] = Processor.process_exchange_partition
        self._processMap["exchange_partitions"] = Processor.process_exchange_partitions
        self._processMap["get_partition_with_auth"] = Processor.process_get_partition_with_auth
        self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
        self._processMap["get_partitions"] = Processor.process_get_partitions
        self._processMap["get_partitions_req"] = Processor.process_get_partitions_req
        self._processMap["get_partitions_with_auth"] = Processor.process_get_partitions_with_auth
        self._processMap["get_partitions_pspec"] = Processor.process_get_partitions_pspec
        self._processMap["get_partition_names"] = Processor.process_get_partition_names
        self._processMap["get_partition_values"] = Processor.process_get_partition_values
        self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
        self._processMap["get_partitions_ps_with_auth"] = Processor.process_get_partitions_ps_with_auth
        self._processMap["get_partitions_ps_with_auth_req"] = Processor.process_get_partitions_ps_with_auth_req
        self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
        self._processMap["get_partition_names_ps_req"] = Processor.process_get_partition_names_ps_req
        self._processMap["get_partition_names_req"] = Processor.process_get_partition_names_req
        self._processMap["get_partitions_by_filter"] = Processor.process_get_partitions_by_filter
        self._processMap["get_part_specs_by_filter"] = Processor.process_get_part_specs_by_filter
        self._processMap["get_partitions_by_expr"] = Processor.process_get_partitions_by_expr
        self._processMap["get_partitions_spec_by_expr"] = Processor.process_get_partitions_spec_by_expr
        self._processMap["get_num_partitions_by_filter"] = Processor.process_get_num_partitions_by_filter
        self._processMap["get_partitions_by_names"] = Processor.process_get_partitions_by_names
        self._processMap["get_partitions_by_names_req"] = Processor.process_get_partitions_by_names_req
        self._processMap["alter_partition"] = Processor.process_alter_partition
        self._processMap["alter_partitions"] = Processor.process_alter_partitions
        self._processMap[
            "alter_partitions_with_environment_context"
        ] = Processor.process_alter_partitions_with_environment_context
        self._processMap["alter_partitions_req"] = Processor.process_alter_partitions_req
        self._processMap["alter_partition_with_environment_context"] = Processor.process_alter_partition_with_environment_context
        self._processMap["rename_partition"] = Processor.process_rename_partition
        self._processMap["rename_partition_req"] = Processor.process_rename_partition_req
        self._processMap["partition_name_has_valid_characters"] = Processor.process_partition_name_has_valid_characters
        self._processMap["get_config_value"] = Processor.process_get_config_value
        self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
        self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
        self._processMap["markPartitionForEvent"] = Processor.process_markPartitionForEvent
        self._processMap["isPartitionMarkedForEvent"] = Processor.process_isPartitionMarkedForEvent
        self._processMap["get_primary_keys"] = Processor.process_get_primary_keys
        self._processMap["get_foreign_keys"] = Processor.process_get_foreign_keys
        self._processMap["get_unique_constraints"] = Processor.process_get_unique_constraints
        self._processMap["get_not_null_constraints"] = Processor.process_get_not_null_constraints
        self._processMap["get_default_constraints"] = Processor.process_get_default_constraints
        self._processMap["get_check_constraints"] = Processor.process_get_check_constraints
        self._processMap["get_all_table_constraints"] = Processor.process_get_all_table_constraints
        self._processMap["update_table_column_statistics"] = Processor.process_update_table_column_statistics
        self._processMap["update_partition_column_statistics"] = Processor.process_update_partition_column_statistics
        self._processMap["update_table_column_statistics_req"] = Processor.process_update_table_column_statistics_req
        self._processMap["update_partition_column_statistics_req"] = Processor.process_update_partition_column_statistics_req
        self._processMap["update_transaction_statistics"] = Processor.process_update_transaction_statistics
        self._processMap["get_table_column_statistics"] = Processor.process_get_table_column_statistics
        self._processMap["get_partition_column_statistics"] = Processor.process_get_partition_column_statistics
        self._processMap["get_table_statistics_req"] = Processor.process_get_table_statistics_req
        self._processMap["get_partitions_statistics_req"] = Processor.process_get_partitions_statistics_req
        self._processMap["get_aggr_stats_for"] = Processor.process_get_aggr_stats_for
        self._processMap["set_aggr_stats_for"] = Processor.process_set_aggr_stats_for
        self._processMap["delete_partition_column_statistics"] = Processor.process_delete_partition_column_statistics
        self._processMap["delete_table_column_statistics"] = Processor.process_delete_table_column_statistics
        self._processMap["create_function"] = Processor.process_create_function
        self._processMap["drop_function"] = Processor.process_drop_function
        self._processMap["alter_function"] = Processor.process_alter_function
        self._processMap["get_functions"] = Processor.process_get_functions
        self._processMap["get_function"] = Processor.process_get_function
        self._processMap["get_all_functions"] = Processor.process_get_all_functions
        self._processMap["create_role"] = Processor.process_create_role
        self._processMap["drop_role"] = Processor.process_drop_role
        self._processMap["get_role_names"] = Processor.process_get_role_names
        self._processMap["grant_role"] = Processor.process_grant_role
        self._processMap["revoke_role"] = Processor.process_revoke_role
        self._processMap["list_roles"] = Processor.process_list_roles
        self._processMap["grant_revoke_role"] = Processor.process_grant_revoke_role
        self._processMap["get_principals_in_role"] = Processor.process_get_principals_in_role
        self._processMap["get_role_grants_for_principal"] = Processor.process_get_role_grants_for_principal
        self._processMap["get_privilege_set"] = Processor.process_get_privilege_set
        self._processMap["list_privileges"] = Processor.process_list_privileges
        self._processMap["grant_privileges"] = Processor.process_grant_privileges
        self._processMap["revoke_privileges"] = Processor.process_revoke_privileges
        self._processMap["grant_revoke_privileges"] = Processor.process_grant_revoke_privileges
        self._processMap["refresh_privileges"] = Processor.process_refresh_privileges
        self._processMap["set_ugi"] = Processor.process_set_ugi
        self._processMap["get_delegation_token"] = Processor.process_get_delegation_token
        self._processMap["renew_delegation_token"] = Processor.process_renew_delegation_token
        self._processMap["cancel_delegation_token"] = Processor.process_cancel_delegation_token
        self._processMap["add_token"] = Processor.process_add_token
        self._processMap["remove_token"] = Processor.process_remove_token
        self._processMap["get_token"] = Processor.process_get_token
        self._processMap["get_all_token_identifiers"] = Processor.process_get_all_token_identifiers
        self._processMap["add_master_key"] = Processor.process_add_master_key
        self._processMap["update_master_key"] = Processor.process_update_master_key
        self._processMap["remove_master_key"] = Processor.process_remove_master_key
        self._processMap["get_master_keys"] = Processor.process_get_master_keys
        self._processMap["get_open_txns"] = Processor.process_get_open_txns
        self._processMap["get_open_txns_info"] = Processor.process_get_open_txns_info
        self._processMap["open_txns"] = Processor.process_open_txns
        self._processMap["abort_txn"] = Processor.process_abort_txn
        self._processMap["abort_txns"] = Processor.process_abort_txns
        self._processMap["commit_txn"] = Processor.process_commit_txn
        self._processMap["get_latest_txnid_in_conflict"] = Processor.process_get_latest_txnid_in_conflict
        self._processMap["repl_tbl_writeid_state"] = Processor.process_repl_tbl_writeid_state
        self._processMap["get_valid_write_ids"] = Processor.process_get_valid_write_ids
        self._processMap["allocate_table_write_ids"] = Processor.process_allocate_table_write_ids
        self._processMap["get_max_allocated_table_write_id"] = Processor.process_get_max_allocated_table_write_id
        self._processMap["seed_write_id"] = Processor.process_seed_write_id
        self._processMap["seed_txn_id"] = Processor.process_seed_txn_id
        self._processMap["lock"] = Processor.process_lock
        self._processMap["check_lock"] = Processor.process_check_lock
        self._processMap["unlock"] = Processor.process_unlock
        self._processMap["show_locks"] = Processor.process_show_locks
        self._processMap["heartbeat"] = Processor.process_heartbeat
        self._processMap["heartbeat_txn_range"] = Processor.process_heartbeat_txn_range
        self._processMap["compact"] = Processor.process_compact
        self._processMap["compact2"] = Processor.process_compact2
        self._processMap["show_compact"] = Processor.process_show_compact
        self._processMap["add_dynamic_partitions"] = Processor.process_add_dynamic_partitions
        self._processMap["find_next_compact"] = Processor.process_find_next_compact
        self._processMap["find_next_compact2"] = Processor.process_find_next_compact2
        self._processMap["update_compactor_state"] = Processor.process_update_compactor_state
        self._processMap["find_columns_with_stats"] = Processor.process_find_columns_with_stats
        self._processMap["mark_cleaned"] = Processor.process_mark_cleaned
        self._processMap["mark_compacted"] = Processor.process_mark_compacted
        self._processMap["mark_failed"] = Processor.process_mark_failed
        self._processMap["mark_refused"] = Processor.process_mark_refused
        self._processMap["update_compaction_metrics_data"] = Processor.process_update_compaction_metrics_data
        self._processMap["remove_compaction_metrics_data"] = Processor.process_remove_compaction_metrics_data
        self._processMap["set_hadoop_jobid"] = Processor.process_set_hadoop_jobid
        self._processMap["get_latest_committed_compaction_info"] = Processor.process_get_latest_committed_compaction_info
        self._processMap["get_next_notification"] = Processor.process_get_next_notification
        self._processMap["get_current_notificationEventId"] = Processor.process_get_current_notificationEventId
        self._processMap["get_notification_events_count"] = Processor.process_get_notification_events_count
        self._processMap["fire_listener_event"] = Processor.process_fire_listener_event
        self._processMap["flushCache"] = Processor.process_flushCache
        self._processMap["add_write_notification_log"] = Processor.process_add_write_notification_log
        self._processMap["add_write_notification_log_in_batch"] = Processor.process_add_write_notification_log_in_batch
        self._processMap["cm_recycle"] = Processor.process_cm_recycle
        self._processMap["get_file_metadata_by_expr"] = Processor.process_get_file_metadata_by_expr
        self._processMap["get_file_metadata"] = Processor.process_get_file_metadata
        self._processMap["put_file_metadata"] = Processor.process_put_file_metadata
        self._processMap["clear_file_metadata"] = Processor.process_clear_file_metadata
        self._processMap["cache_file_metadata"] = Processor.process_cache_file_metadata
        self._processMap["get_metastore_db_uuid"] = Processor.process_get_metastore_db_uuid
        self._processMap["create_resource_plan"] = Processor.process_create_resource_plan
        self._processMap["get_resource_plan"] = Processor.process_get_resource_plan
        self._processMap["get_active_resource_plan"] = Processor.process_get_active_resource_plan
        self._processMap["get_all_resource_plans"] = Processor.process_get_all_resource_plans
        self._processMap["alter_resource_plan"] = Processor.process_alter_resource_plan
        self._processMap["validate_resource_plan"] = Processor.process_validate_resource_plan
        self._processMap["drop_resource_plan"] = Processor.process_drop_resource_plan
        self._processMap["create_wm_trigger"] = Processor.process_create_wm_trigger
        self._processMap["alter_wm_trigger"] = Processor.process_alter_wm_trigger
        self._processMap["drop_wm_trigger"] = Processor.process_drop_wm_trigger
        self._processMap["get_triggers_for_resourceplan"] = Processor.process_get_triggers_for_resourceplan
        self._processMap["create_wm_pool"] = Processor.process_create_wm_pool
        self._processMap["alter_wm_pool"] = Processor.process_alter_wm_pool
        self._processMap["drop_wm_pool"] = Processor.process_drop_wm_pool
        self._processMap["create_or_update_wm_mapping"] = Processor.process_create_or_update_wm_mapping
        self._processMap["drop_wm_mapping"] = Processor.process_drop_wm_mapping
        self._processMap[
            "create_or_drop_wm_trigger_to_pool_mapping"
        ] = Processor.process_create_or_drop_wm_trigger_to_pool_mapping
        self._processMap["create_ischema"] = Processor.process_create_ischema
        self._processMap["alter_ischema"] = Processor.process_alter_ischema
        self._processMap["get_ischema"] = Processor.process_get_ischema
        self._processMap["drop_ischema"] = Processor.process_drop_ischema
        self._processMap["add_schema_version"] = Processor.process_add_schema_version
        self._processMap["get_schema_version"] = Processor.process_get_schema_version
        self._processMap["get_schema_latest_version"] = Processor.process_get_schema_latest_version
        self._processMap["get_schema_all_versions"] = Processor.process_get_schema_all_versions
        self._processMap["drop_schema_version"] = Processor.process_drop_schema_version
        self._processMap["get_schemas_by_cols"] = Processor.process_get_schemas_by_cols
        self._processMap["map_schema_version_to_serde"] = Processor.process_map_schema_version_to_serde
        self._processMap["set_schema_version_state"] = Processor.process_set_schema_version_state
        self._processMap["add_serde"] = Processor.process_add_serde
        self._processMap["get_serde"] = Processor.process_get_serde
        self._processMap["get_lock_materialization_rebuild"] = Processor.process_get_lock_materialization_rebuild
        self._processMap["heartbeat_lock_materialization_rebuild"] = Processor.process_heartbeat_lock_materialization_rebuild
        self._processMap["add_runtime_stats"] = Processor.process_add_runtime_stats
        self._processMap["get_runtime_stats"] = Processor.process_get_runtime_stats
        self._processMap["get_partitions_with_specs"] = Processor.process_get_partitions_with_specs
        self._processMap["scheduled_query_poll"] = Processor.process_scheduled_query_poll
        self._processMap["scheduled_query_maintenance"] = Processor.process_scheduled_query_maintenance
        self._processMap["scheduled_query_progress"] = Processor.process_scheduled_query_progress
        self._processMap["get_scheduled_query"] = Processor.process_get_scheduled_query
        self._processMap["add_replication_metrics"] = Processor.process_add_replication_metrics
        self._processMap["get_replication_metrics"] = Processor.process_get_replication_metrics
        self._processMap["get_open_txns_req"] = Processor.process_get_open_txns_req
        self._processMap["create_stored_procedure"] = Processor.process_create_stored_procedure
        self._processMap["get_stored_procedure"] = Processor.process_get_stored_procedure
        self._processMap["drop_stored_procedure"] = Processor.process_drop_stored_procedure
        self._processMap["get_all_stored_procedures"] = Processor.process_get_all_stored_procedures
        self._processMap["find_package"] = Processor.process_find_package
        self._processMap["add_package"] = Processor.process_add_package
        self._processMap["get_all_packages"] = Processor.process_get_all_packages
        self._processMap["drop_package"] = Processor.process_drop_package
        self._processMap["get_all_write_event_info"] = Processor.process_get_all_write_event_info
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getMetaConf(self, seqid, iprot, oprot):
        args = getMetaConf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetaConf_result()
        try:
            result.success = self._handler.getMetaConf(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getMetaConf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setMetaConf(self, seqid, iprot, oprot):
        args = setMetaConf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setMetaConf_result()
        try:
            self._handler.setMetaConf(args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("setMetaConf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_catalog(self, seqid, iprot, oprot):
        args = create_catalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_catalog_result()
        try:
            self._handler.create_catalog(args.catalog)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_catalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_catalog(self, seqid, iprot, oprot):
        args = alter_catalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_catalog_result()
        try:
            self._handler.alter_catalog(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_catalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_catalog(self, seqid, iprot, oprot):
        args = get_catalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_catalog_result()
        try:
            result.success = self._handler.get_catalog(args.catName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_catalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_catalogs(self, seqid, iprot, oprot):
        args = get_catalogs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_catalogs_result()
        try:
            result.success = self._handler.get_catalogs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_catalogs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_catalog(self, seqid, iprot, oprot):
        args = drop_catalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_catalog_result()
        try:
            self._handler.drop_catalog(args.catName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_catalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_database(self, seqid, iprot, oprot):
        args = create_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_database_result()
        try:
            self._handler.create_database(args.database)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_database(self, seqid, iprot, oprot):
        args = get_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_database_result()
        try:
            result.success = self._handler.get_database(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_database_req(self, seqid, iprot, oprot):
        args = get_database_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_database_req_result()
        try:
            result.success = self._handler.get_database_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_database_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_database(self, seqid, iprot, oprot):
        args = drop_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_database_result()
        try:
            self._handler.drop_database(args.name, args.deleteData, args.cascade)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_database_req(self, seqid, iprot, oprot):
        args = drop_database_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_database_req_result()
        try:
            self._handler.drop_database_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_database_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_databases(self, seqid, iprot, oprot):
        args = get_databases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_databases_result()
        try:
            result.success = self._handler.get_databases(args.pattern)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_databases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_databases(self, seqid, iprot, oprot):
        args = get_all_databases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_databases_result()
        try:
            result.success = self._handler.get_all_databases()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_databases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_database(self, seqid, iprot, oprot):
        args = alter_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_database_result()
        try:
            self._handler.alter_database(args.dbname, args.db)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_dataconnector(self, seqid, iprot, oprot):
        args = create_dataconnector_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_dataconnector_result()
        try:
            self._handler.create_dataconnector(args.connector)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_dataconnector", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dataconnector_req(self, seqid, iprot, oprot):
        args = get_dataconnector_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dataconnector_req_result()
        try:
            result.success = self._handler.get_dataconnector_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_dataconnector_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_dataconnector(self, seqid, iprot, oprot):
        args = drop_dataconnector_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_dataconnector_result()
        try:
            self._handler.drop_dataconnector(args.name, args.ifNotExists, args.checkReferences)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_dataconnector", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dataconnectors(self, seqid, iprot, oprot):
        args = get_dataconnectors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dataconnectors_result()
        try:
            result.success = self._handler.get_dataconnectors()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_dataconnectors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_dataconnector(self, seqid, iprot, oprot):
        args = alter_dataconnector_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_dataconnector_result()
        try:
            self._handler.alter_dataconnector(args.name, args.connector)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_dataconnector", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_type(self, seqid, iprot, oprot):
        args = get_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_type_result()
        try:
            result.success = self._handler.get_type(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_type(self, seqid, iprot, oprot):
        args = create_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_type_result()
        try:
            result.success = self._handler.create_type(args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_type(self, seqid, iprot, oprot):
        args = drop_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_type_result()
        try:
            result.success = self._handler.drop_type(args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_type_all(self, seqid, iprot, oprot):
        args = get_type_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_type_all_result()
        try:
            result.success = self._handler.get_type_all(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_type_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fields(self, seqid, iprot, oprot):
        args = get_fields_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fields_result()
        try:
            result.success = self._handler.get_fields(args.db_name, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_fields", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fields_with_environment_context(self, seqid, iprot, oprot):
        args = get_fields_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fields_with_environment_context_result()
        try:
            result.success = self._handler.get_fields_with_environment_context(
                args.db_name, args.table_name, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_fields_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fields_req(self, seqid, iprot, oprot):
        args = get_fields_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fields_req_result()
        try:
            result.success = self._handler.get_fields_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_fields_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema(self, seqid, iprot, oprot):
        args = get_schema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_result()
        try:
            result.success = self._handler.get_schema(args.db_name, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_schema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_with_environment_context(self, seqid, iprot, oprot):
        args = get_schema_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_with_environment_context_result()
        try:
            result.success = self._handler.get_schema_with_environment_context(
                args.db_name, args.table_name, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_schema_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_req(self, seqid, iprot, oprot):
        args = get_schema_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_req_result()
        try:
            result.success = self._handler.get_schema_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_schema_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table(self, seqid, iprot, oprot):
        args = create_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_result()
        try:
            self._handler.create_table(args.tbl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table_with_environment_context(self, seqid, iprot, oprot):
        args = create_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_with_environment_context_result()
        try:
            self._handler.create_table_with_environment_context(args.tbl, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table_with_constraints(self, seqid, iprot, oprot):
        args = create_table_with_constraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_with_constraints_result()
        try:
            self._handler.create_table_with_constraints(
                args.tbl,
                args.primaryKeys,
                args.foreignKeys,
                args.uniqueConstraints,
                args.notNullConstraints,
                args.defaultConstraints,
                args.checkConstraints,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_table_with_constraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table_req(self, seqid, iprot, oprot):
        args = create_table_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_req_result()
        try:
            self._handler.create_table_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_table_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_constraint(self, seqid, iprot, oprot):
        args = drop_constraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_constraint_result()
        try:
            self._handler.drop_constraint(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_constraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_primary_key(self, seqid, iprot, oprot):
        args = add_primary_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_primary_key_result()
        try:
            self._handler.add_primary_key(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_primary_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_foreign_key(self, seqid, iprot, oprot):
        args = add_foreign_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_foreign_key_result()
        try:
            self._handler.add_foreign_key(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_foreign_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_unique_constraint(self, seqid, iprot, oprot):
        args = add_unique_constraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_unique_constraint_result()
        try:
            self._handler.add_unique_constraint(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_unique_constraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_not_null_constraint(self, seqid, iprot, oprot):
        args = add_not_null_constraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_not_null_constraint_result()
        try:
            self._handler.add_not_null_constraint(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_not_null_constraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_default_constraint(self, seqid, iprot, oprot):
        args = add_default_constraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_default_constraint_result()
        try:
            self._handler.add_default_constraint(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_default_constraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_check_constraint(self, seqid, iprot, oprot):
        args = add_check_constraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_check_constraint_result()
        try:
            self._handler.add_check_constraint(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_check_constraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_translate_table_dryrun(self, seqid, iprot, oprot):
        args = translate_table_dryrun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = translate_table_dryrun_result()
        try:
            result.success = self._handler.translate_table_dryrun(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("translate_table_dryrun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_table(self, seqid, iprot, oprot):
        args = drop_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_table_result()
        try:
            self._handler.drop_table(args.dbname, args.name, args.deleteData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_table_with_environment_context(self, seqid, iprot, oprot):
        args = drop_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_table_with_environment_context_result()
        try:
            self._handler.drop_table_with_environment_context(args.dbname, args.name, args.deleteData, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_truncate_table(self, seqid, iprot, oprot):
        args = truncate_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = truncate_table_result()
        try:
            self._handler.truncate_table(args.dbName, args.tableName, args.partNames)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("truncate_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_truncate_table_req(self, seqid, iprot, oprot):
        args = truncate_table_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = truncate_table_req_result()
        try:
            result.success = self._handler.truncate_table_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("truncate_table_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables(self, seqid, iprot, oprot):
        args = get_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_result()
        try:
            result.success = self._handler.get_tables(args.db_name, args.pattern)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables_by_type(self, seqid, iprot, oprot):
        args = get_tables_by_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_by_type_result()
        try:
            result.success = self._handler.get_tables_by_type(args.db_name, args.pattern, args.tableType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_tables_by_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_materialized_view_objects_for_rewriting(self, seqid, iprot, oprot):
        args = get_all_materialized_view_objects_for_rewriting_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_materialized_view_objects_for_rewriting_result()
        try:
            result.success = self._handler.get_all_materialized_view_objects_for_rewriting()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_materialized_view_objects_for_rewriting", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_materialized_views_for_rewriting(self, seqid, iprot, oprot):
        args = get_materialized_views_for_rewriting_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_materialized_views_for_rewriting_result()
        try:
            result.success = self._handler.get_materialized_views_for_rewriting(args.db_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_materialized_views_for_rewriting", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_meta(self, seqid, iprot, oprot):
        args = get_table_meta_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_meta_result()
        try:
            result.success = self._handler.get_table_meta(args.db_patterns, args.tbl_patterns, args.tbl_types)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table_meta", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_tables(self, seqid, iprot, oprot):
        args = get_all_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_tables_result()
        try:
            result.success = self._handler.get_all_tables(args.db_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table(self, seqid, iprot, oprot):
        args = get_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_result()
        try:
            result.success = self._handler.get_table(args.dbname, args.tbl_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_objects_by_name(self, seqid, iprot, oprot):
        args = get_table_objects_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_objects_by_name_result()
        try:
            result.success = self._handler.get_table_objects_by_name(args.dbname, args.tbl_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table_objects_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables_ext(self, seqid, iprot, oprot):
        args = get_tables_ext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_ext_result()
        try:
            result.success = self._handler.get_tables_ext(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_tables_ext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_req(self, seqid, iprot, oprot):
        args = get_table_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_req_result()
        try:
            result.success = self._handler.get_table_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_objects_by_name_req(self, seqid, iprot, oprot):
        args = get_table_objects_by_name_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_objects_by_name_req_result()
        try:
            result.success = self._handler.get_table_objects_by_name_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table_objects_by_name_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_materialization_invalidation_info(self, seqid, iprot, oprot):
        args = get_materialization_invalidation_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_materialization_invalidation_info_result()
        try:
            result.success = self._handler.get_materialization_invalidation_info(args.creation_metadata, args.validTxnList)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_materialization_invalidation_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_creation_metadata(self, seqid, iprot, oprot):
        args = update_creation_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_creation_metadata_result()
        try:
            self._handler.update_creation_metadata(args.catName, args.dbname, args.tbl_name, args.creation_metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_creation_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_names_by_filter(self, seqid, iprot, oprot):
        args = get_table_names_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_names_by_filter_result()
        try:
            result.success = self._handler.get_table_names_by_filter(args.dbname, args.filter, args.max_tables)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table_names_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table(self, seqid, iprot, oprot):
        args = alter_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_result()
        try:
            self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table_with_environment_context(self, seqid, iprot, oprot):
        args = alter_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_with_environment_context_result()
        try:
            self._handler.alter_table_with_environment_context(args.dbname, args.tbl_name, args.new_tbl, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table_with_cascade(self, seqid, iprot, oprot):
        args = alter_table_with_cascade_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_with_cascade_result()
        try:
            self._handler.alter_table_with_cascade(args.dbname, args.tbl_name, args.new_tbl, args.cascade)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_table_with_cascade", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table_req(self, seqid, iprot, oprot):
        args = alter_table_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_req_result()
        try:
            result.success = self._handler.alter_table_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_table_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partition(self, seqid, iprot, oprot):
        args = add_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partition_result()
        try:
            result.success = self._handler.add_partition(args.new_part)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partition_with_environment_context(self, seqid, iprot, oprot):
        args = add_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partition_with_environment_context_result()
        try:
            result.success = self._handler.add_partition_with_environment_context(args.new_part, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions(self, seqid, iprot, oprot):
        args = add_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_result()
        try:
            result.success = self._handler.add_partitions(args.new_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions_pspec(self, seqid, iprot, oprot):
        args = add_partitions_pspec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_pspec_result()
        try:
            result.success = self._handler.add_partitions_pspec(args.new_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_partitions_pspec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition(self, seqid, iprot, oprot):
        args = append_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_result()
        try:
            result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("append_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions_req(self, seqid, iprot, oprot):
        args = add_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_req_result()
        try:
            result.success = self._handler.add_partitions_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_with_environment_context(self, seqid, iprot, oprot):
        args = append_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_with_environment_context_result()
        try:
            result.success = self._handler.append_partition_with_environment_context(
                args.db_name, args.tbl_name, args.part_vals, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("append_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_by_name(self, seqid, iprot, oprot):
        args = append_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_by_name_result()
        try:
            result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("append_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
        args = append_partition_by_name_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_by_name_with_environment_context_result()
        try:
            result.success = self._handler.append_partition_by_name_with_environment_context(
                args.db_name, args.tbl_name, args.part_name, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("append_partition_by_name_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition(self, seqid, iprot, oprot):
        args = drop_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_result()
        try:
            result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_with_environment_context(self, seqid, iprot, oprot):
        args = drop_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_with_environment_context_result()
        try:
            result.success = self._handler.drop_partition_with_environment_context(
                args.db_name, args.tbl_name, args.part_vals, args.deleteData, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_by_name(self, seqid, iprot, oprot):
        args = drop_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_by_name_result()
        try:
            result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
        args = drop_partition_by_name_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_by_name_with_environment_context_result()
        try:
            result.success = self._handler.drop_partition_by_name_with_environment_context(
                args.db_name, args.tbl_name, args.part_name, args.deleteData, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_partition_by_name_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partitions_req(self, seqid, iprot, oprot):
        args = drop_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partitions_req_result()
        try:
            result.success = self._handler.drop_partitions_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition(self, seqid, iprot, oprot):
        args = get_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_result()
        try:
            result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_req(self, seqid, iprot, oprot):
        args = get_partition_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_req_result()
        try:
            result.success = self._handler.get_partition_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exchange_partition(self, seqid, iprot, oprot):
        args = exchange_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exchange_partition_result()
        try:
            result.success = self._handler.exchange_partition(
                args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("exchange_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exchange_partitions(self, seqid, iprot, oprot):
        args = exchange_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exchange_partitions_result()
        try:
            result.success = self._handler.exchange_partitions(
                args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("exchange_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_with_auth(self, seqid, iprot, oprot):
        args = get_partition_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_with_auth_result()
        try:
            result.success = self._handler.get_partition_with_auth(
                args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_by_name(self, seqid, iprot, oprot):
        args = get_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_by_name_result()
        try:
            result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions(self, seqid, iprot, oprot):
        args = get_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_result()
        try:
            result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_req(self, seqid, iprot, oprot):
        args = get_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_req_result()
        try:
            result.success = self._handler.get_partitions_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_with_auth(self, seqid, iprot, oprot):
        args = get_partitions_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_with_auth_result()
        try:
            result.success = self._handler.get_partitions_with_auth(
                args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_pspec(self, seqid, iprot, oprot):
        args = get_partitions_pspec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_pspec_result()
        try:
            result.success = self._handler.get_partitions_pspec(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_pspec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names(self, seqid, iprot, oprot):
        args = get_partition_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_result()
        try:
            result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_values(self, seqid, iprot, oprot):
        args = get_partition_values_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_values_result()
        try:
            result.success = self._handler.get_partition_values(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_values", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_ps(self, seqid, iprot, oprot):
        args = get_partitions_ps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_ps_result()
        try:
            result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_ps", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_ps_with_auth(self, seqid, iprot, oprot):
        args = get_partitions_ps_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_ps_with_auth_result()
        try:
            result.success = self._handler.get_partitions_ps_with_auth(
                args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_ps_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_ps_with_auth_req(self, seqid, iprot, oprot):
        args = get_partitions_ps_with_auth_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_ps_with_auth_req_result()
        try:
            result.success = self._handler.get_partitions_ps_with_auth_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_ps_with_auth_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names_ps(self, seqid, iprot, oprot):
        args = get_partition_names_ps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_ps_result()
        try:
            result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_names_ps", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names_ps_req(self, seqid, iprot, oprot):
        args = get_partition_names_ps_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_ps_req_result()
        try:
            result.success = self._handler.get_partition_names_ps_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_names_ps_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names_req(self, seqid, iprot, oprot):
        args = get_partition_names_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_req_result()
        try:
            result.success = self._handler.get_partition_names_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_names_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_filter(self, seqid, iprot, oprot):
        args = get_partitions_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_filter_result()
        try:
            result.success = self._handler.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_part_specs_by_filter(self, seqid, iprot, oprot):
        args = get_part_specs_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_part_specs_by_filter_result()
        try:
            result.success = self._handler.get_part_specs_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_part_specs_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_expr(self, seqid, iprot, oprot):
        args = get_partitions_by_expr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_expr_result()
        try:
            result.success = self._handler.get_partitions_by_expr(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_by_expr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_spec_by_expr(self, seqid, iprot, oprot):
        args = get_partitions_spec_by_expr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_spec_by_expr_result()
        try:
            result.success = self._handler.get_partitions_spec_by_expr(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_spec_by_expr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_num_partitions_by_filter(self, seqid, iprot, oprot):
        args = get_num_partitions_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_num_partitions_by_filter_result()
        try:
            result.success = self._handler.get_num_partitions_by_filter(args.db_name, args.tbl_name, args.filter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_num_partitions_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_names(self, seqid, iprot, oprot):
        args = get_partitions_by_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_names_result()
        try:
            result.success = self._handler.get_partitions_by_names(args.db_name, args.tbl_name, args.names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_by_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_names_req(self, seqid, iprot, oprot):
        args = get_partitions_by_names_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_names_req_result()
        try:
            result.success = self._handler.get_partitions_by_names_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_by_names_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partition(self, seqid, iprot, oprot):
        args = alter_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partition_result()
        try:
            self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partitions(self, seqid, iprot, oprot):
        args = alter_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partitions_result()
        try:
            self._handler.alter_partitions(args.db_name, args.tbl_name, args.new_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partitions_with_environment_context(self, seqid, iprot, oprot):
        args = alter_partitions_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partitions_with_environment_context_result()
        try:
            self._handler.alter_partitions_with_environment_context(
                args.db_name, args.tbl_name, args.new_parts, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_partitions_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partitions_req(self, seqid, iprot, oprot):
        args = alter_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partitions_req_result()
        try:
            result.success = self._handler.alter_partitions_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partition_with_environment_context(self, seqid, iprot, oprot):
        args = alter_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partition_with_environment_context_result()
        try:
            self._handler.alter_partition_with_environment_context(
                args.db_name, args.tbl_name, args.new_part, args.environment_context
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rename_partition(self, seqid, iprot, oprot):
        args = rename_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rename_partition_result()
        try:
            self._handler.rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("rename_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rename_partition_req(self, seqid, iprot, oprot):
        args = rename_partition_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rename_partition_req_result()
        try:
            result.success = self._handler.rename_partition_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("rename_partition_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_has_valid_characters(self, seqid, iprot, oprot):
        args = partition_name_has_valid_characters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_has_valid_characters_result()
        try:
            result.success = self._handler.partition_name_has_valid_characters(args.part_vals, args.throw_exception)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("partition_name_has_valid_characters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_config_value(self, seqid, iprot, oprot):
        args = get_config_value_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_config_value_result()
        try:
            result.success = self._handler.get_config_value(args.name, args.defaultValue)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ConfigValSecurityException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_config_value", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_to_vals(self, seqid, iprot, oprot):
        args = partition_name_to_vals_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_to_vals_result()
        try:
            result.success = self._handler.partition_name_to_vals(args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("partition_name_to_vals", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_to_spec(self, seqid, iprot, oprot):
        args = partition_name_to_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_to_spec_result()
        try:
            result.success = self._handler.partition_name_to_spec(args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("partition_name_to_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_markPartitionForEvent(self, seqid, iprot, oprot):
        args = markPartitionForEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markPartitionForEvent_result()
        try:
            self._handler.markPartitionForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except UnknownTableException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except UnknownPartitionException as o5:
            msg_type = TMessageType.REPLY
            result.o5 = o5
        except InvalidPartitionException as o6:
            msg_type = TMessageType.REPLY
            result.o6 = o6
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("markPartitionForEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isPartitionMarkedForEvent(self, seqid, iprot, oprot):
        args = isPartitionMarkedForEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isPartitionMarkedForEvent_result()
        try:
            result.success = self._handler.isPartitionMarkedForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except UnknownTableException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except UnknownPartitionException as o5:
            msg_type = TMessageType.REPLY
            result.o5 = o5
        except InvalidPartitionException as o6:
            msg_type = TMessageType.REPLY
            result.o6 = o6
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("isPartitionMarkedForEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_primary_keys(self, seqid, iprot, oprot):
        args = get_primary_keys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_primary_keys_result()
        try:
            result.success = self._handler.get_primary_keys(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_primary_keys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_foreign_keys(self, seqid, iprot, oprot):
        args = get_foreign_keys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_foreign_keys_result()
        try:
            result.success = self._handler.get_foreign_keys(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_foreign_keys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_unique_constraints(self, seqid, iprot, oprot):
        args = get_unique_constraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_unique_constraints_result()
        try:
            result.success = self._handler.get_unique_constraints(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_unique_constraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_not_null_constraints(self, seqid, iprot, oprot):
        args = get_not_null_constraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_not_null_constraints_result()
        try:
            result.success = self._handler.get_not_null_constraints(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_not_null_constraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_default_constraints(self, seqid, iprot, oprot):
        args = get_default_constraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_default_constraints_result()
        try:
            result.success = self._handler.get_default_constraints(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_default_constraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_check_constraints(self, seqid, iprot, oprot):
        args = get_check_constraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_check_constraints_result()
        try:
            result.success = self._handler.get_check_constraints(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_check_constraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_table_constraints(self, seqid, iprot, oprot):
        args = get_all_table_constraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_table_constraints_result()
        try:
            result.success = self._handler.get_all_table_constraints(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_table_constraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_table_column_statistics(self, seqid, iprot, oprot):
        args = update_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_table_column_statistics_result()
        try:
            result.success = self._handler.update_table_column_statistics(args.stats_obj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_partition_column_statistics(self, seqid, iprot, oprot):
        args = update_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_partition_column_statistics_result()
        try:
            result.success = self._handler.update_partition_column_statistics(args.stats_obj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_table_column_statistics_req(self, seqid, iprot, oprot):
        args = update_table_column_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_table_column_statistics_req_result()
        try:
            result.success = self._handler.update_table_column_statistics_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_table_column_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_partition_column_statistics_req(self, seqid, iprot, oprot):
        args = update_partition_column_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_partition_column_statistics_req_result()
        try:
            result.success = self._handler.update_partition_column_statistics_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_partition_column_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_transaction_statistics(self, seqid, iprot, oprot):
        args = update_transaction_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_transaction_statistics_result()
        try:
            self._handler.update_transaction_statistics(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_transaction_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_column_statistics(self, seqid, iprot, oprot):
        args = get_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_column_statistics_result()
        try:
            result.success = self._handler.get_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidInputException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_column_statistics(self, seqid, iprot, oprot):
        args = get_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_column_statistics_result()
        try:
            result.success = self._handler.get_partition_column_statistics(
                args.db_name, args.tbl_name, args.part_name, args.col_name
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidInputException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_statistics_req(self, seqid, iprot, oprot):
        args = get_table_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_statistics_req_result()
        try:
            result.success = self._handler.get_table_statistics_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_table_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_statistics_req(self, seqid, iprot, oprot):
        args = get_partitions_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_statistics_req_result()
        try:
            result.success = self._handler.get_partitions_statistics_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_aggr_stats_for(self, seqid, iprot, oprot):
        args = get_aggr_stats_for_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_aggr_stats_for_result()
        try:
            result.success = self._handler.get_aggr_stats_for(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_aggr_stats_for", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_aggr_stats_for(self, seqid, iprot, oprot):
        args = set_aggr_stats_for_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_aggr_stats_for_result()
        try:
            result.success = self._handler.set_aggr_stats_for(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("set_aggr_stats_for", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_partition_column_statistics(self, seqid, iprot, oprot):
        args = delete_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_partition_column_statistics_result()
        try:
            result.success = self._handler.delete_partition_column_statistics(
                args.db_name, args.tbl_name, args.part_name, args.col_name, args.engine
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("delete_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_table_column_statistics(self, seqid, iprot, oprot):
        args = delete_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_table_column_statistics_result()
        try:
            result.success = self._handler.delete_table_column_statistics(args.db_name, args.tbl_name, args.col_name, args.engine)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("delete_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_function(self, seqid, iprot, oprot):
        args = create_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_function_result()
        try:
            self._handler.create_function(args.func)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_function(self, seqid, iprot, oprot):
        args = drop_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_function_result()
        try:
            self._handler.drop_function(args.dbName, args.funcName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_function(self, seqid, iprot, oprot):
        args = alter_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_function_result()
        try:
            self._handler.alter_function(args.dbName, args.funcName, args.newFunc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_functions(self, seqid, iprot, oprot):
        args = get_functions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_functions_result()
        try:
            result.success = self._handler.get_functions(args.dbName, args.pattern)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_functions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function(self, seqid, iprot, oprot):
        args = get_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_result()
        try:
            result.success = self._handler.get_function(args.dbName, args.funcName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_functions(self, seqid, iprot, oprot):
        args = get_all_functions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_functions_result()
        try:
            result.success = self._handler.get_all_functions()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_functions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_role(self, seqid, iprot, oprot):
        args = create_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_role_result()
        try:
            result.success = self._handler.create_role(args.role)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_role(self, seqid, iprot, oprot):
        args = drop_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_role_result()
        try:
            result.success = self._handler.drop_role(args.role_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_role_names(self, seqid, iprot, oprot):
        args = get_role_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_role_names_result()
        try:
            result.success = self._handler.get_role_names()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_role_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_role(self, seqid, iprot, oprot):
        args = grant_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_role_result()
        try:
            result.success = self._handler.grant_role(
                args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantorType, args.grant_option
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("grant_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revoke_role(self, seqid, iprot, oprot):
        args = revoke_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revoke_role_result()
        try:
            result.success = self._handler.revoke_role(args.role_name, args.principal_name, args.principal_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("revoke_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_list_roles(self, seqid, iprot, oprot):
        args = list_roles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = list_roles_result()
        try:
            result.success = self._handler.list_roles(args.principal_name, args.principal_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("list_roles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_revoke_role(self, seqid, iprot, oprot):
        args = grant_revoke_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_revoke_role_result()
        try:
            result.success = self._handler.grant_revoke_role(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("grant_revoke_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_principals_in_role(self, seqid, iprot, oprot):
        args = get_principals_in_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_principals_in_role_result()
        try:
            result.success = self._handler.get_principals_in_role(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_principals_in_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_role_grants_for_principal(self, seqid, iprot, oprot):
        args = get_role_grants_for_principal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_role_grants_for_principal_result()
        try:
            result.success = self._handler.get_role_grants_for_principal(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_role_grants_for_principal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_privilege_set(self, seqid, iprot, oprot):
        args = get_privilege_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_privilege_set_result()
        try:
            result.success = self._handler.get_privilege_set(args.hiveObject, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_privilege_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_list_privileges(self, seqid, iprot, oprot):
        args = list_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = list_privileges_result()
        try:
            result.success = self._handler.list_privileges(args.principal_name, args.principal_type, args.hiveObject)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("list_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_privileges(self, seqid, iprot, oprot):
        args = grant_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_privileges_result()
        try:
            result.success = self._handler.grant_privileges(args.privileges)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("grant_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revoke_privileges(self, seqid, iprot, oprot):
        args = revoke_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revoke_privileges_result()
        try:
            result.success = self._handler.revoke_privileges(args.privileges)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("revoke_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_revoke_privileges(self, seqid, iprot, oprot):
        args = grant_revoke_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_revoke_privileges_result()
        try:
            result.success = self._handler.grant_revoke_privileges(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("grant_revoke_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_refresh_privileges(self, seqid, iprot, oprot):
        args = refresh_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = refresh_privileges_result()
        try:
            result.success = self._handler.refresh_privileges(args.objToRefresh, args.authorizer, args.grantRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("refresh_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_ugi(self, seqid, iprot, oprot):
        args = set_ugi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_ugi_result()
        try:
            result.success = self._handler.set_ugi(args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("set_ugi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_delegation_token(self, seqid, iprot, oprot):
        args = get_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_delegation_token_result()
        try:
            result.success = self._handler.get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_renew_delegation_token(self, seqid, iprot, oprot):
        args = renew_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = renew_delegation_token_result()
        try:
            result.success = self._handler.renew_delegation_token(args.token_str_form)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("renew_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_delegation_token(self, seqid, iprot, oprot):
        args = cancel_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_delegation_token_result()
        try:
            self._handler.cancel_delegation_token(args.token_str_form)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("cancel_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_token(self, seqid, iprot, oprot):
        args = add_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_token_result()
        try:
            result.success = self._handler.add_token(args.token_identifier, args.delegation_token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_token(self, seqid, iprot, oprot):
        args = remove_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_token_result()
        try:
            result.success = self._handler.remove_token(args.token_identifier)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("remove_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_token(self, seqid, iprot, oprot):
        args = get_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_token_result()
        try:
            result.success = self._handler.get_token(args.token_identifier)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_token_identifiers(self, seqid, iprot, oprot):
        args = get_all_token_identifiers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_token_identifiers_result()
        try:
            result.success = self._handler.get_all_token_identifiers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_token_identifiers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_master_key(self, seqid, iprot, oprot):
        args = add_master_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_master_key_result()
        try:
            result.success = self._handler.add_master_key(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_master_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_master_key(self, seqid, iprot, oprot):
        args = update_master_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_master_key_result()
        try:
            self._handler.update_master_key(args.seq_number, args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_master_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_master_key(self, seqid, iprot, oprot):
        args = remove_master_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_master_key_result()
        try:
            result.success = self._handler.remove_master_key(args.key_seq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("remove_master_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_master_keys(self, seqid, iprot, oprot):
        args = get_master_keys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_master_keys_result()
        try:
            result.success = self._handler.get_master_keys()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_master_keys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_open_txns(self, seqid, iprot, oprot):
        args = get_open_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_open_txns_result()
        try:
            result.success = self._handler.get_open_txns()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_open_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_open_txns_info(self, seqid, iprot, oprot):
        args = get_open_txns_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_open_txns_info_result()
        try:
            result.success = self._handler.get_open_txns_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_open_txns_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_txns(self, seqid, iprot, oprot):
        args = open_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_txns_result()
        try:
            result.success = self._handler.open_txns(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("open_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abort_txn(self, seqid, iprot, oprot):
        args = abort_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_txn_result()
        try:
            self._handler.abort_txn(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("abort_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abort_txns(self, seqid, iprot, oprot):
        args = abort_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_txns_result()
        try:
            self._handler.abort_txns(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("abort_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_txn(self, seqid, iprot, oprot):
        args = commit_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_txn_result()
        try:
            self._handler.commit_txn(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("commit_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_latest_txnid_in_conflict(self, seqid, iprot, oprot):
        args = get_latest_txnid_in_conflict_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_latest_txnid_in_conflict_result()
        try:
            result.success = self._handler.get_latest_txnid_in_conflict(args.txnId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_latest_txnid_in_conflict", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_repl_tbl_writeid_state(self, seqid, iprot, oprot):
        args = repl_tbl_writeid_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = repl_tbl_writeid_state_result()
        try:
            self._handler.repl_tbl_writeid_state(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("repl_tbl_writeid_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_valid_write_ids(self, seqid, iprot, oprot):
        args = get_valid_write_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_valid_write_ids_result()
        try:
            result.success = self._handler.get_valid_write_ids(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_valid_write_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_allocate_table_write_ids(self, seqid, iprot, oprot):
        args = allocate_table_write_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = allocate_table_write_ids_result()
        try:
            result.success = self._handler.allocate_table_write_ids(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("allocate_table_write_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_max_allocated_table_write_id(self, seqid, iprot, oprot):
        args = get_max_allocated_table_write_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_max_allocated_table_write_id_result()
        try:
            result.success = self._handler.get_max_allocated_table_write_id(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_max_allocated_table_write_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_seed_write_id(self, seqid, iprot, oprot):
        args = seed_write_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = seed_write_id_result()
        try:
            self._handler.seed_write_id(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("seed_write_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_seed_txn_id(self, seqid, iprot, oprot):
        args = seed_txn_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = seed_txn_id_result()
        try:
            self._handler.seed_txn_id(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("seed_txn_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_lock(self, seqid, iprot, oprot):
        args = lock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lock_result()
        try:
            result.success = self._handler.lock(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("lock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_lock(self, seqid, iprot, oprot):
        args = check_lock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_lock_result()
        try:
            result.success = self._handler.check_lock(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except NoSuchLockException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("check_lock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unlock(self, seqid, iprot, oprot):
        args = unlock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unlock_result()
        try:
            self._handler.unlock(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchLockException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnOpenException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("unlock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_show_locks(self, seqid, iprot, oprot):
        args = show_locks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = show_locks_result()
        try:
            result.success = self._handler.show_locks(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("show_locks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_heartbeat(self, seqid, iprot, oprot):
        args = heartbeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = heartbeat_result()
        try:
            self._handler.heartbeat(args.ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchLockException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchTxnException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TxnAbortedException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("heartbeat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_heartbeat_txn_range(self, seqid, iprot, oprot):
        args = heartbeat_txn_range_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = heartbeat_txn_range_result()
        try:
            result.success = self._handler.heartbeat_txn_range(args.txns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("heartbeat_txn_range", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compact(self, seqid, iprot, oprot):
        args = compact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compact_result()
        try:
            self._handler.compact(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("compact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compact2(self, seqid, iprot, oprot):
        args = compact2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compact2_result()
        try:
            result.success = self._handler.compact2(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("compact2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_show_compact(self, seqid, iprot, oprot):
        args = show_compact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = show_compact_result()
        try:
            result.success = self._handler.show_compact(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("show_compact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_dynamic_partitions(self, seqid, iprot, oprot):
        args = add_dynamic_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_dynamic_partitions_result()
        try:
            self._handler.add_dynamic_partitions(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_dynamic_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_find_next_compact(self, seqid, iprot, oprot):
        args = find_next_compact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = find_next_compact_result()
        try:
            result.success = self._handler.find_next_compact(args.workerId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("find_next_compact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_find_next_compact2(self, seqid, iprot, oprot):
        args = find_next_compact2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = find_next_compact2_result()
        try:
            result.success = self._handler.find_next_compact2(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("find_next_compact2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_compactor_state(self, seqid, iprot, oprot):
        args = update_compactor_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_compactor_state_result()
        try:
            self._handler.update_compactor_state(args.cr, args.txn_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_compactor_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_find_columns_with_stats(self, seqid, iprot, oprot):
        args = find_columns_with_stats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = find_columns_with_stats_result()
        try:
            result.success = self._handler.find_columns_with_stats(args.cr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("find_columns_with_stats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mark_cleaned(self, seqid, iprot, oprot):
        args = mark_cleaned_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mark_cleaned_result()
        try:
            self._handler.mark_cleaned(args.cr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("mark_cleaned", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mark_compacted(self, seqid, iprot, oprot):
        args = mark_compacted_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mark_compacted_result()
        try:
            self._handler.mark_compacted(args.cr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("mark_compacted", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mark_failed(self, seqid, iprot, oprot):
        args = mark_failed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mark_failed_result()
        try:
            self._handler.mark_failed(args.cr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("mark_failed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mark_refused(self, seqid, iprot, oprot):
        args = mark_refused_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mark_refused_result()
        try:
            self._handler.mark_refused(args.cr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("mark_refused", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_compaction_metrics_data(self, seqid, iprot, oprot):
        args = update_compaction_metrics_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_compaction_metrics_data_result()
        try:
            result.success = self._handler.update_compaction_metrics_data(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("update_compaction_metrics_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_compaction_metrics_data(self, seqid, iprot, oprot):
        args = remove_compaction_metrics_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_compaction_metrics_data_result()
        try:
            self._handler.remove_compaction_metrics_data(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("remove_compaction_metrics_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_hadoop_jobid(self, seqid, iprot, oprot):
        args = set_hadoop_jobid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_hadoop_jobid_result()
        try:
            self._handler.set_hadoop_jobid(args.jobId, args.cq_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("set_hadoop_jobid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_latest_committed_compaction_info(self, seqid, iprot, oprot):
        args = get_latest_committed_compaction_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_latest_committed_compaction_info_result()
        try:
            result.success = self._handler.get_latest_committed_compaction_info(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_latest_committed_compaction_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_next_notification(self, seqid, iprot, oprot):
        args = get_next_notification_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_next_notification_result()
        try:
            result.success = self._handler.get_next_notification(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_next_notification", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_current_notificationEventId(self, seqid, iprot, oprot):
        args = get_current_notificationEventId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_current_notificationEventId_result()
        try:
            result.success = self._handler.get_current_notificationEventId()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_current_notificationEventId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_notification_events_count(self, seqid, iprot, oprot):
        args = get_notification_events_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_notification_events_count_result()
        try:
            result.success = self._handler.get_notification_events_count(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_notification_events_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fire_listener_event(self, seqid, iprot, oprot):
        args = fire_listener_event_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fire_listener_event_result()
        try:
            result.success = self._handler.fire_listener_event(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("fire_listener_event", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_flushCache(self, seqid, iprot, oprot):
        args = flushCache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = flushCache_result()
        try:
            self._handler.flushCache()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("flushCache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_write_notification_log(self, seqid, iprot, oprot):
        args = add_write_notification_log_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_write_notification_log_result()
        try:
            result.success = self._handler.add_write_notification_log(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_write_notification_log", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_write_notification_log_in_batch(self, seqid, iprot, oprot):
        args = add_write_notification_log_in_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_write_notification_log_in_batch_result()
        try:
            result.success = self._handler.add_write_notification_log_in_batch(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_write_notification_log_in_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cm_recycle(self, seqid, iprot, oprot):
        args = cm_recycle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cm_recycle_result()
        try:
            result.success = self._handler.cm_recycle(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("cm_recycle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_file_metadata_by_expr(self, seqid, iprot, oprot):
        args = get_file_metadata_by_expr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_file_metadata_by_expr_result()
        try:
            result.success = self._handler.get_file_metadata_by_expr(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_file_metadata_by_expr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_file_metadata(self, seqid, iprot, oprot):
        args = get_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_file_metadata_result()
        try:
            result.success = self._handler.get_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_put_file_metadata(self, seqid, iprot, oprot):
        args = put_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = put_file_metadata_result()
        try:
            result.success = self._handler.put_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("put_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clear_file_metadata(self, seqid, iprot, oprot):
        args = clear_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clear_file_metadata_result()
        try:
            result.success = self._handler.clear_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("clear_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cache_file_metadata(self, seqid, iprot, oprot):
        args = cache_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cache_file_metadata_result()
        try:
            result.success = self._handler.cache_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("cache_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_metastore_db_uuid(self, seqid, iprot, oprot):
        args = get_metastore_db_uuid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_metastore_db_uuid_result()
        try:
            result.success = self._handler.get_metastore_db_uuid()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_metastore_db_uuid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_resource_plan(self, seqid, iprot, oprot):
        args = create_resource_plan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_resource_plan_result()
        try:
            result.success = self._handler.create_resource_plan(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_resource_plan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_resource_plan(self, seqid, iprot, oprot):
        args = get_resource_plan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_resource_plan_result()
        try:
            result.success = self._handler.get_resource_plan(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_resource_plan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_active_resource_plan(self, seqid, iprot, oprot):
        args = get_active_resource_plan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_active_resource_plan_result()
        try:
            result.success = self._handler.get_active_resource_plan(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_active_resource_plan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_resource_plans(self, seqid, iprot, oprot):
        args = get_all_resource_plans_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_resource_plans_result()
        try:
            result.success = self._handler.get_all_resource_plans(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_resource_plans", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_resource_plan(self, seqid, iprot, oprot):
        args = alter_resource_plan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_resource_plan_result()
        try:
            result.success = self._handler.alter_resource_plan(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_resource_plan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_validate_resource_plan(self, seqid, iprot, oprot):
        args = validate_resource_plan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = validate_resource_plan_result()
        try:
            result.success = self._handler.validate_resource_plan(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("validate_resource_plan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_resource_plan(self, seqid, iprot, oprot):
        args = drop_resource_plan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_resource_plan_result()
        try:
            result.success = self._handler.drop_resource_plan(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_resource_plan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_wm_trigger(self, seqid, iprot, oprot):
        args = create_wm_trigger_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_wm_trigger_result()
        try:
            result.success = self._handler.create_wm_trigger(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except MetaException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_wm_trigger", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_wm_trigger(self, seqid, iprot, oprot):
        args = alter_wm_trigger_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_wm_trigger_result()
        try:
            result.success = self._handler.alter_wm_trigger(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_wm_trigger", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_wm_trigger(self, seqid, iprot, oprot):
        args = drop_wm_trigger_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_wm_trigger_result()
        try:
            result.success = self._handler.drop_wm_trigger(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_wm_trigger", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_triggers_for_resourceplan(self, seqid, iprot, oprot):
        args = get_triggers_for_resourceplan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_triggers_for_resourceplan_result()
        try:
            result.success = self._handler.get_triggers_for_resourceplan(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_triggers_for_resourceplan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_wm_pool(self, seqid, iprot, oprot):
        args = create_wm_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_wm_pool_result()
        try:
            result.success = self._handler.create_wm_pool(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except MetaException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_wm_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_wm_pool(self, seqid, iprot, oprot):
        args = alter_wm_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_wm_pool_result()
        try:
            result.success = self._handler.alter_wm_pool(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except MetaException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_wm_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_wm_pool(self, seqid, iprot, oprot):
        args = drop_wm_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_wm_pool_result()
        try:
            result.success = self._handler.drop_wm_pool(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_wm_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_or_update_wm_mapping(self, seqid, iprot, oprot):
        args = create_or_update_wm_mapping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_or_update_wm_mapping_result()
        try:
            result.success = self._handler.create_or_update_wm_mapping(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except MetaException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_or_update_wm_mapping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_wm_mapping(self, seqid, iprot, oprot):
        args = drop_wm_mapping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_wm_mapping_result()
        try:
            result.success = self._handler.drop_wm_mapping(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_wm_mapping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_or_drop_wm_trigger_to_pool_mapping(self, seqid, iprot, oprot):
        args = create_or_drop_wm_trigger_to_pool_mapping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_or_drop_wm_trigger_to_pool_mapping_result()
        try:
            result.success = self._handler.create_or_drop_wm_trigger_to_pool_mapping(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except MetaException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_or_drop_wm_trigger_to_pool_mapping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_ischema(self, seqid, iprot, oprot):
        args = create_ischema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_ischema_result()
        try:
            self._handler.create_ischema(args.schema)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_ischema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_ischema(self, seqid, iprot, oprot):
        args = alter_ischema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_ischema_result()
        try:
            self._handler.alter_ischema(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alter_ischema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_ischema(self, seqid, iprot, oprot):
        args = get_ischema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_ischema_result()
        try:
            result.success = self._handler.get_ischema(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_ischema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_ischema(self, seqid, iprot, oprot):
        args = drop_ischema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_ischema_result()
        try:
            self._handler.drop_ischema(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_ischema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_schema_version(self, seqid, iprot, oprot):
        args = add_schema_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_schema_version_result()
        try:
            self._handler.add_schema_version(args.schemaVersion)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_schema_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_version(self, seqid, iprot, oprot):
        args = get_schema_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_version_result()
        try:
            result.success = self._handler.get_schema_version(args.schemaVersion)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_schema_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_latest_version(self, seqid, iprot, oprot):
        args = get_schema_latest_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_latest_version_result()
        try:
            result.success = self._handler.get_schema_latest_version(args.schemaName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_schema_latest_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_all_versions(self, seqid, iprot, oprot):
        args = get_schema_all_versions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_all_versions_result()
        try:
            result.success = self._handler.get_schema_all_versions(args.schemaName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_schema_all_versions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_schema_version(self, seqid, iprot, oprot):
        args = drop_schema_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_schema_version_result()
        try:
            self._handler.drop_schema_version(args.schemaVersion)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_schema_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schemas_by_cols(self, seqid, iprot, oprot):
        args = get_schemas_by_cols_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schemas_by_cols_result()
        try:
            result.success = self._handler.get_schemas_by_cols(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_schemas_by_cols", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_map_schema_version_to_serde(self, seqid, iprot, oprot):
        args = map_schema_version_to_serde_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = map_schema_version_to_serde_result()
        try:
            self._handler.map_schema_version_to_serde(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("map_schema_version_to_serde", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_schema_version_state(self, seqid, iprot, oprot):
        args = set_schema_version_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_schema_version_state_result()
        try:
            self._handler.set_schema_version_state(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("set_schema_version_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_serde(self, seqid, iprot, oprot):
        args = add_serde_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_serde_result()
        try:
            self._handler.add_serde(args.serde)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_serde", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_serde(self, seqid, iprot, oprot):
        args = get_serde_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_serde_result()
        try:
            result.success = self._handler.get_serde(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_serde", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_lock_materialization_rebuild(self, seqid, iprot, oprot):
        args = get_lock_materialization_rebuild_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_lock_materialization_rebuild_result()
        try:
            result.success = self._handler.get_lock_materialization_rebuild(args.dbName, args.tableName, args.txnId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_lock_materialization_rebuild", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_heartbeat_lock_materialization_rebuild(self, seqid, iprot, oprot):
        args = heartbeat_lock_materialization_rebuild_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = heartbeat_lock_materialization_rebuild_result()
        try:
            result.success = self._handler.heartbeat_lock_materialization_rebuild(args.dbName, args.tableName, args.txnId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("heartbeat_lock_materialization_rebuild", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_runtime_stats(self, seqid, iprot, oprot):
        args = add_runtime_stats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_runtime_stats_result()
        try:
            self._handler.add_runtime_stats(args.stat)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_runtime_stats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_runtime_stats(self, seqid, iprot, oprot):
        args = get_runtime_stats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_runtime_stats_result()
        try:
            result.success = self._handler.get_runtime_stats(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_runtime_stats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_with_specs(self, seqid, iprot, oprot):
        args = get_partitions_with_specs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_with_specs_result()
        try:
            result.success = self._handler.get_partitions_with_specs(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_partitions_with_specs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scheduled_query_poll(self, seqid, iprot, oprot):
        args = scheduled_query_poll_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scheduled_query_poll_result()
        try:
            result.success = self._handler.scheduled_query_poll(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("scheduled_query_poll", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scheduled_query_maintenance(self, seqid, iprot, oprot):
        args = scheduled_query_maintenance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scheduled_query_maintenance_result()
        try:
            self._handler.scheduled_query_maintenance(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except AlreadyExistsException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("scheduled_query_maintenance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scheduled_query_progress(self, seqid, iprot, oprot):
        args = scheduled_query_progress_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scheduled_query_progress_result()
        try:
            self._handler.scheduled_query_progress(args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("scheduled_query_progress", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_scheduled_query(self, seqid, iprot, oprot):
        args = get_scheduled_query_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_scheduled_query_result()
        try:
            result.success = self._handler.get_scheduled_query(args.scheduleKey)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_scheduled_query", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_replication_metrics(self, seqid, iprot, oprot):
        args = add_replication_metrics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_replication_metrics_result()
        try:
            self._handler.add_replication_metrics(args.replicationMetricList)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_replication_metrics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_replication_metrics(self, seqid, iprot, oprot):
        args = get_replication_metrics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_replication_metrics_result()
        try:
            result.success = self._handler.get_replication_metrics(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_replication_metrics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_open_txns_req(self, seqid, iprot, oprot):
        args = get_open_txns_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_open_txns_req_result()
        try:
            result.success = self._handler.get_open_txns_req(args.getOpenTxnsRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_open_txns_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_stored_procedure(self, seqid, iprot, oprot):
        args = create_stored_procedure_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_stored_procedure_result()
        try:
            self._handler.create_stored_procedure(args.proc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("create_stored_procedure", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_stored_procedure(self, seqid, iprot, oprot):
        args = get_stored_procedure_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_stored_procedure_result()
        try:
            result.success = self._handler.get_stored_procedure(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_stored_procedure", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_stored_procedure(self, seqid, iprot, oprot):
        args = drop_stored_procedure_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_stored_procedure_result()
        try:
            self._handler.drop_stored_procedure(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_stored_procedure", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_stored_procedures(self, seqid, iprot, oprot):
        args = get_all_stored_procedures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_stored_procedures_result()
        try:
            result.success = self._handler.get_all_stored_procedures(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_stored_procedures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_find_package(self, seqid, iprot, oprot):
        args = find_package_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = find_package_result()
        try:
            result.success = self._handler.find_package(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("find_package", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_package(self, seqid, iprot, oprot):
        args = add_package_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_package_result()
        try:
            self._handler.add_package(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("add_package", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_packages(self, seqid, iprot, oprot):
        args = get_all_packages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_packages_result()
        try:
            result.success = self._handler.get_all_packages(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_packages", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_package(self, seqid, iprot, oprot):
        args = drop_package_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_package_result()
        try:
            self._handler.drop_package(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("drop_package", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_write_event_info(self, seqid, iprot, oprot):
        args = get_all_write_event_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_write_event_info_result()
        try:
            result.success = self._handler.get_all_write_event_info(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("get_all_write_event_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES


class getMetaConf_args:
    """
    Attributes:
     - key

    """

    def __init__(
        self,
        key=None,
    ):
        self.key = key

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetaConf_args")
        if self.key is not None:
            oprot.writeFieldBegin("key", TType.STRING, 1)
            oprot.writeString(self.key.encode("utf-8") if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetaConf_args)
getMetaConf_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "key",
        "UTF8",
        None,
    ),  # 1
)


class getMetaConf_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetaConf_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(self.success.encode("utf-8") if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetaConf_result)
getMetaConf_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class setMetaConf_args:
    """
    Attributes:
     - key
     - value

    """

    def __init__(
        self,
        key=None,
        value=None,
    ):
        self.key = key
        self.value = value

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("setMetaConf_args")
        if self.key is not None:
            oprot.writeFieldBegin("key", TType.STRING, 1)
            oprot.writeString(self.key.encode("utf-8") if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin("value", TType.STRING, 2)
            oprot.writeString(self.value.encode("utf-8") if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(setMetaConf_args)
setMetaConf_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "key",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "value",
        "UTF8",
        None,
    ),  # 2
)


class setMetaConf_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("setMetaConf_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(setMetaConf_result)
setMetaConf_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class create_catalog_args:
    """
    Attributes:
     - catalog

    """

    def __init__(
        self,
        catalog=None,
    ):
        self.catalog = catalog

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog = CreateCatalogRequest()
                    self.catalog.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_catalog_args")
        if self.catalog is not None:
            oprot.writeFieldBegin("catalog", TType.STRUCT, 1)
            self.catalog.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_catalog_args)
create_catalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "catalog",
        [CreateCatalogRequest, None],
        None,
    ),  # 1
)


class create_catalog_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_catalog_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_catalog_result)
create_catalog_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class alter_catalog_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AlterCatalogRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_catalog_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_catalog_args)
alter_catalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [AlterCatalogRequest, None],
        None,
    ),  # 1
)


class alter_catalog_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_catalog_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_catalog_result)
alter_catalog_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_catalog_args:
    """
    Attributes:
     - catName

    """

    def __init__(
        self,
        catName=None,
    ):
        self.catName = catName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catName = GetCatalogRequest()
                    self.catName.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_catalog_args")
        if self.catName is not None:
            oprot.writeFieldBegin("catName", TType.STRUCT, 1)
            self.catName.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_catalog_args)
get_catalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "catName",
        [GetCatalogRequest, None],
        None,
    ),  # 1
)


class get_catalog_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCatalogResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_catalog_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_catalog_result)
get_catalog_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetCatalogResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_catalogs_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_catalogs_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_catalogs_args)
get_catalogs_args.thrift_spec = ()


class get_catalogs_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCatalogsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_catalogs_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_catalogs_result)
get_catalogs_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetCatalogsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class drop_catalog_args:
    """
    Attributes:
     - catName

    """

    def __init__(
        self,
        catName=None,
    ):
        self.catName = catName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catName = DropCatalogRequest()
                    self.catName.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_catalog_args")
        if self.catName is not None:
            oprot.writeFieldBegin("catName", TType.STRUCT, 1)
            self.catName.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_catalog_args)
drop_catalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "catName",
        [DropCatalogRequest, None],
        None,
    ),  # 1
)


class drop_catalog_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_catalog_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_catalog_result)
drop_catalog_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class create_database_args:
    """
    Attributes:
     - database

    """

    def __init__(
        self,
        database=None,
    ):
        self.database = database

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.database = Database()
                    self.database.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_database_args")
        if self.database is not None:
            oprot.writeFieldBegin("database", TType.STRUCT, 1)
            self.database.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_database_args)
create_database_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "database",
        [Database, None],
        None,
    ),  # 1
)


class create_database_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_database_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_database_result)
create_database_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_database_args:
    """
    Attributes:
     - name

    """

    def __init__(
        self,
        name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_database_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_database_args)
get_database_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
)


class get_database_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Database()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_database_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_database_result)
get_database_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Database, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_database_req_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetDatabaseRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_database_req_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_database_req_args)
get_database_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GetDatabaseRequest, None],
        None,
    ),  # 1
)


class get_database_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Database()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_database_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_database_req_result)
get_database_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Database, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_database_args:
    """
    Attributes:
     - name
     - deleteData
     - cascade

    """

    def __init__(
        self,
        name=None,
        deleteData=None,
        cascade=None,
    ):
        self.name = name
        self.deleteData = deleteData
        self.cascade = cascade

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_database_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin("deleteData", TType.BOOL, 2)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin("cascade", TType.BOOL, 3)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_database_args)
drop_database_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.BOOL,
        "deleteData",
        None,
        None,
    ),  # 2
    (
        3,
        TType.BOOL,
        "cascade",
        None,
        None,
    ),  # 3
)


class drop_database_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_database_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_database_result)
drop_database_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class drop_database_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = DropDatabaseRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_database_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_database_req_args)
drop_database_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [DropDatabaseRequest, None],
        None,
    ),  # 1
)


class drop_database_req_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_database_req_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_database_req_result)
drop_database_req_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_databases_args:
    """
    Attributes:
     - pattern

    """

    def __init__(
        self,
        pattern=None,
    ):
        self.pattern = pattern

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pattern = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_databases_args")
        if self.pattern is not None:
            oprot.writeFieldBegin("pattern", TType.STRING, 1)
            oprot.writeString(self.pattern.encode("utf-8") if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_databases_args)
get_databases_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "pattern",
        "UTF8",
        None,
    ),  # 1
)


class get_databases_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1252, _size1249) = iprot.readListBegin()
                    for _i1253 in range(_size1249):
                        _elem1254 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_databases_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1255 in self.success:
                oprot.writeString(iter1255.encode("utf-8") if sys.version_info[0] == 2 else iter1255)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_databases_result)
get_databases_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_all_databases_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_databases_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_databases_args)
get_all_databases_args.thrift_spec = ()


class get_all_databases_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1259, _size1256) = iprot.readListBegin()
                    for _i1260 in range(_size1256):
                        _elem1261 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1261)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_databases_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1262 in self.success:
                oprot.writeString(iter1262.encode("utf-8") if sys.version_info[0] == 2 else iter1262)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_databases_result)
get_all_databases_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class alter_database_args:
    """
    Attributes:
     - dbname
     - db

    """

    def __init__(
        self,
        dbname=None,
        db=None,
    ):
        self.dbname = dbname
        self.db = db

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.db = Database()
                    self.db.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_database_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin("db", TType.STRUCT, 2)
            self.db.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_database_args)
alter_database_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "db",
        [Database, None],
        None,
    ),  # 2
)


class alter_database_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_database_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_database_result)
alter_database_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class create_dataconnector_args:
    """
    Attributes:
     - connector

    """

    def __init__(
        self,
        connector=None,
    ):
        self.connector = connector

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connector = DataConnector()
                    self.connector.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_dataconnector_args")
        if self.connector is not None:
            oprot.writeFieldBegin("connector", TType.STRUCT, 1)
            self.connector.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_dataconnector_args)
create_dataconnector_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connector",
        [DataConnector, None],
        None,
    ),  # 1
)


class create_dataconnector_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_dataconnector_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_dataconnector_result)
create_dataconnector_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_dataconnector_req_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetDataConnectorRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_dataconnector_req_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_dataconnector_req_args)
get_dataconnector_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GetDataConnectorRequest, None],
        None,
    ),  # 1
)


class get_dataconnector_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DataConnector()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_dataconnector_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_dataconnector_req_result)
get_dataconnector_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [DataConnector, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_dataconnector_args:
    """
    Attributes:
     - name
     - ifNotExists
     - checkReferences

    """

    def __init__(
        self,
        name=None,
        ifNotExists=None,
        checkReferences=None,
    ):
        self.name = name
        self.ifNotExists = ifNotExists
        self.checkReferences = checkReferences

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == -1:
                if ftype == TType.BOOL:
                    self.ifNotExists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == -2:
                if ftype == TType.BOOL:
                    self.checkReferences = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_dataconnector_args")
        if self.checkReferences is not None:
            oprot.writeFieldBegin("checkReferences", TType.BOOL, -2)
            oprot.writeBool(self.checkReferences)
            oprot.writeFieldEnd()
        if self.ifNotExists is not None:
            oprot.writeFieldBegin("ifNotExists", TType.BOOL, -1)
            oprot.writeBool(self.ifNotExists)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_dataconnector_args)
drop_dataconnector_args.thrift_spec = ()


class drop_dataconnector_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_dataconnector_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_dataconnector_result)
drop_dataconnector_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_dataconnectors_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_dataconnectors_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_dataconnectors_args)
get_dataconnectors_args.thrift_spec = ()


class get_dataconnectors_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1266, _size1263) = iprot.readListBegin()
                    for _i1267 in range(_size1263):
                        _elem1268 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_dataconnectors_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1269 in self.success:
                oprot.writeString(iter1269.encode("utf-8") if sys.version_info[0] == 2 else iter1269)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_dataconnectors_result)
get_dataconnectors_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class alter_dataconnector_args:
    """
    Attributes:
     - name
     - connector

    """

    def __init__(
        self,
        name=None,
        connector=None,
    ):
        self.name = name
        self.connector = connector

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.connector = DataConnector()
                    self.connector.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_dataconnector_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.connector is not None:
            oprot.writeFieldBegin("connector", TType.STRUCT, 2)
            self.connector.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_dataconnector_args)
alter_dataconnector_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "connector",
        [DataConnector, None],
        None,
    ),  # 2
)


class alter_dataconnector_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_dataconnector_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_dataconnector_result)
alter_dataconnector_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_type_args:
    """
    Attributes:
     - name

    """

    def __init__(
        self,
        name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_type_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_type_args)
get_type_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
)


class get_type_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Type()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_type_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_type_result)
get_type_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Type, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class create_type_args:
    """
    Attributes:
     - type

    """

    def __init__(
        self,
        type=None,
    ):
        self.type = type

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.type = Type()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_type_args")
        if self.type is not None:
            oprot.writeFieldBegin("type", TType.STRUCT, 1)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_type_args)
create_type_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "type",
        [Type, None],
        None,
    ),  # 1
)


class create_type_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_type_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_type_result)
create_type_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class drop_type_args:
    """
    Attributes:
     - type

    """

    def __init__(
        self,
        type=None,
    ):
        self.type = type

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.type = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_type_args")
        if self.type is not None:
            oprot.writeFieldBegin("type", TType.STRING, 1)
            oprot.writeString(self.type.encode("utf-8") if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_type_args)
drop_type_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "type",
        "UTF8",
        None,
    ),  # 1
)


class drop_type_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_type_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_type_result)
drop_type_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_type_all_args:
    """
    Attributes:
     - name

    """

    def __init__(
        self,
        name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_type_all_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_type_all_args)
get_type_all_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
)


class get_type_all_result:
    """
    Attributes:
     - success
     - o2

    """

    def __init__(
        self,
        success=None,
        o2=None,
    ):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1271, _vtype1272, _size1270) = iprot.readMapBegin()
                    for _i1274 in range(_size1270):
                        _key1275 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val1276 = Type()
                        _val1276.read(iprot)
                        self.success[_key1275] = _val1276
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_type_all_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter1277, viter1278 in self.success.items():
                oprot.writeString(kiter1277.encode("utf-8") if sys.version_info[0] == 2 else kiter1277)
                viter1278.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_type_all_result)
get_type_all_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRUCT, [Type, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 1
)


class get_fields_args:
    """
    Attributes:
     - db_name
     - table_name

    """

    def __init__(
        self,
        db_name=None,
        table_name=None,
    ):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_fields_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin("table_name", TType.STRING, 2)
            oprot.writeString(self.table_name.encode("utf-8") if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_fields_args)
get_fields_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "table_name",
        "UTF8",
        None,
    ),  # 2
)


class get_fields_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1282, _size1279) = iprot.readListBegin()
                    for _i1283 in range(_size1279):
                        _elem1284 = FieldSchema()
                        _elem1284.read(iprot)
                        self.success.append(_elem1284)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_fields_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1285 in self.success:
                iter1285.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_fields_result)
get_fields_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [FieldSchema, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [UnknownTableException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class get_fields_with_environment_context_args:
    """
    Attributes:
     - db_name
     - table_name
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        table_name=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.table_name = table_name
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_fields_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin("table_name", TType.STRING, 2)
            oprot.writeString(self.table_name.encode("utf-8") if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 3)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_fields_with_environment_context_args)
get_fields_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "table_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 3
)


class get_fields_with_environment_context_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1289, _size1286) = iprot.readListBegin()
                    for _i1290 in range(_size1286):
                        _elem1291 = FieldSchema()
                        _elem1291.read(iprot)
                        self.success.append(_elem1291)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_fields_with_environment_context_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1292 in self.success:
                iter1292.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_fields_with_environment_context_result)
get_fields_with_environment_context_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [FieldSchema, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [UnknownTableException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class get_fields_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetFieldsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_fields_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_fields_req_args)
get_fields_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetFieldsRequest, None],
        None,
    ),  # 1
)


class get_fields_req_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetFieldsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_fields_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_fields_req_result)
get_fields_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetFieldsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [UnknownTableException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class get_schema_args:
    """
    Attributes:
     - db_name
     - table_name

    """

    def __init__(
        self,
        db_name=None,
        table_name=None,
    ):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin("table_name", TType.STRING, 2)
            oprot.writeString(self.table_name.encode("utf-8") if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_args)
get_schema_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "table_name",
        "UTF8",
        None,
    ),  # 2
)


class get_schema_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1296, _size1293) = iprot.readListBegin()
                    for _i1297 in range(_size1293):
                        _elem1298 = FieldSchema()
                        _elem1298.read(iprot)
                        self.success.append(_elem1298)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1299 in self.success:
                iter1299.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_result)
get_schema_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [FieldSchema, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [UnknownTableException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class get_schema_with_environment_context_args:
    """
    Attributes:
     - db_name
     - table_name
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        table_name=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.table_name = table_name
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin("table_name", TType.STRING, 2)
            oprot.writeString(self.table_name.encode("utf-8") if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 3)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_with_environment_context_args)
get_schema_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "table_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 3
)


class get_schema_with_environment_context_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1303, _size1300) = iprot.readListBegin()
                    for _i1304 in range(_size1300):
                        _elem1305 = FieldSchema()
                        _elem1305.read(iprot)
                        self.success.append(_elem1305)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_with_environment_context_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1306 in self.success:
                iter1306.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_with_environment_context_result)
get_schema_with_environment_context_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [FieldSchema, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [UnknownTableException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class get_schema_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetSchemaRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_req_args)
get_schema_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetSchemaRequest, None],
        None,
    ),  # 1
)


class get_schema_req_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetSchemaResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_req_result)
get_schema_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetSchemaResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [UnknownTableException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class create_table_args:
    """
    Attributes:
     - tbl

    """

    def __init__(
        self,
        tbl=None,
    ):
        self.tbl = tbl

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_args")
        if self.tbl is not None:
            oprot.writeFieldBegin("tbl", TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_args)
create_table_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "tbl",
        [Table, None],
        None,
    ),  # 1
)


class create_table_result:
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_result)
create_table_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [NoSuchObjectException, None],
        None,
    ),  # 4
)


class create_table_with_environment_context_args:
    """
    Attributes:
     - tbl
     - environment_context

    """

    def __init__(
        self,
        tbl=None,
        environment_context=None,
    ):
        self.tbl = tbl
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_with_environment_context_args")
        if self.tbl is not None:
            oprot.writeFieldBegin("tbl", TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 2)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_with_environment_context_args)
create_table_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "tbl",
        [Table, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 2
)


class create_table_with_environment_context_result:
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_with_environment_context_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_with_environment_context_result)
create_table_with_environment_context_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [NoSuchObjectException, None],
        None,
    ),  # 4
)


class create_table_with_constraints_args:
    """
    Attributes:
     - tbl
     - primaryKeys
     - foreignKeys
     - uniqueConstraints
     - notNullConstraints
     - defaultConstraints
     - checkConstraints

    """

    def __init__(
        self,
        tbl=None,
        primaryKeys=None,
        foreignKeys=None,
        uniqueConstraints=None,
        notNullConstraints=None,
        defaultConstraints=None,
        checkConstraints=None,
    ):
        self.tbl = tbl
        self.primaryKeys = primaryKeys
        self.foreignKeys = foreignKeys
        self.uniqueConstraints = uniqueConstraints
        self.notNullConstraints = notNullConstraints
        self.defaultConstraints = defaultConstraints
        self.checkConstraints = checkConstraints

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.primaryKeys = []
                    (_etype1310, _size1307) = iprot.readListBegin()
                    for _i1311 in range(_size1307):
                        _elem1312 = SQLPrimaryKey()
                        _elem1312.read(iprot)
                        self.primaryKeys.append(_elem1312)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.foreignKeys = []
                    (_etype1316, _size1313) = iprot.readListBegin()
                    for _i1317 in range(_size1313):
                        _elem1318 = SQLForeignKey()
                        _elem1318.read(iprot)
                        self.foreignKeys.append(_elem1318)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.uniqueConstraints = []
                    (_etype1322, _size1319) = iprot.readListBegin()
                    for _i1323 in range(_size1319):
                        _elem1324 = SQLUniqueConstraint()
                        _elem1324.read(iprot)
                        self.uniqueConstraints.append(_elem1324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.notNullConstraints = []
                    (_etype1328, _size1325) = iprot.readListBegin()
                    for _i1329 in range(_size1325):
                        _elem1330 = SQLNotNullConstraint()
                        _elem1330.read(iprot)
                        self.notNullConstraints.append(_elem1330)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.defaultConstraints = []
                    (_etype1334, _size1331) = iprot.readListBegin()
                    for _i1335 in range(_size1331):
                        _elem1336 = SQLDefaultConstraint()
                        _elem1336.read(iprot)
                        self.defaultConstraints.append(_elem1336)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.checkConstraints = []
                    (_etype1340, _size1337) = iprot.readListBegin()
                    for _i1341 in range(_size1337):
                        _elem1342 = SQLCheckConstraint()
                        _elem1342.read(iprot)
                        self.checkConstraints.append(_elem1342)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_with_constraints_args")
        if self.tbl is not None:
            oprot.writeFieldBegin("tbl", TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.primaryKeys is not None:
            oprot.writeFieldBegin("primaryKeys", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.primaryKeys))
            for iter1343 in self.primaryKeys:
                iter1343.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.foreignKeys is not None:
            oprot.writeFieldBegin("foreignKeys", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.foreignKeys))
            for iter1344 in self.foreignKeys:
                iter1344.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.uniqueConstraints is not None:
            oprot.writeFieldBegin("uniqueConstraints", TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.uniqueConstraints))
            for iter1345 in self.uniqueConstraints:
                iter1345.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.notNullConstraints is not None:
            oprot.writeFieldBegin("notNullConstraints", TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.notNullConstraints))
            for iter1346 in self.notNullConstraints:
                iter1346.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.defaultConstraints is not None:
            oprot.writeFieldBegin("defaultConstraints", TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.defaultConstraints))
            for iter1347 in self.defaultConstraints:
                iter1347.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.checkConstraints is not None:
            oprot.writeFieldBegin("checkConstraints", TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.checkConstraints))
            for iter1348 in self.checkConstraints:
                iter1348.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_with_constraints_args)
create_table_with_constraints_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "tbl",
        [Table, None],
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "primaryKeys",
        (TType.STRUCT, [SQLPrimaryKey, None], False),
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "foreignKeys",
        (TType.STRUCT, [SQLForeignKey, None], False),
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "uniqueConstraints",
        (TType.STRUCT, [SQLUniqueConstraint, None], False),
        None,
    ),  # 4
    (
        5,
        TType.LIST,
        "notNullConstraints",
        (TType.STRUCT, [SQLNotNullConstraint, None], False),
        None,
    ),  # 5
    (
        6,
        TType.LIST,
        "defaultConstraints",
        (TType.STRUCT, [SQLDefaultConstraint, None], False),
        None,
    ),  # 6
    (
        7,
        TType.LIST,
        "checkConstraints",
        (TType.STRUCT, [SQLCheckConstraint, None], False),
        None,
    ),  # 7
)


class create_table_with_constraints_result:
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_with_constraints_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_with_constraints_result)
create_table_with_constraints_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [NoSuchObjectException, None],
        None,
    ),  # 4
)


class create_table_req_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = CreateTableRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_req_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_req_args)
create_table_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [CreateTableRequest, None],
        None,
    ),  # 1
)


class create_table_req_result:
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_table_req_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_table_req_result)
create_table_req_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [NoSuchObjectException, None],
        None,
    ),  # 4
)


class drop_constraint_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = DropConstraintRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_constraint_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_constraint_args)
drop_constraint_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [DropConstraintRequest, None],
        None,
    ),  # 1
)


class drop_constraint_result:
    """
    Attributes:
     - o1
     - o3

    """

    def __init__(
        self,
        o1=None,
        o3=None,
    ):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_constraint_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_constraint_result)
drop_constraint_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 2
)


class add_primary_key_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddPrimaryKeyRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_primary_key_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_primary_key_args)
add_primary_key_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AddPrimaryKeyRequest, None],
        None,
    ),  # 1
)


class add_primary_key_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_primary_key_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_primary_key_result)
add_primary_key_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class add_foreign_key_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddForeignKeyRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_foreign_key_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_foreign_key_args)
add_foreign_key_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AddForeignKeyRequest, None],
        None,
    ),  # 1
)


class add_foreign_key_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_foreign_key_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_foreign_key_result)
add_foreign_key_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class add_unique_constraint_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddUniqueConstraintRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_unique_constraint_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_unique_constraint_args)
add_unique_constraint_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AddUniqueConstraintRequest, None],
        None,
    ),  # 1
)


class add_unique_constraint_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_unique_constraint_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_unique_constraint_result)
add_unique_constraint_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class add_not_null_constraint_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddNotNullConstraintRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_not_null_constraint_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_not_null_constraint_args)
add_not_null_constraint_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AddNotNullConstraintRequest, None],
        None,
    ),  # 1
)


class add_not_null_constraint_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_not_null_constraint_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_not_null_constraint_result)
add_not_null_constraint_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class add_default_constraint_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddDefaultConstraintRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_default_constraint_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_default_constraint_args)
add_default_constraint_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AddDefaultConstraintRequest, None],
        None,
    ),  # 1
)


class add_default_constraint_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_default_constraint_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_default_constraint_result)
add_default_constraint_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class add_check_constraint_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddCheckConstraintRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_check_constraint_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_check_constraint_args)
add_check_constraint_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AddCheckConstraintRequest, None],
        None,
    ),  # 1
)


class add_check_constraint_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_check_constraint_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_check_constraint_result)
add_check_constraint_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class translate_table_dryrun_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = CreateTableRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("translate_table_dryrun_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(translate_table_dryrun_args)
translate_table_dryrun_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [CreateTableRequest, None],
        None,
    ),  # 1
)


class translate_table_dryrun_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Table()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("translate_table_dryrun_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(translate_table_dryrun_result)
translate_table_dryrun_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Table, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [NoSuchObjectException, None],
        None,
    ),  # 4
)


class drop_table_args:
    """
    Attributes:
     - dbname
     - name
     - deleteData

    """

    def __init__(
        self,
        dbname=None,
        name=None,
        deleteData=None,
    ):
        self.dbname = dbname
        self.name = name
        self.deleteData = deleteData

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_table_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 2)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin("deleteData", TType.BOOL, 3)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_table_args)
drop_table_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.BOOL,
        "deleteData",
        None,
        None,
    ),  # 3
)


class drop_table_result:
    """
    Attributes:
     - o1
     - o3

    """

    def __init__(
        self,
        o1=None,
        o3=None,
    ):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_table_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_table_result)
drop_table_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_table_with_environment_context_args:
    """
    Attributes:
     - dbname
     - name
     - deleteData
     - environment_context

    """

    def __init__(
        self,
        dbname=None,
        name=None,
        deleteData=None,
        environment_context=None,
    ):
        self.dbname = dbname
        self.name = name
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_table_with_environment_context_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 2)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin("deleteData", TType.BOOL, 3)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_table_with_environment_context_args)
drop_table_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.BOOL,
        "deleteData",
        None,
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 4
)


class drop_table_with_environment_context_result:
    """
    Attributes:
     - o1
     - o3

    """

    def __init__(
        self,
        o1=None,
        o3=None,
    ):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_table_with_environment_context_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_table_with_environment_context_result)
drop_table_with_environment_context_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 2
)


class truncate_table_args:
    """
    Attributes:
     - dbName
     - tableName
     - partNames

    """

    def __init__(
        self,
        dbName=None,
        tableName=None,
        partNames=None,
    ):
        self.dbName = dbName
        self.tableName = tableName
        self.partNames = partNames

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.partNames = []
                    (_etype1352, _size1349) = iprot.readListBegin()
                    for _i1353 in range(_size1349):
                        _elem1354 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.partNames.append(_elem1354)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("truncate_table_args")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 2)
            oprot.writeString(self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.partNames is not None:
            oprot.writeFieldBegin("partNames", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.partNames))
            for iter1355 in self.partNames:
                oprot.writeString(iter1355.encode("utf-8") if sys.version_info[0] == 2 else iter1355)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(truncate_table_args)
truncate_table_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "partNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class truncate_table_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("truncate_table_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(truncate_table_result)
truncate_table_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class truncate_table_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = TruncateTableRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("truncate_table_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(truncate_table_req_args)
truncate_table_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [TruncateTableRequest, None],
        None,
    ),  # 1
)


class truncate_table_req_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TruncateTableResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("truncate_table_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(truncate_table_req_result)
truncate_table_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [TruncateTableResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_tables_args:
    """
    Attributes:
     - db_name
     - pattern

    """

    def __init__(
        self,
        db_name=None,
        pattern=None,
    ):
        self.db_name = db_name
        self.pattern = pattern

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_tables_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin("pattern", TType.STRING, 2)
            oprot.writeString(self.pattern.encode("utf-8") if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_tables_args)
get_tables_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "pattern",
        "UTF8",
        None,
    ),  # 2
)


class get_tables_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1359, _size1356) = iprot.readListBegin()
                    for _i1360 in range(_size1356):
                        _elem1361 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1361)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_tables_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1362 in self.success:
                oprot.writeString(iter1362.encode("utf-8") if sys.version_info[0] == 2 else iter1362)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_tables_result)
get_tables_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_tables_by_type_args:
    """
    Attributes:
     - db_name
     - pattern
     - tableType

    """

    def __init__(
        self,
        db_name=None,
        pattern=None,
        tableType=None,
    ):
        self.db_name = db_name
        self.pattern = pattern
        self.tableType = tableType

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableType = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_tables_by_type_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin("pattern", TType.STRING, 2)
            oprot.writeString(self.pattern.encode("utf-8") if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        if self.tableType is not None:
            oprot.writeFieldBegin("tableType", TType.STRING, 3)
            oprot.writeString(self.tableType.encode("utf-8") if sys.version_info[0] == 2 else self.tableType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_tables_by_type_args)
get_tables_by_type_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "pattern",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableType",
        "UTF8",
        None,
    ),  # 3
)


class get_tables_by_type_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1366, _size1363) = iprot.readListBegin()
                    for _i1367 in range(_size1363):
                        _elem1368 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1368)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_tables_by_type_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1369 in self.success:
                oprot.writeString(iter1369.encode("utf-8") if sys.version_info[0] == 2 else iter1369)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_tables_by_type_result)
get_tables_by_type_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_all_materialized_view_objects_for_rewriting_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_materialized_view_objects_for_rewriting_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_materialized_view_objects_for_rewriting_args)
get_all_materialized_view_objects_for_rewriting_args.thrift_spec = ()


class get_all_materialized_view_objects_for_rewriting_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1373, _size1370) = iprot.readListBegin()
                    for _i1374 in range(_size1370):
                        _elem1375 = Table()
                        _elem1375.read(iprot)
                        self.success.append(_elem1375)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_materialized_view_objects_for_rewriting_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1376 in self.success:
                iter1376.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_materialized_view_objects_for_rewriting_result)
get_all_materialized_view_objects_for_rewriting_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Table, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_materialized_views_for_rewriting_args:
    """
    Attributes:
     - db_name

    """

    def __init__(
        self,
        db_name=None,
    ):
        self.db_name = db_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_materialized_views_for_rewriting_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_materialized_views_for_rewriting_args)
get_materialized_views_for_rewriting_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
)


class get_materialized_views_for_rewriting_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1380, _size1377) = iprot.readListBegin()
                    for _i1381 in range(_size1377):
                        _elem1382 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1382)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_materialized_views_for_rewriting_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1383 in self.success:
                oprot.writeString(iter1383.encode("utf-8") if sys.version_info[0] == 2 else iter1383)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_materialized_views_for_rewriting_result)
get_materialized_views_for_rewriting_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_table_meta_args:
    """
    Attributes:
     - db_patterns
     - tbl_patterns
     - tbl_types

    """

    def __init__(
        self,
        db_patterns=None,
        tbl_patterns=None,
        tbl_types=None,
    ):
        self.db_patterns = db_patterns
        self.tbl_patterns = tbl_patterns
        self.tbl_types = tbl_types

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_patterns = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_patterns = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tbl_types = []
                    (_etype1387, _size1384) = iprot.readListBegin()
                    for _i1388 in range(_size1384):
                        _elem1389 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tbl_types.append(_elem1389)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_meta_args")
        if self.db_patterns is not None:
            oprot.writeFieldBegin("db_patterns", TType.STRING, 1)
            oprot.writeString(self.db_patterns.encode("utf-8") if sys.version_info[0] == 2 else self.db_patterns)
            oprot.writeFieldEnd()
        if self.tbl_patterns is not None:
            oprot.writeFieldBegin("tbl_patterns", TType.STRING, 2)
            oprot.writeString(self.tbl_patterns.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_patterns)
            oprot.writeFieldEnd()
        if self.tbl_types is not None:
            oprot.writeFieldBegin("tbl_types", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tbl_types))
            for iter1390 in self.tbl_types:
                oprot.writeString(iter1390.encode("utf-8") if sys.version_info[0] == 2 else iter1390)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_meta_args)
get_table_meta_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_patterns",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_patterns",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "tbl_types",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class get_table_meta_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1394, _size1391) = iprot.readListBegin()
                    for _i1395 in range(_size1391):
                        _elem1396 = TableMeta()
                        _elem1396.read(iprot)
                        self.success.append(_elem1396)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_meta_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1397 in self.success:
                iter1397.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_meta_result)
get_table_meta_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [TableMeta, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_all_tables_args:
    """
    Attributes:
     - db_name

    """

    def __init__(
        self,
        db_name=None,
    ):
        self.db_name = db_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_tables_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_tables_args)
get_all_tables_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
)


class get_all_tables_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1401, _size1398) = iprot.readListBegin()
                    for _i1402 in range(_size1398):
                        _elem1403 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1403)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_tables_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1404 in self.success:
                oprot.writeString(iter1404.encode("utf-8") if sys.version_info[0] == 2 else iter1404)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_tables_result)
get_all_tables_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_table_args:
    """
    Attributes:
     - dbname
     - tbl_name

    """

    def __init__(
        self,
        dbname=None,
        tbl_name=None,
    ):
        self.dbname = dbname
        self.tbl_name = tbl_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_args)
get_table_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
)


class get_table_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Table()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_result)
get_table_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Table, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_table_objects_by_name_args:
    """
    Attributes:
     - dbname
     - tbl_names

    """

    def __init__(
        self,
        dbname=None,
        tbl_names=None,
    ):
        self.dbname = dbname
        self.tbl_names = tbl_names

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tbl_names = []
                    (_etype1408, _size1405) = iprot.readListBegin()
                    for _i1409 in range(_size1405):
                        _elem1410 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tbl_names.append(_elem1410)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_objects_by_name_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_names is not None:
            oprot.writeFieldBegin("tbl_names", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.tbl_names))
            for iter1411 in self.tbl_names:
                oprot.writeString(iter1411.encode("utf-8") if sys.version_info[0] == 2 else iter1411)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_objects_by_name_args)
get_table_objects_by_name_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "tbl_names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 2
)


class get_table_objects_by_name_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1415, _size1412) = iprot.readListBegin()
                    for _i1416 in range(_size1412):
                        _elem1417 = Table()
                        _elem1417.read(iprot)
                        self.success.append(_elem1417)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_objects_by_name_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1418 in self.success:
                iter1418.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_objects_by_name_result)
get_table_objects_by_name_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Table, None], False),
        None,
    ),  # 0
)


class get_tables_ext_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetTablesExtRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_tables_ext_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_tables_ext_args)
get_tables_ext_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetTablesExtRequest, None],
        None,
    ),  # 1
)


class get_tables_ext_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1422, _size1419) = iprot.readListBegin()
                    for _i1423 in range(_size1419):
                        _elem1424 = ExtendedTableInfo()
                        _elem1424.read(iprot)
                        self.success.append(_elem1424)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_tables_ext_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1425 in self.success:
                iter1425.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_tables_ext_result)
get_tables_ext_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [ExtendedTableInfo, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_table_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetTableRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_req_args)
get_table_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetTableRequest, None],
        None,
    ),  # 1
)


class get_table_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTableResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_req_result)
get_table_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetTableResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_table_objects_by_name_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetTablesRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_objects_by_name_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_objects_by_name_req_args)
get_table_objects_by_name_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetTablesRequest, None],
        None,
    ),  # 1
)


class get_table_objects_by_name_req_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTablesResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_objects_by_name_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_objects_by_name_req_result)
get_table_objects_by_name_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetTablesResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class get_materialization_invalidation_info_args:
    """
    Attributes:
     - creation_metadata
     - validTxnList

    """

    def __init__(
        self,
        creation_metadata=None,
        validTxnList=None,
    ):
        self.creation_metadata = creation_metadata
        self.validTxnList = validTxnList

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.creation_metadata = CreationMetadata()
                    self.creation_metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.validTxnList = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_materialization_invalidation_info_args")
        if self.creation_metadata is not None:
            oprot.writeFieldBegin("creation_metadata", TType.STRUCT, 1)
            self.creation_metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.validTxnList is not None:
            oprot.writeFieldBegin("validTxnList", TType.STRING, 2)
            oprot.writeString(self.validTxnList.encode("utf-8") if sys.version_info[0] == 2 else self.validTxnList)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_materialization_invalidation_info_args)
get_materialization_invalidation_info_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "creation_metadata",
        [CreationMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "validTxnList",
        "UTF8",
        None,
    ),  # 2
)


class get_materialization_invalidation_info_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Materialization()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_materialization_invalidation_info_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_materialization_invalidation_info_result)
get_materialization_invalidation_info_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Materialization, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class update_creation_metadata_args:
    """
    Attributes:
     - catName
     - dbname
     - tbl_name
     - creation_metadata

    """

    def __init__(
        self,
        catName=None,
        dbname=None,
        tbl_name=None,
        creation_metadata=None,
    ):
        self.catName = catName
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.creation_metadata = creation_metadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creation_metadata = CreationMetadata()
                    self.creation_metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_creation_metadata_args")
        if self.catName is not None:
            oprot.writeFieldBegin("catName", TType.STRING, 1)
            oprot.writeString(self.catName.encode("utf-8") if sys.version_info[0] == 2 else self.catName)
            oprot.writeFieldEnd()
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 2)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 3)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.creation_metadata is not None:
            oprot.writeFieldBegin("creation_metadata", TType.STRUCT, 4)
            self.creation_metadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_creation_metadata_args)
update_creation_metadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "creation_metadata",
        [CreationMetadata, None],
        None,
    ),  # 4
)


class update_creation_metadata_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_creation_metadata_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_creation_metadata_result)
update_creation_metadata_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class get_table_names_by_filter_args:
    """
    Attributes:
     - dbname
     - filter
     - max_tables

    """

    def __init__(
        self,
        dbname=None,
        filter=None,
        max_tables=-1,
    ):
        self.dbname = dbname
        self.filter = filter
        self.max_tables = max_tables

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_tables = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_names_by_filter_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin("filter", TType.STRING, 2)
            oprot.writeString(self.filter.encode("utf-8") if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_tables is not None:
            oprot.writeFieldBegin("max_tables", TType.I16, 3)
            oprot.writeI16(self.max_tables)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_names_by_filter_args)
get_table_names_by_filter_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "filter",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I16,
        "max_tables",
        None,
        -1,
    ),  # 3
)


class get_table_names_by_filter_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1429, _size1426) = iprot.readListBegin()
                    for _i1430 in range(_size1426):
                        _elem1431 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1431)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_names_by_filter_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1432 in self.success:
                oprot.writeString(iter1432.encode("utf-8") if sys.version_info[0] == 2 else iter1432)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_names_by_filter_result)
get_table_names_by_filter_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
)


class alter_table_args:
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl

    """

    def __init__(
        self,
        dbname=None,
        tbl_name=None,
        new_tbl=None,
    ):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin("new_tbl", TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_args)
alter_table_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "new_tbl",
        [Table, None],
        None,
    ),  # 3
)


class alter_table_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_result)
alter_table_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_table_with_environment_context_args:
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context

    """

    def __init__(
        self,
        dbname=None,
        tbl_name=None,
        new_tbl=None,
        environment_context=None,
    ):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_with_environment_context_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin("new_tbl", TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_with_environment_context_args)
alter_table_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "new_tbl",
        [Table, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 4
)


class alter_table_with_environment_context_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_with_environment_context_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_with_environment_context_result)
alter_table_with_environment_context_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_table_with_cascade_args:
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl
     - cascade

    """

    def __init__(
        self,
        dbname=None,
        tbl_name=None,
        new_tbl=None,
        cascade=None,
    ):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl
        self.cascade = cascade

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_with_cascade_args")
        if self.dbname is not None:
            oprot.writeFieldBegin("dbname", TType.STRING, 1)
            oprot.writeString(self.dbname.encode("utf-8") if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin("new_tbl", TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin("cascade", TType.BOOL, 4)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_with_cascade_args)
alter_table_with_cascade_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "new_tbl",
        [Table, None],
        None,
    ),  # 3
    (
        4,
        TType.BOOL,
        "cascade",
        None,
        None,
    ),  # 4
)


class alter_table_with_cascade_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_with_cascade_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_with_cascade_result)
alter_table_with_cascade_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_table_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AlterTableRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_req_args)
alter_table_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AlterTableRequest, None],
        None,
    ),  # 1
)


class alter_table_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AlterTableResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_table_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_table_req_result)
alter_table_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AlterTableResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class add_partition_args:
    """
    Attributes:
     - new_part

    """

    def __init__(
        self,
        new_part=None,
    ):
        self.new_part = new_part

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partition_args")
        if self.new_part is not None:
            oprot.writeFieldBegin("new_part", TType.STRUCT, 1)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partition_args)
add_partition_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "new_part",
        [Partition, None],
        None,
    ),  # 1
)


class add_partition_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partition_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partition_result)
add_partition_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class add_partition_with_environment_context_args:
    """
    Attributes:
     - new_part
     - environment_context

    """

    def __init__(
        self,
        new_part=None,
        environment_context=None,
    ):
        self.new_part = new_part
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partition_with_environment_context_args")
        if self.new_part is not None:
            oprot.writeFieldBegin("new_part", TType.STRUCT, 1)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 2)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partition_with_environment_context_args)
add_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "new_part",
        [Partition, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 2
)


class add_partition_with_environment_context_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partition_with_environment_context_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partition_with_environment_context_result)
add_partition_with_environment_context_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class add_partitions_args:
    """
    Attributes:
     - new_parts

    """

    def __init__(
        self,
        new_parts=None,
    ):
        self.new_parts = new_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype1436, _size1433) = iprot.readListBegin()
                    for _i1437 in range(_size1433):
                        _elem1438 = Partition()
                        _elem1438.read(iprot)
                        self.new_parts.append(_elem1438)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partitions_args")
        if self.new_parts is not None:
            oprot.writeFieldBegin("new_parts", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter1439 in self.new_parts:
                iter1439.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partitions_args)
add_partitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "new_parts",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 1
)


class add_partitions_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partitions_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partitions_result)
add_partitions_result.thrift_spec = (
    (
        0,
        TType.I32,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class add_partitions_pspec_args:
    """
    Attributes:
     - new_parts

    """

    def __init__(
        self,
        new_parts=None,
    ):
        self.new_parts = new_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype1443, _size1440) = iprot.readListBegin()
                    for _i1444 in range(_size1440):
                        _elem1445 = PartitionSpec()
                        _elem1445.read(iprot)
                        self.new_parts.append(_elem1445)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partitions_pspec_args")
        if self.new_parts is not None:
            oprot.writeFieldBegin("new_parts", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter1446 in self.new_parts:
                iter1446.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partitions_pspec_args)
add_partitions_pspec_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "new_parts",
        (TType.STRUCT, [PartitionSpec, None], False),
        None,
    ),  # 1
)


class add_partitions_pspec_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partitions_pspec_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partitions_pspec_result)
add_partitions_pspec_result.thrift_spec = (
    (
        0,
        TType.I32,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class append_partition_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1450, _size1447) = iprot.readListBegin()
                    for _i1451 in range(_size1447):
                        _elem1452 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1452)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1453 in self.part_vals:
                oprot.writeString(iter1453.encode("utf-8") if sys.version_info[0] == 2 else iter1453)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_args)
append_partition_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class append_partition_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_result)
append_partition_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class add_partitions_req_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = AddPartitionsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partitions_req_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partitions_req_args)
add_partitions_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [AddPartitionsRequest, None],
        None,
    ),  # 1
)


class add_partitions_req_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AddPartitionsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_partitions_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_partitions_req_result)
add_partitions_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AddPartitionsResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class append_partition_with_environment_context_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1457, _size1454) = iprot.readListBegin()
                    for _i1458 in range(_size1454):
                        _elem1459 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1459)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1460 in self.part_vals:
                oprot.writeString(iter1460.encode("utf-8") if sys.version_info[0] == 2 else iter1460)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_with_environment_context_args)
append_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 4
)


class append_partition_with_environment_context_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_with_environment_context_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_with_environment_context_result)
append_partition_with_environment_context_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class append_partition_by_name_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_name=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_by_name_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 3)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_by_name_args)
append_partition_by_name_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 3
)


class append_partition_by_name_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_by_name_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_by_name_result)
append_partition_by_name_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class append_partition_by_name_with_environment_context_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_name=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_by_name_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 3)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_by_name_with_environment_context_args)
append_partition_by_name_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 4
)


class append_partition_by_name_with_environment_context_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("append_partition_by_name_with_environment_context_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(append_partition_by_name_with_environment_context_result)
append_partition_by_name_with_environment_context_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [AlreadyExistsException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class drop_partition_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - deleteData

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        deleteData=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.deleteData = deleteData

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1464, _size1461) = iprot.readListBegin()
                    for _i1465 in range(_size1461):
                        _elem1466 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1466)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1467 in self.part_vals:
                oprot.writeString(iter1467.encode("utf-8") if sys.version_info[0] == 2 else iter1467)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin("deleteData", TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_args)
drop_partition_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.BOOL,
        "deleteData",
        None,
        None,
    ),  # 4
)


class drop_partition_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_result)
drop_partition_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_partition_with_environment_context_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        deleteData=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1471, _size1468) = iprot.readListBegin()
                    for _i1472 in range(_size1468):
                        _elem1473 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1473)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1474 in self.part_vals:
                oprot.writeString(iter1474.encode("utf-8") if sys.version_info[0] == 2 else iter1474)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin("deleteData", TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 5)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_with_environment_context_args)
drop_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.BOOL,
        "deleteData",
        None,
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 5
)


class drop_partition_with_environment_context_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_with_environment_context_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_with_environment_context_result)
drop_partition_with_environment_context_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_partition_by_name_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - deleteData

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_name=None,
        deleteData=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.deleteData = deleteData

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_by_name_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 3)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin("deleteData", TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_by_name_args)
drop_partition_by_name_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.BOOL,
        "deleteData",
        None,
        None,
    ),  # 4
)


class drop_partition_by_name_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_by_name_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_by_name_result)
drop_partition_by_name_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_partition_by_name_with_environment_context_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - deleteData
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_name=None,
        deleteData=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_by_name_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 3)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin("deleteData", TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 5)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_by_name_with_environment_context_args)
drop_partition_by_name_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.BOOL,
        "deleteData",
        None,
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 5
)


class drop_partition_by_name_with_environment_context_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partition_by_name_with_environment_context_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partition_by_name_with_environment_context_result)
drop_partition_by_name_with_environment_context_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_partitions_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = DropPartitionsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partitions_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partitions_req_args)
drop_partitions_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [DropPartitionsRequest, None],
        None,
    ),  # 1
)


class drop_partitions_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DropPartitionsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_partitions_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_partitions_req_result)
drop_partitions_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [DropPartitionsResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partition_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1478, _size1475) = iprot.readListBegin()
                    for _i1479 in range(_size1475):
                        _elem1480 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1480)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1481 in self.part_vals:
                oprot.writeString(iter1481.encode("utf-8") if sys.version_info[0] == 2 else iter1481)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_args)
get_partition_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class get_partition_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_result)
get_partition_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partition_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetPartitionRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_req_args)
get_partition_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetPartitionRequest, None],
        None,
    ),  # 1
)


class get_partition_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPartitionResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_req_result)
get_partition_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetPartitionResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class exchange_partition_args:
    """
    Attributes:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name

    """

    def __init__(
        self,
        partitionSpecs=None,
        source_db=None,
        source_table_name=None,
        dest_db=None,
        dest_table_name=None,
    ):
        self.partitionSpecs = partitionSpecs
        self.source_db = source_db
        self.source_table_name = source_table_name
        self.dest_db = dest_db
        self.dest_table_name = dest_table_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSpecs = {}
                    (_ktype1483, _vtype1484, _size1482) = iprot.readMapBegin()
                    for _i1486 in range(_size1482):
                        _key1487 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val1488 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.partitionSpecs[_key1487] = _val1488
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_db = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source_table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dest_db = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dest_table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("exchange_partition_args")
        if self.partitionSpecs is not None:
            oprot.writeFieldBegin("partitionSpecs", TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
            for kiter1489, viter1490 in self.partitionSpecs.items():
                oprot.writeString(kiter1489.encode("utf-8") if sys.version_info[0] == 2 else kiter1489)
                oprot.writeString(viter1490.encode("utf-8") if sys.version_info[0] == 2 else viter1490)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source_db is not None:
            oprot.writeFieldBegin("source_db", TType.STRING, 2)
            oprot.writeString(self.source_db.encode("utf-8") if sys.version_info[0] == 2 else self.source_db)
            oprot.writeFieldEnd()
        if self.source_table_name is not None:
            oprot.writeFieldBegin("source_table_name", TType.STRING, 3)
            oprot.writeString(self.source_table_name.encode("utf-8") if sys.version_info[0] == 2 else self.source_table_name)
            oprot.writeFieldEnd()
        if self.dest_db is not None:
            oprot.writeFieldBegin("dest_db", TType.STRING, 4)
            oprot.writeString(self.dest_db.encode("utf-8") if sys.version_info[0] == 2 else self.dest_db)
            oprot.writeFieldEnd()
        if self.dest_table_name is not None:
            oprot.writeFieldBegin("dest_table_name", TType.STRING, 5)
            oprot.writeString(self.dest_table_name.encode("utf-8") if sys.version_info[0] == 2 else self.dest_table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exchange_partition_args)
exchange_partition_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "partitionSpecs",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "source_db",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "source_table_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "dest_db",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "dest_table_name",
        "UTF8",
        None,
    ),  # 5
)


class exchange_partition_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("exchange_partition_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exchange_partition_result)
exchange_partition_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class exchange_partitions_args:
    """
    Attributes:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name

    """

    def __init__(
        self,
        partitionSpecs=None,
        source_db=None,
        source_table_name=None,
        dest_db=None,
        dest_table_name=None,
    ):
        self.partitionSpecs = partitionSpecs
        self.source_db = source_db
        self.source_table_name = source_table_name
        self.dest_db = dest_db
        self.dest_table_name = dest_table_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSpecs = {}
                    (_ktype1492, _vtype1493, _size1491) = iprot.readMapBegin()
                    for _i1495 in range(_size1491):
                        _key1496 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val1497 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.partitionSpecs[_key1496] = _val1497
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_db = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source_table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dest_db = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dest_table_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("exchange_partitions_args")
        if self.partitionSpecs is not None:
            oprot.writeFieldBegin("partitionSpecs", TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
            for kiter1498, viter1499 in self.partitionSpecs.items():
                oprot.writeString(kiter1498.encode("utf-8") if sys.version_info[0] == 2 else kiter1498)
                oprot.writeString(viter1499.encode("utf-8") if sys.version_info[0] == 2 else viter1499)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source_db is not None:
            oprot.writeFieldBegin("source_db", TType.STRING, 2)
            oprot.writeString(self.source_db.encode("utf-8") if sys.version_info[0] == 2 else self.source_db)
            oprot.writeFieldEnd()
        if self.source_table_name is not None:
            oprot.writeFieldBegin("source_table_name", TType.STRING, 3)
            oprot.writeString(self.source_table_name.encode("utf-8") if sys.version_info[0] == 2 else self.source_table_name)
            oprot.writeFieldEnd()
        if self.dest_db is not None:
            oprot.writeFieldBegin("dest_db", TType.STRING, 4)
            oprot.writeString(self.dest_db.encode("utf-8") if sys.version_info[0] == 2 else self.dest_db)
            oprot.writeFieldEnd()
        if self.dest_table_name is not None:
            oprot.writeFieldBegin("dest_table_name", TType.STRING, 5)
            oprot.writeString(self.dest_table_name.encode("utf-8") if sys.version_info[0] == 2 else self.dest_table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exchange_partitions_args)
exchange_partitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "partitionSpecs",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "source_db",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "source_table_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "dest_db",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "dest_table_name",
        "UTF8",
        None,
    ),  # 5
)


class exchange_partitions_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1503, _size1500) = iprot.readListBegin()
                    for _i1504 in range(_size1500):
                        _elem1505 = Partition()
                        _elem1505.read(iprot)
                        self.success.append(_elem1505)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("exchange_partitions_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1506 in self.success:
                iter1506.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exchange_partitions_result)
exchange_partitions_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class get_partition_with_auth_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        user_name=None,
        group_names=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1510, _size1507) = iprot.readListBegin()
                    for _i1511 in range(_size1507):
                        _elem1512 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1512)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype1516, _size1513) = iprot.readListBegin()
                    for _i1517 in range(_size1513):
                        _elem1518 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.group_names.append(_elem1518)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_with_auth_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1519 in self.part_vals:
                oprot.writeString(iter1519.encode("utf-8") if sys.version_info[0] == 2 else iter1519)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin("user_name", TType.STRING, 4)
            oprot.writeString(self.user_name.encode("utf-8") if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin("group_names", TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter1520 in self.group_names:
                oprot.writeString(iter1520.encode("utf-8") if sys.version_info[0] == 2 else iter1520)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_with_auth_args)
get_partition_with_auth_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "user_name",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.LIST,
        "group_names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 5
)


class get_partition_with_auth_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_with_auth_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_with_auth_result)
get_partition_with_auth_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partition_by_name_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_name=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_by_name_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 3)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_by_name_args)
get_partition_by_name_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 3
)


class get_partition_by_name_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_by_name_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_by_name_result)
get_partition_by_name_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Partition, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        max_parts=-1,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_args)
get_partitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I16,
        "max_parts",
        None,
        -1,
    ),  # 3
)


class get_partitions_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1524, _size1521) = iprot.readListBegin()
                    for _i1525 in range(_size1521):
                        _elem1526 = Partition()
                        _elem1526.read(iprot)
                        self.success.append(_elem1526)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1527 in self.success:
                iter1527.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_result)
get_partitions_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partitions_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PartitionsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_req_args)
get_partitions_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [PartitionsRequest, None],
        None,
    ),  # 1
)


class get_partitions_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_req_result)
get_partitions_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PartitionsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partitions_with_auth_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        max_parts=-1,
        user_name=None,
        group_names=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype1531, _size1528) = iprot.readListBegin()
                    for _i1532 in range(_size1528):
                        _elem1533 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.group_names.append(_elem1533)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_with_auth_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin("user_name", TType.STRING, 4)
            oprot.writeString(self.user_name.encode("utf-8") if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin("group_names", TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter1534 in self.group_names:
                oprot.writeString(iter1534.encode("utf-8") if sys.version_info[0] == 2 else iter1534)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_with_auth_args)
get_partitions_with_auth_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I16,
        "max_parts",
        None,
        -1,
    ),  # 3
    (
        4,
        TType.STRING,
        "user_name",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.LIST,
        "group_names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 5
)


class get_partitions_with_auth_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1538, _size1535) = iprot.readListBegin()
                    for _i1539 in range(_size1535):
                        _elem1540 = Partition()
                        _elem1540.read(iprot)
                        self.success.append(_elem1540)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_with_auth_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1541 in self.success:
                iter1541.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_with_auth_result)
get_partitions_with_auth_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partitions_pspec_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        max_parts=-1,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.max_parts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_pspec_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I32, 3)
            oprot.writeI32(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_pspec_args)
get_partitions_pspec_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I32,
        "max_parts",
        None,
        -1,
    ),  # 3
)


class get_partitions_pspec_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1545, _size1542) = iprot.readListBegin()
                    for _i1546 in range(_size1542):
                        _elem1547 = PartitionSpec()
                        _elem1547.read(iprot)
                        self.success.append(_elem1547)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_pspec_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1548 in self.success:
                iter1548.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_pspec_result)
get_partitions_pspec_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [PartitionSpec, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partition_names_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        max_parts=-1,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_args)
get_partition_names_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I16,
        "max_parts",
        None,
        -1,
    ),  # 3
)


class get_partition_names_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1552, _size1549) = iprot.readListBegin()
                    for _i1553 in range(_size1549):
                        _elem1554 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1554)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1555 in self.success:
                oprot.writeString(iter1555.encode("utf-8") if sys.version_info[0] == 2 else iter1555)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_result)
get_partition_names_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partition_values_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionValuesRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_values_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_values_args)
get_partition_values_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [PartitionValuesRequest, None],
        None,
    ),  # 1
)


class get_partition_values_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionValuesResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_values_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_values_result)
get_partition_values_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PartitionValuesResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_ps_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        max_parts=-1,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1559, _size1556) = iprot.readListBegin()
                    for _i1560 in range(_size1556):
                        _elem1561 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1561)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_ps_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1562 in self.part_vals:
                oprot.writeString(iter1562.encode("utf-8") if sys.version_info[0] == 2 else iter1562)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_ps_args)
get_partitions_ps_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.I16,
        "max_parts",
        None,
        -1,
    ),  # 4
)


class get_partitions_ps_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1566, _size1563) = iprot.readListBegin()
                    for _i1567 in range(_size1563):
                        _elem1568 = Partition()
                        _elem1568.read(iprot)
                        self.success.append(_elem1568)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_ps_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1569 in self.success:
                iter1569.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_ps_result)
get_partitions_ps_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_ps_with_auth_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        max_parts=-1,
        user_name=None,
        group_names=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1573, _size1570) = iprot.readListBegin()
                    for _i1574 in range(_size1570):
                        _elem1575 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1575)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.user_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype1579, _size1576) = iprot.readListBegin()
                    for _i1580 in range(_size1576):
                        _elem1581 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.group_names.append(_elem1581)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_ps_with_auth_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1582 in self.part_vals:
                oprot.writeString(iter1582.encode("utf-8") if sys.version_info[0] == 2 else iter1582)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin("user_name", TType.STRING, 5)
            oprot.writeString(self.user_name.encode("utf-8") if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin("group_names", TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter1583 in self.group_names:
                oprot.writeString(iter1583.encode("utf-8") if sys.version_info[0] == 2 else iter1583)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_ps_with_auth_args)
get_partitions_ps_with_auth_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.I16,
        "max_parts",
        None,
        -1,
    ),  # 4
    (
        5,
        TType.STRING,
        "user_name",
        "UTF8",
        None,
    ),  # 5
    (
        6,
        TType.LIST,
        "group_names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 6
)


class get_partitions_ps_with_auth_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1587, _size1584) = iprot.readListBegin()
                    for _i1588 in range(_size1584):
                        _elem1589 = Partition()
                        _elem1589.read(iprot)
                        self.success.append(_elem1589)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_ps_with_auth_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1590 in self.success:
                iter1590.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_ps_with_auth_result)
get_partitions_ps_with_auth_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partitions_ps_with_auth_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetPartitionsPsWithAuthRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_ps_with_auth_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_ps_with_auth_req_args)
get_partitions_ps_with_auth_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetPartitionsPsWithAuthRequest, None],
        None,
    ),  # 1
)


class get_partitions_ps_with_auth_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPartitionsPsWithAuthResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_ps_with_auth_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_ps_with_auth_req_result)
get_partitions_ps_with_auth_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetPartitionsPsWithAuthResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partition_names_ps_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        max_parts=-1,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1594, _size1591) = iprot.readListBegin()
                    for _i1595 in range(_size1591):
                        _elem1596 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1596)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_ps_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1597 in self.part_vals:
                oprot.writeString(iter1597.encode("utf-8") if sys.version_info[0] == 2 else iter1597)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_ps_args)
get_partition_names_ps_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.I16,
        "max_parts",
        None,
        -1,
    ),  # 4
)


class get_partition_names_ps_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1601, _size1598) = iprot.readListBegin()
                    for _i1602 in range(_size1598):
                        _elem1603 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1603)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_ps_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1604 in self.success:
                oprot.writeString(iter1604.encode("utf-8") if sys.version_info[0] == 2 else iter1604)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_ps_result)
get_partition_names_ps_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partition_names_ps_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetPartitionNamesPsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_ps_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_ps_req_args)
get_partition_names_ps_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetPartitionNamesPsRequest, None],
        None,
    ),  # 1
)


class get_partition_names_ps_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPartitionNamesPsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_ps_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_ps_req_result)
get_partition_names_ps_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetPartitionNamesPsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partition_names_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PartitionsByExprRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_req_args)
get_partition_names_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [PartitionsByExprRequest, None],
        None,
    ),  # 1
)


class get_partition_names_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1608, _size1605) = iprot.readListBegin()
                    for _i1609 in range(_size1605):
                        _elem1610 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1610)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_names_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1611 in self.success:
                oprot.writeString(iter1611.encode("utf-8") if sys.version_info[0] == 2 else iter1611)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_names_req_result)
get_partition_names_req_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_by_filter_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - filter
     - max_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        filter=None,
        max_parts=-1,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter
        self.max_parts = max_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_filter_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin("filter", TType.STRING, 3)
            oprot.writeString(self.filter.encode("utf-8") if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_filter_args)
get_partitions_by_filter_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "filter",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.I16,
        "max_parts",
        None,
        -1,
    ),  # 4
)


class get_partitions_by_filter_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1615, _size1612) = iprot.readListBegin()
                    for _i1616 in range(_size1612):
                        _elem1617 = Partition()
                        _elem1617.read(iprot)
                        self.success.append(_elem1617)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_filter_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1618 in self.success:
                iter1618.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_filter_result)
get_partitions_by_filter_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_part_specs_by_filter_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - filter
     - max_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        filter=None,
        max_parts=-1,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter
        self.max_parts = max_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_parts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_part_specs_by_filter_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin("filter", TType.STRING, 3)
            oprot.writeString(self.filter.encode("utf-8") if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin("max_parts", TType.I32, 4)
            oprot.writeI32(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_part_specs_by_filter_args)
get_part_specs_by_filter_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "filter",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.I32,
        "max_parts",
        None,
        -1,
    ),  # 4
)


class get_part_specs_by_filter_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1622, _size1619) = iprot.readListBegin()
                    for _i1623 in range(_size1619):
                        _elem1624 = PartitionSpec()
                        _elem1624.read(iprot)
                        self.success.append(_elem1624)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_part_specs_by_filter_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1625 in self.success:
                iter1625.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_part_specs_by_filter_result)
get_part_specs_by_filter_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [PartitionSpec, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_by_expr_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PartitionsByExprRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_expr_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_expr_args)
get_partitions_by_expr_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [PartitionsByExprRequest, None],
        None,
    ),  # 1
)


class get_partitions_by_expr_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsByExprResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_expr_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_expr_result)
get_partitions_by_expr_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PartitionsByExprResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_spec_by_expr_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PartitionsByExprRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_spec_by_expr_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_spec_by_expr_args)
get_partitions_spec_by_expr_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [PartitionsByExprRequest, None],
        None,
    ),  # 1
)


class get_partitions_spec_by_expr_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsSpecByExprResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_spec_by_expr_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_spec_by_expr_result)
get_partitions_spec_by_expr_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PartitionsSpecByExprResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_num_partitions_by_filter_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - filter

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        filter=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_num_partitions_by_filter_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin("filter", TType.STRING, 3)
            oprot.writeString(self.filter.encode("utf-8") if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_num_partitions_by_filter_args)
get_num_partitions_by_filter_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "filter",
        "UTF8",
        None,
    ),  # 3
)


class get_num_partitions_by_filter_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_num_partitions_by_filter_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_num_partitions_by_filter_result)
get_num_partitions_by_filter_result.thrift_spec = (
    (
        0,
        TType.I32,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_by_names_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - names

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        names=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.names = names

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype1629, _size1626) = iprot.readListBegin()
                    for _i1630 in range(_size1626):
                        _elem1631 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.names.append(_elem1631)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_names_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.names is not None:
            oprot.writeFieldBegin("names", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter1632 in self.names:
                oprot.writeString(iter1632.encode("utf-8") if sys.version_info[0] == 2 else iter1632)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_names_args)
get_partitions_by_names_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class get_partitions_by_names_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1636, _size1633) = iprot.readListBegin()
                    for _i1637 in range(_size1633):
                        _elem1638 = Partition()
                        _elem1638.read(iprot)
                        self.success.append(_elem1638)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_names_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1639 in self.success:
                iter1639.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_names_result)
get_partitions_by_names_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_partitions_by_names_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetPartitionsByNamesRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_names_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_names_req_args)
get_partitions_by_names_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetPartitionsByNamesRequest, None],
        None,
    ),  # 1
)


class get_partitions_by_names_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPartitionsByNamesResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_by_names_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_by_names_req_result)
get_partitions_by_names_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetPartitionsByNamesResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class alter_partition_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - new_part

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        new_part=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_part = new_part

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partition_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin("new_part", TType.STRUCT, 3)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partition_args)
alter_partition_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "new_part",
        [Partition, None],
        None,
    ),  # 3
)


class alter_partition_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partition_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partition_result)
alter_partition_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_partitions_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - new_parts

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        new_parts=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_parts = new_parts

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype1643, _size1640) = iprot.readListBegin()
                    for _i1644 in range(_size1640):
                        _elem1645 = Partition()
                        _elem1645.read(iprot)
                        self.new_parts.append(_elem1645)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partitions_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_parts is not None:
            oprot.writeFieldBegin("new_parts", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter1646 in self.new_parts:
                iter1646.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partitions_args)
alter_partitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "new_parts",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 3
)


class alter_partitions_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partitions_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partitions_result)
alter_partitions_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_partitions_with_environment_context_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - new_parts
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        new_parts=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_parts = new_parts
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype1650, _size1647) = iprot.readListBegin()
                    for _i1651 in range(_size1647):
                        _elem1652 = Partition()
                        _elem1652.read(iprot)
                        self.new_parts.append(_elem1652)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partitions_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_parts is not None:
            oprot.writeFieldBegin("new_parts", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter1653 in self.new_parts:
                iter1653.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partitions_with_environment_context_args)
alter_partitions_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "new_parts",
        (TType.STRUCT, [Partition, None], False),
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 4
)


class alter_partitions_with_environment_context_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partitions_with_environment_context_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partitions_with_environment_context_result)
alter_partitions_with_environment_context_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_partitions_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AlterPartitionsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partitions_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partitions_req_args)
alter_partitions_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [AlterPartitionsRequest, None],
        None,
    ),  # 1
)


class alter_partitions_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AlterPartitionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partitions_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partitions_req_result)
alter_partitions_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AlterPartitionsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_partition_with_environment_context_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - new_part
     - environment_context

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        new_part=None,
        environment_context=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_part = new_part
        self.environment_context = environment_context

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partition_with_environment_context_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin("new_part", TType.STRUCT, 3)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin("environment_context", TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partition_with_environment_context_args)
alter_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "new_part",
        [Partition, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "environment_context",
        [EnvironmentContext, None],
        None,
    ),  # 4
)


class alter_partition_with_environment_context_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_partition_with_environment_context_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_partition_with_environment_context_result)
alter_partition_with_environment_context_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class rename_partition_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - new_part

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        new_part=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.new_part = new_part

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1657, _size1654) = iprot.readListBegin()
                    for _i1658 in range(_size1654):
                        _elem1659 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1659)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("rename_partition_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1660 in self.part_vals:
                oprot.writeString(iter1660.encode("utf-8") if sys.version_info[0] == 2 else iter1660)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin("new_part", TType.STRUCT, 4)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(rename_partition_args)
rename_partition_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "new_part",
        [Partition, None],
        None,
    ),  # 4
)


class rename_partition_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("rename_partition_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(rename_partition_result)
rename_partition_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class rename_partition_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = RenamePartitionRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("rename_partition_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(rename_partition_req_args)
rename_partition_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [RenamePartitionRequest, None],
        None,
    ),  # 1
)


class rename_partition_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RenamePartitionResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("rename_partition_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(rename_partition_req_result)
rename_partition_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [RenamePartitionResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class partition_name_has_valid_characters_args:
    """
    Attributes:
     - part_vals
     - throw_exception

    """

    def __init__(
        self,
        part_vals=None,
        throw_exception=None,
    ):
        self.part_vals = part_vals
        self.throw_exception = throw_exception

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype1664, _size1661) = iprot.readListBegin()
                    for _i1665 in range(_size1661):
                        _elem1666 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals.append(_elem1666)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.throw_exception = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("partition_name_has_valid_characters_args")
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter1667 in self.part_vals:
                oprot.writeString(iter1667.encode("utf-8") if sys.version_info[0] == 2 else iter1667)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.throw_exception is not None:
            oprot.writeFieldBegin("throw_exception", TType.BOOL, 2)
            oprot.writeBool(self.throw_exception)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(partition_name_has_valid_characters_args)
partition_name_has_valid_characters_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "part_vals",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 1
    (
        2,
        TType.BOOL,
        "throw_exception",
        None,
        None,
    ),  # 2
)


class partition_name_has_valid_characters_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("partition_name_has_valid_characters_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(partition_name_has_valid_characters_result)
partition_name_has_valid_characters_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_config_value_args:
    """
    Attributes:
     - name
     - defaultValue

    """

    def __init__(
        self,
        name=None,
        defaultValue=None,
    ):
        self.name = name
        self.defaultValue = defaultValue

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.defaultValue = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_config_value_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.defaultValue is not None:
            oprot.writeFieldBegin("defaultValue", TType.STRING, 2)
            oprot.writeString(self.defaultValue.encode("utf-8") if sys.version_info[0] == 2 else self.defaultValue)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_config_value_args)
get_config_value_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "defaultValue",
        "UTF8",
        None,
    ),  # 2
)


class get_config_value_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = ConfigValSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_config_value_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(self.success.encode("utf-8") if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_config_value_result)
get_config_value_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [ConfigValSecurityException, None],
        None,
    ),  # 1
)


class partition_name_to_vals_args:
    """
    Attributes:
     - part_name

    """

    def __init__(
        self,
        part_name=None,
    ):
        self.part_name = part_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("partition_name_to_vals_args")
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 1)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(partition_name_to_vals_args)
partition_name_to_vals_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 1
)


class partition_name_to_vals_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1671, _size1668) = iprot.readListBegin()
                    for _i1672 in range(_size1668):
                        _elem1673 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1673)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("partition_name_to_vals_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1674 in self.success:
                oprot.writeString(iter1674.encode("utf-8") if sys.version_info[0] == 2 else iter1674)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(partition_name_to_vals_result)
partition_name_to_vals_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class partition_name_to_spec_args:
    """
    Attributes:
     - part_name

    """

    def __init__(
        self,
        part_name=None,
    ):
        self.part_name = part_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("partition_name_to_spec_args")
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 1)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(partition_name_to_spec_args)
partition_name_to_spec_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 1
)


class partition_name_to_spec_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1676, _vtype1677, _size1675) = iprot.readMapBegin()
                    for _i1679 in range(_size1675):
                        _key1680 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val1681 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key1680] = _val1681
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("partition_name_to_spec_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter1682, viter1683 in self.success.items():
                oprot.writeString(kiter1682.encode("utf-8") if sys.version_info[0] == 2 else kiter1682)
                oprot.writeString(viter1683.encode("utf-8") if sys.version_info[0] == 2 else viter1683)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(partition_name_to_spec_result)
partition_name_to_spec_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class markPartitionForEvent_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - eventType

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        eventType=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.eventType = eventType

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.part_vals = {}
                    (_ktype1685, _vtype1686, _size1684) = iprot.readMapBegin()
                    for _i1688 in range(_size1684):
                        _key1689 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val1690 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals[_key1689] = _val1690
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.eventType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("markPartitionForEvent_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
            for kiter1691, viter1692 in self.part_vals.items():
                oprot.writeString(kiter1691.encode("utf-8") if sys.version_info[0] == 2 else kiter1691)
                oprot.writeString(viter1692.encode("utf-8") if sys.version_info[0] == 2 else viter1692)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin("eventType", TType.I32, 4)
            oprot.writeI32(self.eventType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(markPartitionForEvent_args)
markPartitionForEvent_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "part_vals",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.I32,
        "eventType",
        None,
        None,
    ),  # 4
)


class markPartitionForEvent_result:
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4
     - o5
     - o6

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
        o5=None,
        o6=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4
        self.o5 = o5
        self.o6 = o6

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.o5 = UnknownPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.o6 = InvalidPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("markPartitionForEvent_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        if self.o5 is not None:
            oprot.writeFieldBegin("o5", TType.STRUCT, 5)
            self.o5.write(oprot)
            oprot.writeFieldEnd()
        if self.o6 is not None:
            oprot.writeFieldBegin("o6", TType.STRUCT, 6)
            self.o6.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(markPartitionForEvent_result)
markPartitionForEvent_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [UnknownTableException, None],
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "o5",
        [UnknownPartitionException, None],
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "o6",
        [InvalidPartitionException, None],
        None,
    ),  # 6
)


class isPartitionMarkedForEvent_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - eventType

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_vals=None,
        eventType=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.eventType = eventType

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.part_vals = {}
                    (_ktype1694, _vtype1695, _size1693) = iprot.readMapBegin()
                    for _i1697 in range(_size1693):
                        _key1698 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val1699 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.part_vals[_key1698] = _val1699
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.eventType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("isPartitionMarkedForEvent_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin("part_vals", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
            for kiter1700, viter1701 in self.part_vals.items():
                oprot.writeString(kiter1700.encode("utf-8") if sys.version_info[0] == 2 else kiter1700)
                oprot.writeString(viter1701.encode("utf-8") if sys.version_info[0] == 2 else viter1701)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin("eventType", TType.I32, 4)
            oprot.writeI32(self.eventType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(isPartitionMarkedForEvent_args)
isPartitionMarkedForEvent_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "part_vals",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.I32,
        "eventType",
        None,
        None,
    ),  # 4
)


class isPartitionMarkedForEvent_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
     - o5
     - o6

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
        o5=None,
        o6=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4
        self.o5 = o5
        self.o6 = o6

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.o5 = UnknownPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.o6 = InvalidPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("isPartitionMarkedForEvent_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        if self.o5 is not None:
            oprot.writeFieldBegin("o5", TType.STRUCT, 5)
            self.o5.write(oprot)
            oprot.writeFieldEnd()
        if self.o6 is not None:
            oprot.writeFieldBegin("o6", TType.STRUCT, 6)
            self.o6.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(isPartitionMarkedForEvent_result)
isPartitionMarkedForEvent_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [UnknownDBException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [UnknownTableException, None],
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "o5",
        [UnknownPartitionException, None],
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "o6",
        [InvalidPartitionException, None],
        None,
    ),  # 6
)


class get_primary_keys_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PrimaryKeysRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_primary_keys_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_primary_keys_args)
get_primary_keys_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [PrimaryKeysRequest, None],
        None,
    ),  # 1
)


class get_primary_keys_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PrimaryKeysResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_primary_keys_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_primary_keys_result)
get_primary_keys_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PrimaryKeysResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_foreign_keys_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ForeignKeysRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_foreign_keys_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_foreign_keys_args)
get_foreign_keys_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [ForeignKeysRequest, None],
        None,
    ),  # 1
)


class get_foreign_keys_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ForeignKeysResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_foreign_keys_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_foreign_keys_result)
get_foreign_keys_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ForeignKeysResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_unique_constraints_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = UniqueConstraintsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_unique_constraints_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_unique_constraints_args)
get_unique_constraints_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [UniqueConstraintsRequest, None],
        None,
    ),  # 1
)


class get_unique_constraints_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UniqueConstraintsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_unique_constraints_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_unique_constraints_result)
get_unique_constraints_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [UniqueConstraintsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_not_null_constraints_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = NotNullConstraintsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_not_null_constraints_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_not_null_constraints_args)
get_not_null_constraints_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [NotNullConstraintsRequest, None],
        None,
    ),  # 1
)


class get_not_null_constraints_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NotNullConstraintsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_not_null_constraints_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_not_null_constraints_result)
get_not_null_constraints_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [NotNullConstraintsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_default_constraints_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = DefaultConstraintsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_default_constraints_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_default_constraints_args)
get_default_constraints_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [DefaultConstraintsRequest, None],
        None,
    ),  # 1
)


class get_default_constraints_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DefaultConstraintsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_default_constraints_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_default_constraints_result)
get_default_constraints_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [DefaultConstraintsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_check_constraints_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = CheckConstraintsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_check_constraints_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_check_constraints_args)
get_check_constraints_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [CheckConstraintsRequest, None],
        None,
    ),  # 1
)


class get_check_constraints_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CheckConstraintsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_check_constraints_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_check_constraints_result)
get_check_constraints_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CheckConstraintsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_all_table_constraints_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = AllTableConstraintsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_table_constraints_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_table_constraints_args)
get_all_table_constraints_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [AllTableConstraintsRequest, None],
        None,
    ),  # 1
)


class get_all_table_constraints_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AllTableConstraintsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_table_constraints_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_table_constraints_result)
get_all_table_constraints_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AllTableConstraintsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class update_table_column_statistics_args:
    """
    Attributes:
     - stats_obj

    """

    def __init__(
        self,
        stats_obj=None,
    ):
        self.stats_obj = stats_obj

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats_obj = ColumnStatistics()
                    self.stats_obj.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_table_column_statistics_args")
        if self.stats_obj is not None:
            oprot.writeFieldBegin("stats_obj", TType.STRUCT, 1)
            self.stats_obj.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_table_column_statistics_args)
update_table_column_statistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "stats_obj",
        [ColumnStatistics, None],
        None,
    ),  # 1
)


class update_table_column_statistics_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_table_column_statistics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_table_column_statistics_result)
update_table_column_statistics_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class update_partition_column_statistics_args:
    """
    Attributes:
     - stats_obj

    """

    def __init__(
        self,
        stats_obj=None,
    ):
        self.stats_obj = stats_obj

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats_obj = ColumnStatistics()
                    self.stats_obj.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_partition_column_statistics_args")
        if self.stats_obj is not None:
            oprot.writeFieldBegin("stats_obj", TType.STRUCT, 1)
            self.stats_obj.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_partition_column_statistics_args)
update_partition_column_statistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "stats_obj",
        [ColumnStatistics, None],
        None,
    ),  # 1
)


class update_partition_column_statistics_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_partition_column_statistics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_partition_column_statistics_result)
update_partition_column_statistics_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class update_table_column_statistics_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = SetPartitionsStatsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_table_column_statistics_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_table_column_statistics_req_args)
update_table_column_statistics_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [SetPartitionsStatsRequest, None],
        None,
    ),  # 1
)


class update_table_column_statistics_req_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SetPartitionsStatsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_table_column_statistics_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_table_column_statistics_req_result)
update_table_column_statistics_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [SetPartitionsStatsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class update_partition_column_statistics_req_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = SetPartitionsStatsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_partition_column_statistics_req_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_partition_column_statistics_req_args)
update_partition_column_statistics_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [SetPartitionsStatsRequest, None],
        None,
    ),  # 1
)


class update_partition_column_statistics_req_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SetPartitionsStatsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_partition_column_statistics_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_partition_column_statistics_req_result)
update_partition_column_statistics_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [SetPartitionsStatsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class update_transaction_statistics_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = UpdateTransactionalStatsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_transaction_statistics_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_transaction_statistics_args)
update_transaction_statistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [UpdateTransactionalStatsRequest, None],
        None,
    ),  # 1
)


class update_transaction_statistics_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_transaction_statistics_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_transaction_statistics_result)
update_transaction_statistics_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_table_column_statistics_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - col_name

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        col_name=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.col_name = col_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_column_statistics_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin("col_name", TType.STRING, 3)
            oprot.writeString(self.col_name.encode("utf-8") if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_column_statistics_args)
get_table_column_statistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "col_name",
        "UTF8",
        None,
    ),  # 3
)


class get_table_column_statistics_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ColumnStatistics()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_column_statistics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_column_statistics_result)
get_table_column_statistics_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ColumnStatistics, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidInputException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidObjectException, None],
        None,
    ),  # 4
)


class get_partition_column_statistics_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - col_name

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_name=None,
        col_name=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.col_name = col_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.col_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_column_statistics_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 3)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin("col_name", TType.STRING, 4)
            oprot.writeString(self.col_name.encode("utf-8") if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_column_statistics_args)
get_partition_column_statistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "col_name",
        "UTF8",
        None,
    ),  # 4
)


class get_partition_column_statistics_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ColumnStatistics()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partition_column_statistics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partition_column_statistics_result)
get_partition_column_statistics_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ColumnStatistics, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidInputException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidObjectException, None],
        None,
    ),  # 4
)


class get_table_statistics_req_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = TableStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_statistics_req_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_statistics_req_args)
get_table_statistics_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [TableStatsRequest, None],
        None,
    ),  # 1
)


class get_table_statistics_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TableStatsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_table_statistics_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_table_statistics_req_result)
get_table_statistics_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [TableStatsResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_partitions_statistics_req_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_statistics_req_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_statistics_req_args)
get_partitions_statistics_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [PartitionsStatsRequest, None],
        None,
    ),  # 1
)


class get_partitions_statistics_req_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsStatsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_statistics_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_statistics_req_result)
get_partitions_statistics_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PartitionsStatsResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_aggr_stats_for_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_aggr_stats_for_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_aggr_stats_for_args)
get_aggr_stats_for_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [PartitionsStatsRequest, None],
        None,
    ),  # 1
)


class get_aggr_stats_for_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AggrStats()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_aggr_stats_for_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_aggr_stats_for_result)
get_aggr_stats_for_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AggrStats, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class set_aggr_stats_for_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = SetPartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_aggr_stats_for_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_aggr_stats_for_args)
set_aggr_stats_for_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [SetPartitionsStatsRequest, None],
        None,
    ),  # 1
)


class set_aggr_stats_for_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_aggr_stats_for_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_aggr_stats_for_result)
set_aggr_stats_for_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class delete_partition_column_statistics_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - col_name
     - engine

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        part_name=None,
        col_name=None,
        engine=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.col_name = col_name
        self.engine = engine

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.col_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.engine = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("delete_partition_column_statistics_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin("part_name", TType.STRING, 3)
            oprot.writeString(self.part_name.encode("utf-8") if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin("col_name", TType.STRING, 4)
            oprot.writeString(self.col_name.encode("utf-8") if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        if self.engine is not None:
            oprot.writeFieldBegin("engine", TType.STRING, 5)
            oprot.writeString(self.engine.encode("utf-8") if sys.version_info[0] == 2 else self.engine)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_partition_column_statistics_args)
delete_partition_column_statistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "part_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "col_name",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "engine",
        "UTF8",
        None,
    ),  # 5
)


class delete_partition_column_statistics_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("delete_partition_column_statistics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_partition_column_statistics_result)
delete_partition_column_statistics_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class delete_table_column_statistics_args:
    """
    Attributes:
     - db_name
     - tbl_name
     - col_name
     - engine

    """

    def __init__(
        self,
        db_name=None,
        tbl_name=None,
        col_name=None,
        engine=None,
    ):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.col_name = col_name
        self.engine = engine

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.engine = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("delete_table_column_statistics_args")
        if self.db_name is not None:
            oprot.writeFieldBegin("db_name", TType.STRING, 1)
            oprot.writeString(self.db_name.encode("utf-8") if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin("tbl_name", TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode("utf-8") if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin("col_name", TType.STRING, 3)
            oprot.writeString(self.col_name.encode("utf-8") if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        if self.engine is not None:
            oprot.writeFieldBegin("engine", TType.STRING, 4)
            oprot.writeString(self.engine.encode("utf-8") if sys.version_info[0] == 2 else self.engine)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_table_column_statistics_args)
delete_table_column_statistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "db_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tbl_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "col_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "engine",
        "UTF8",
        None,
    ),  # 4
)


class delete_table_column_statistics_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("delete_table_column_statistics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_table_column_statistics_result)
delete_table_column_statistics_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class create_function_args:
    """
    Attributes:
     - func

    """

    def __init__(
        self,
        func=None,
    ):
        self.func = func

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.func = Function()
                    self.func.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_function_args")
        if self.func is not None:
            oprot.writeFieldBegin("func", TType.STRUCT, 1)
            self.func.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_function_args)
create_function_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "func",
        [Function, None],
        None,
    ),  # 1
)


class create_function_result:
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_function_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_function_result)
create_function_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [NoSuchObjectException, None],
        None,
    ),  # 4
)


class drop_function_args:
    """
    Attributes:
     - dbName
     - funcName

    """

    def __init__(
        self,
        dbName=None,
        funcName=None,
    ):
        self.dbName = dbName
        self.funcName = funcName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_function_args")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin("funcName", TType.STRING, 2)
            oprot.writeString(self.funcName.encode("utf-8") if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_function_args)
drop_function_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "funcName",
        "UTF8",
        None,
    ),  # 2
)


class drop_function_result:
    """
    Attributes:
     - o1
     - o3

    """

    def __init__(
        self,
        o1=None,
        o3=None,
    ):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_function_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_function_result)
drop_function_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 2
)


class alter_function_args:
    """
    Attributes:
     - dbName
     - funcName
     - newFunc

    """

    def __init__(
        self,
        dbName=None,
        funcName=None,
        newFunc=None,
    ):
        self.dbName = dbName
        self.funcName = funcName
        self.newFunc = newFunc

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.newFunc = Function()
                    self.newFunc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_function_args")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin("funcName", TType.STRING, 2)
            oprot.writeString(self.funcName.encode("utf-8") if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        if self.newFunc is not None:
            oprot.writeFieldBegin("newFunc", TType.STRUCT, 3)
            self.newFunc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_function_args)
alter_function_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "funcName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "newFunc",
        [Function, None],
        None,
    ),  # 3
)


class alter_function_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_function_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_function_result)
alter_function_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [InvalidOperationException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_functions_args:
    """
    Attributes:
     - dbName
     - pattern

    """

    def __init__(
        self,
        dbName=None,
        pattern=None,
    ):
        self.dbName = dbName
        self.pattern = pattern

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_functions_args")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin("pattern", TType.STRING, 2)
            oprot.writeString(self.pattern.encode("utf-8") if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_functions_args)
get_functions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "pattern",
        "UTF8",
        None,
    ),  # 2
)


class get_functions_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1705, _size1702) = iprot.readListBegin()
                    for _i1706 in range(_size1702):
                        _elem1707 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1707)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_functions_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1708 in self.success:
                oprot.writeString(iter1708.encode("utf-8") if sys.version_info[0] == 2 else iter1708)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_functions_result)
get_functions_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_function_args:
    """
    Attributes:
     - dbName
     - funcName

    """

    def __init__(
        self,
        dbName=None,
        funcName=None,
    ):
        self.dbName = dbName
        self.funcName = funcName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_function_args")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin("funcName", TType.STRING, 2)
            oprot.writeString(self.funcName.encode("utf-8") if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_function_args)
get_function_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "funcName",
        "UTF8",
        None,
    ),  # 2
)


class get_function_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Function()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_function_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_function_result)
get_function_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Function, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class get_all_functions_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_functions_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_functions_args)
get_all_functions_args.thrift_spec = ()


class get_all_functions_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAllFunctionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_functions_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_functions_result)
get_all_functions_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetAllFunctionsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class create_role_args:
    """
    Attributes:
     - role

    """

    def __init__(
        self,
        role=None,
    ):
        self.role = role

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.role = Role()
                    self.role.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_role_args")
        if self.role is not None:
            oprot.writeFieldBegin("role", TType.STRUCT, 1)
            self.role.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_role_args)
create_role_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "role",
        [Role, None],
        None,
    ),  # 1
)


class create_role_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_role_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_role_result)
create_role_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class drop_role_args:
    """
    Attributes:
     - role_name

    """

    def __init__(
        self,
        role_name=None,
    ):
        self.role_name = role_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_role_args")
        if self.role_name is not None:
            oprot.writeFieldBegin("role_name", TType.STRING, 1)
            oprot.writeString(self.role_name.encode("utf-8") if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_role_args)
drop_role_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "role_name",
        "UTF8",
        None,
    ),  # 1
)


class drop_role_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_role_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_role_result)
drop_role_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_role_names_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_role_names_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_role_names_args)
get_role_names_args.thrift_spec = ()


class get_role_names_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1712, _size1709) = iprot.readListBegin()
                    for _i1713 in range(_size1709):
                        _elem1714 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1714)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_role_names_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1715 in self.success:
                oprot.writeString(iter1715.encode("utf-8") if sys.version_info[0] == 2 else iter1715)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_role_names_result)
get_role_names_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class grant_role_args:
    """
    Attributes:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option

    """

    def __init__(
        self,
        role_name=None,
        principal_name=None,
        principal_type=None,
        grantor=None,
        grantorType=None,
        grant_option=None,
    ):
        self.role_name = role_name
        self.principal_name = principal_name
        self.principal_type = principal_type
        self.grantor = grantor
        self.grantorType = grantorType
        self.grant_option = grant_option

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.grantor = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.grantorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.grant_option = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_role_args")
        if self.role_name is not None:
            oprot.writeFieldBegin("role_name", TType.STRING, 1)
            oprot.writeString(self.role_name.encode("utf-8") if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin("principal_name", TType.STRING, 2)
            oprot.writeString(self.principal_name.encode("utf-8") if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin("principal_type", TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.grantor is not None:
            oprot.writeFieldBegin("grantor", TType.STRING, 4)
            oprot.writeString(self.grantor.encode("utf-8") if sys.version_info[0] == 2 else self.grantor)
            oprot.writeFieldEnd()
        if self.grantorType is not None:
            oprot.writeFieldBegin("grantorType", TType.I32, 5)
            oprot.writeI32(self.grantorType)
            oprot.writeFieldEnd()
        if self.grant_option is not None:
            oprot.writeFieldBegin("grant_option", TType.BOOL, 6)
            oprot.writeBool(self.grant_option)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_role_args)
grant_role_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "role_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "principal_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I32,
        "principal_type",
        None,
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "grantor",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.I32,
        "grantorType",
        None,
        None,
    ),  # 5
    (
        6,
        TType.BOOL,
        "grant_option",
        None,
        None,
    ),  # 6
)


class grant_role_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_role_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_role_result)
grant_role_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class revoke_role_args:
    """
    Attributes:
     - role_name
     - principal_name
     - principal_type

    """

    def __init__(
        self,
        role_name=None,
        principal_name=None,
        principal_type=None,
    ):
        self.role_name = role_name
        self.principal_name = principal_name
        self.principal_type = principal_type

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("revoke_role_args")
        if self.role_name is not None:
            oprot.writeFieldBegin("role_name", TType.STRING, 1)
            oprot.writeString(self.role_name.encode("utf-8") if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin("principal_name", TType.STRING, 2)
            oprot.writeString(self.principal_name.encode("utf-8") if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin("principal_type", TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(revoke_role_args)
revoke_role_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "role_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "principal_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I32,
        "principal_type",
        None,
        None,
    ),  # 3
)


class revoke_role_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("revoke_role_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(revoke_role_result)
revoke_role_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class list_roles_args:
    """
    Attributes:
     - principal_name
     - principal_type

    """

    def __init__(
        self,
        principal_name=None,
        principal_type=None,
    ):
        self.principal_name = principal_name
        self.principal_type = principal_type

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("list_roles_args")
        if self.principal_name is not None:
            oprot.writeFieldBegin("principal_name", TType.STRING, 1)
            oprot.writeString(self.principal_name.encode("utf-8") if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin("principal_type", TType.I32, 2)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(list_roles_args)
list_roles_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "principal_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.I32,
        "principal_type",
        None,
        None,
    ),  # 2
)


class list_roles_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1719, _size1716) = iprot.readListBegin()
                    for _i1720 in range(_size1716):
                        _elem1721 = Role()
                        _elem1721.read(iprot)
                        self.success.append(_elem1721)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("list_roles_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1722 in self.success:
                iter1722.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(list_roles_result)
list_roles_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Role, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class grant_revoke_role_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GrantRevokeRoleRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_revoke_role_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_revoke_role_args)
grant_revoke_role_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GrantRevokeRoleRequest, None],
        None,
    ),  # 1
)


class grant_revoke_role_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GrantRevokeRoleResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_revoke_role_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_revoke_role_result)
grant_revoke_role_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GrantRevokeRoleResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_principals_in_role_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetPrincipalsInRoleRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_principals_in_role_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_principals_in_role_args)
get_principals_in_role_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GetPrincipalsInRoleRequest, None],
        None,
    ),  # 1
)


class get_principals_in_role_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPrincipalsInRoleResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_principals_in_role_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_principals_in_role_result)
get_principals_in_role_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetPrincipalsInRoleResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_role_grants_for_principal_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetRoleGrantsForPrincipalRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_role_grants_for_principal_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_role_grants_for_principal_args)
get_role_grants_for_principal_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GetRoleGrantsForPrincipalRequest, None],
        None,
    ),  # 1
)


class get_role_grants_for_principal_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetRoleGrantsForPrincipalResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_role_grants_for_principal_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_role_grants_for_principal_result)
get_role_grants_for_principal_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetRoleGrantsForPrincipalResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_privilege_set_args:
    """
    Attributes:
     - hiveObject
     - user_name
     - group_names

    """

    def __init__(
        self,
        hiveObject=None,
        user_name=None,
        group_names=None,
    ):
        self.hiveObject = hiveObject
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hiveObject = HiveObjectRef()
                    self.hiveObject.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype1726, _size1723) = iprot.readListBegin()
                    for _i1727 in range(_size1723):
                        _elem1728 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.group_names.append(_elem1728)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_privilege_set_args")
        if self.hiveObject is not None:
            oprot.writeFieldBegin("hiveObject", TType.STRUCT, 1)
            self.hiveObject.write(oprot)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin("user_name", TType.STRING, 2)
            oprot.writeString(self.user_name.encode("utf-8") if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin("group_names", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter1729 in self.group_names:
                oprot.writeString(iter1729.encode("utf-8") if sys.version_info[0] == 2 else iter1729)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_privilege_set_args)
get_privilege_set_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "hiveObject",
        [HiveObjectRef, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "user_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "group_names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class get_privilege_set_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PrincipalPrivilegeSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_privilege_set_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_privilege_set_result)
get_privilege_set_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PrincipalPrivilegeSet, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class list_privileges_args:
    """
    Attributes:
     - principal_name
     - principal_type
     - hiveObject

    """

    def __init__(
        self,
        principal_name=None,
        principal_type=None,
        hiveObject=None,
    ):
        self.principal_name = principal_name
        self.principal_type = principal_type
        self.hiveObject = hiveObject

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.hiveObject = HiveObjectRef()
                    self.hiveObject.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("list_privileges_args")
        if self.principal_name is not None:
            oprot.writeFieldBegin("principal_name", TType.STRING, 1)
            oprot.writeString(self.principal_name.encode("utf-8") if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin("principal_type", TType.I32, 2)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.hiveObject is not None:
            oprot.writeFieldBegin("hiveObject", TType.STRUCT, 3)
            self.hiveObject.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(list_privileges_args)
list_privileges_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "principal_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.I32,
        "principal_type",
        None,
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "hiveObject",
        [HiveObjectRef, None],
        None,
    ),  # 3
)


class list_privileges_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1733, _size1730) = iprot.readListBegin()
                    for _i1734 in range(_size1730):
                        _elem1735 = HiveObjectPrivilege()
                        _elem1735.read(iprot)
                        self.success.append(_elem1735)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("list_privileges_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1736 in self.success:
                iter1736.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(list_privileges_result)
list_privileges_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [HiveObjectPrivilege, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class grant_privileges_args:
    """
    Attributes:
     - privileges

    """

    def __init__(
        self,
        privileges=None,
    ):
        self.privileges = privileges

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.privileges = PrivilegeBag()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_privileges_args")
        if self.privileges is not None:
            oprot.writeFieldBegin("privileges", TType.STRUCT, 1)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_privileges_args)
grant_privileges_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "privileges",
        [PrivilegeBag, None],
        None,
    ),  # 1
)


class grant_privileges_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_privileges_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_privileges_result)
grant_privileges_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class revoke_privileges_args:
    """
    Attributes:
     - privileges

    """

    def __init__(
        self,
        privileges=None,
    ):
        self.privileges = privileges

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.privileges = PrivilegeBag()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("revoke_privileges_args")
        if self.privileges is not None:
            oprot.writeFieldBegin("privileges", TType.STRUCT, 1)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(revoke_privileges_args)
revoke_privileges_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "privileges",
        [PrivilegeBag, None],
        None,
    ),  # 1
)


class revoke_privileges_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("revoke_privileges_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(revoke_privileges_result)
revoke_privileges_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class grant_revoke_privileges_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GrantRevokePrivilegeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_revoke_privileges_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_revoke_privileges_args)
grant_revoke_privileges_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GrantRevokePrivilegeRequest, None],
        None,
    ),  # 1
)


class grant_revoke_privileges_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GrantRevokePrivilegeResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("grant_revoke_privileges_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(grant_revoke_privileges_result)
grant_revoke_privileges_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GrantRevokePrivilegeResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class refresh_privileges_args:
    """
    Attributes:
     - objToRefresh
     - authorizer
     - grantRequest

    """

    def __init__(
        self,
        objToRefresh=None,
        authorizer=None,
        grantRequest=None,
    ):
        self.objToRefresh = objToRefresh
        self.authorizer = authorizer
        self.grantRequest = grantRequest

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.objToRefresh = HiveObjectRef()
                    self.objToRefresh.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.authorizer = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.grantRequest = GrantRevokePrivilegeRequest()
                    self.grantRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("refresh_privileges_args")
        if self.objToRefresh is not None:
            oprot.writeFieldBegin("objToRefresh", TType.STRUCT, 1)
            self.objToRefresh.write(oprot)
            oprot.writeFieldEnd()
        if self.authorizer is not None:
            oprot.writeFieldBegin("authorizer", TType.STRING, 2)
            oprot.writeString(self.authorizer.encode("utf-8") if sys.version_info[0] == 2 else self.authorizer)
            oprot.writeFieldEnd()
        if self.grantRequest is not None:
            oprot.writeFieldBegin("grantRequest", TType.STRUCT, 3)
            self.grantRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(refresh_privileges_args)
refresh_privileges_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "objToRefresh",
        [HiveObjectRef, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "authorizer",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "grantRequest",
        [GrantRevokePrivilegeRequest, None],
        None,
    ),  # 3
)


class refresh_privileges_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GrantRevokePrivilegeResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("refresh_privileges_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(refresh_privileges_result)
refresh_privileges_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GrantRevokePrivilegeResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class set_ugi_args:
    """
    Attributes:
     - user_name
     - group_names

    """

    def __init__(
        self,
        user_name=None,
        group_names=None,
    ):
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype1740, _size1737) = iprot.readListBegin()
                    for _i1741 in range(_size1737):
                        _elem1742 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.group_names.append(_elem1742)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_ugi_args")
        if self.user_name is not None:
            oprot.writeFieldBegin("user_name", TType.STRING, 1)
            oprot.writeString(self.user_name.encode("utf-8") if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin("group_names", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter1743 in self.group_names:
                oprot.writeString(iter1743.encode("utf-8") if sys.version_info[0] == 2 else iter1743)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_ugi_args)
set_ugi_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "user_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "group_names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 2
)


class set_ugi_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1747, _size1744) = iprot.readListBegin()
                    for _i1748 in range(_size1744):
                        _elem1749 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1749)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_ugi_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1750 in self.success:
                oprot.writeString(iter1750.encode("utf-8") if sys.version_info[0] == 2 else iter1750)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_ugi_result)
set_ugi_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_delegation_token_args:
    """
    Attributes:
     - token_owner
     - renewer_kerberos_principal_name

    """

    def __init__(
        self,
        token_owner=None,
        renewer_kerberos_principal_name=None,
    ):
        self.token_owner = token_owner
        self.renewer_kerberos_principal_name = renewer_kerberos_principal_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_owner = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.renewer_kerberos_principal_name = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_delegation_token_args")
        if self.token_owner is not None:
            oprot.writeFieldBegin("token_owner", TType.STRING, 1)
            oprot.writeString(self.token_owner.encode("utf-8") if sys.version_info[0] == 2 else self.token_owner)
            oprot.writeFieldEnd()
        if self.renewer_kerberos_principal_name is not None:
            oprot.writeFieldBegin("renewer_kerberos_principal_name", TType.STRING, 2)
            oprot.writeString(
                self.renewer_kerberos_principal_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.renewer_kerberos_principal_name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_delegation_token_args)
get_delegation_token_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "token_owner",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "renewer_kerberos_principal_name",
        "UTF8",
        None,
    ),  # 2
)


class get_delegation_token_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_delegation_token_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(self.success.encode("utf-8") if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_delegation_token_result)
get_delegation_token_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class renew_delegation_token_args:
    """
    Attributes:
     - token_str_form

    """

    def __init__(
        self,
        token_str_form=None,
    ):
        self.token_str_form = token_str_form

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_str_form = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("renew_delegation_token_args")
        if self.token_str_form is not None:
            oprot.writeFieldBegin("token_str_form", TType.STRING, 1)
            oprot.writeString(self.token_str_form.encode("utf-8") if sys.version_info[0] == 2 else self.token_str_form)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(renew_delegation_token_args)
renew_delegation_token_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "token_str_form",
        "UTF8",
        None,
    ),  # 1
)


class renew_delegation_token_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("renew_delegation_token_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(renew_delegation_token_result)
renew_delegation_token_result.thrift_spec = (
    (
        0,
        TType.I64,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class cancel_delegation_token_args:
    """
    Attributes:
     - token_str_form

    """

    def __init__(
        self,
        token_str_form=None,
    ):
        self.token_str_form = token_str_form

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_str_form = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("cancel_delegation_token_args")
        if self.token_str_form is not None:
            oprot.writeFieldBegin("token_str_form", TType.STRING, 1)
            oprot.writeString(self.token_str_form.encode("utf-8") if sys.version_info[0] == 2 else self.token_str_form)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(cancel_delegation_token_args)
cancel_delegation_token_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "token_str_form",
        "UTF8",
        None,
    ),  # 1
)


class cancel_delegation_token_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("cancel_delegation_token_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(cancel_delegation_token_result)
cancel_delegation_token_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class add_token_args:
    """
    Attributes:
     - token_identifier
     - delegation_token

    """

    def __init__(
        self,
        token_identifier=None,
        delegation_token=None,
    ):
        self.token_identifier = token_identifier
        self.delegation_token = delegation_token

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_identifier = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.delegation_token = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_token_args")
        if self.token_identifier is not None:
            oprot.writeFieldBegin("token_identifier", TType.STRING, 1)
            oprot.writeString(self.token_identifier.encode("utf-8") if sys.version_info[0] == 2 else self.token_identifier)
            oprot.writeFieldEnd()
        if self.delegation_token is not None:
            oprot.writeFieldBegin("delegation_token", TType.STRING, 2)
            oprot.writeString(self.delegation_token.encode("utf-8") if sys.version_info[0] == 2 else self.delegation_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_token_args)
add_token_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "token_identifier",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "delegation_token",
        "UTF8",
        None,
    ),  # 2
)


class add_token_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_token_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_token_result)
add_token_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class remove_token_args:
    """
    Attributes:
     - token_identifier

    """

    def __init__(
        self,
        token_identifier=None,
    ):
        self.token_identifier = token_identifier

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_identifier = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("remove_token_args")
        if self.token_identifier is not None:
            oprot.writeFieldBegin("token_identifier", TType.STRING, 1)
            oprot.writeString(self.token_identifier.encode("utf-8") if sys.version_info[0] == 2 else self.token_identifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_token_args)
remove_token_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "token_identifier",
        "UTF8",
        None,
    ),  # 1
)


class remove_token_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("remove_token_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_token_result)
remove_token_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class get_token_args:
    """
    Attributes:
     - token_identifier

    """

    def __init__(
        self,
        token_identifier=None,
    ):
        self.token_identifier = token_identifier

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_identifier = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_token_args")
        if self.token_identifier is not None:
            oprot.writeFieldBegin("token_identifier", TType.STRING, 1)
            oprot.writeString(self.token_identifier.encode("utf-8") if sys.version_info[0] == 2 else self.token_identifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_token_args)
get_token_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "token_identifier",
        "UTF8",
        None,
    ),  # 1
)


class get_token_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_token_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(self.success.encode("utf-8") if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_token_result)
get_token_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
)


class get_all_token_identifiers_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_token_identifiers_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_token_identifiers_args)
get_all_token_identifiers_args.thrift_spec = ()


class get_all_token_identifiers_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1754, _size1751) = iprot.readListBegin()
                    for _i1755 in range(_size1751):
                        _elem1756 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1756)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_token_identifiers_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1757 in self.success:
                oprot.writeString(iter1757.encode("utf-8") if sys.version_info[0] == 2 else iter1757)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_token_identifiers_result)
get_all_token_identifiers_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class add_master_key_args:
    """
    Attributes:
     - key

    """

    def __init__(
        self,
        key=None,
    ):
        self.key = key

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_master_key_args")
        if self.key is not None:
            oprot.writeFieldBegin("key", TType.STRING, 1)
            oprot.writeString(self.key.encode("utf-8") if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_master_key_args)
add_master_key_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "key",
        "UTF8",
        None,
    ),  # 1
)


class add_master_key_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_master_key_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_master_key_result)
add_master_key_result.thrift_spec = (
    (
        0,
        TType.I32,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class update_master_key_args:
    """
    Attributes:
     - seq_number
     - key

    """

    def __init__(
        self,
        seq_number=None,
        key=None,
    ):
        self.seq_number = seq_number
        self.key = key

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq_number = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_master_key_args")
        if self.seq_number is not None:
            oprot.writeFieldBegin("seq_number", TType.I32, 1)
            oprot.writeI32(self.seq_number)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin("key", TType.STRING, 2)
            oprot.writeString(self.key.encode("utf-8") if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_master_key_args)
update_master_key_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I32,
        "seq_number",
        None,
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "key",
        "UTF8",
        None,
    ),  # 2
)


class update_master_key_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_master_key_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_master_key_result)
update_master_key_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class remove_master_key_args:
    """
    Attributes:
     - key_seq

    """

    def __init__(
        self,
        key_seq=None,
    ):
        self.key_seq = key_seq

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.key_seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("remove_master_key_args")
        if self.key_seq is not None:
            oprot.writeFieldBegin("key_seq", TType.I32, 1)
            oprot.writeI32(self.key_seq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_master_key_args)
remove_master_key_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I32,
        "key_seq",
        None,
        None,
    ),  # 1
)


class remove_master_key_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("remove_master_key_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_master_key_result)
remove_master_key_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class get_master_keys_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_master_keys_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_master_keys_args)
get_master_keys_args.thrift_spec = ()


class get_master_keys_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1761, _size1758) = iprot.readListBegin()
                    for _i1762 in range(_size1758):
                        _elem1763 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1763)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_master_keys_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1764 in self.success:
                oprot.writeString(iter1764.encode("utf-8") if sys.version_info[0] == 2 else iter1764)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_master_keys_result)
get_master_keys_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class get_open_txns_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_open_txns_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_open_txns_args)
get_open_txns_args.thrift_spec = ()


class get_open_txns_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetOpenTxnsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_open_txns_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_open_txns_result)
get_open_txns_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetOpenTxnsResponse, None],
        None,
    ),  # 0
)


class get_open_txns_info_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_open_txns_info_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_open_txns_info_args)
get_open_txns_info_args.thrift_spec = ()


class get_open_txns_info_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetOpenTxnsInfoResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_open_txns_info_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_open_txns_info_result)
get_open_txns_info_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetOpenTxnsInfoResponse, None],
        None,
    ),  # 0
)


class open_txns_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = OpenTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("open_txns_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(open_txns_args)
open_txns_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [OpenTxnRequest, None],
        None,
    ),  # 1
)


class open_txns_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = OpenTxnsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("open_txns_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(open_txns_result)
open_txns_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [OpenTxnsResponse, None],
        None,
    ),  # 0
)


class abort_txn_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AbortTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("abort_txn_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(abort_txn_args)
abort_txn_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [AbortTxnRequest, None],
        None,
    ),  # 1
)


class abort_txn_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("abort_txn_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(abort_txn_result)
abort_txn_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
)


class abort_txns_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AbortTxnsRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("abort_txns_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(abort_txns_args)
abort_txns_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [AbortTxnsRequest, None],
        None,
    ),  # 1
)


class abort_txns_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("abort_txns_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(abort_txns_result)
abort_txns_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
)


class commit_txn_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CommitTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("commit_txn_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(commit_txn_args)
commit_txn_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [CommitTxnRequest, None],
        None,
    ),  # 1
)


class commit_txn_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("commit_txn_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(commit_txn_result)
commit_txn_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [TxnAbortedException, None],
        None,
    ),  # 2
)


class get_latest_txnid_in_conflict_args:
    """
    Attributes:
     - txnId

    """

    def __init__(
        self,
        txnId=None,
    ):
        self.txnId = txnId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.txnId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_latest_txnid_in_conflict_args")
        if self.txnId is not None:
            oprot.writeFieldBegin("txnId", TType.I64, 1)
            oprot.writeI64(self.txnId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_latest_txnid_in_conflict_args)
get_latest_txnid_in_conflict_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "txnId",
        None,
        None,
    ),  # 1
)


class get_latest_txnid_in_conflict_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_latest_txnid_in_conflict_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_latest_txnid_in_conflict_result)
get_latest_txnid_in_conflict_result.thrift_spec = (
    (
        0,
        TType.I64,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class repl_tbl_writeid_state_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = ReplTblWriteIdStateRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("repl_tbl_writeid_state_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(repl_tbl_writeid_state_args)
repl_tbl_writeid_state_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [ReplTblWriteIdStateRequest, None],
        None,
    ),  # 1
)


class repl_tbl_writeid_state_result:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("repl_tbl_writeid_state_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(repl_tbl_writeid_state_result)
repl_tbl_writeid_state_result.thrift_spec = ()


class get_valid_write_ids_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = GetValidWriteIdsRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_valid_write_ids_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_valid_write_ids_args)
get_valid_write_ids_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [GetValidWriteIdsRequest, None],
        None,
    ),  # 1
)


class get_valid_write_ids_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetValidWriteIdsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_valid_write_ids_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_valid_write_ids_result)
get_valid_write_ids_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetValidWriteIdsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class allocate_table_write_ids_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AllocateTableWriteIdsRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("allocate_table_write_ids_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(allocate_table_write_ids_args)
allocate_table_write_ids_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [AllocateTableWriteIdsRequest, None],
        None,
    ),  # 1
)


class allocate_table_write_ids_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AllocateTableWriteIdsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("allocate_table_write_ids_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(allocate_table_write_ids_result)
allocate_table_write_ids_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AllocateTableWriteIdsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [TxnAbortedException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_max_allocated_table_write_id_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = MaxAllocatedTableWriteIdRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_max_allocated_table_write_id_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_max_allocated_table_write_id_args)
get_max_allocated_table_write_id_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [MaxAllocatedTableWriteIdRequest, None],
        None,
    ),  # 1
)


class get_max_allocated_table_write_id_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MaxAllocatedTableWriteIdResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_max_allocated_table_write_id_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_max_allocated_table_write_id_result)
get_max_allocated_table_write_id_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [MaxAllocatedTableWriteIdResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class seed_write_id_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = SeedTableWriteIdsRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("seed_write_id_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(seed_write_id_args)
seed_write_id_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [SeedTableWriteIdsRequest, None],
        None,
    ),  # 1
)


class seed_write_id_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("seed_write_id_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(seed_write_id_result)
seed_write_id_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class seed_txn_id_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = SeedTxnIdRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("seed_txn_id_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(seed_txn_id_args)
seed_txn_id_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [SeedTxnIdRequest, None],
        None,
    ),  # 1
)


class seed_txn_id_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("seed_txn_id_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(seed_txn_id_result)
seed_txn_id_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class lock_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = LockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("lock_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(lock_args)
lock_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [LockRequest, None],
        None,
    ),  # 1
)


class lock_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LockResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("lock_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(lock_result)
lock_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [LockResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [TxnAbortedException, None],
        None,
    ),  # 2
)


class check_lock_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CheckLockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("check_lock_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_lock_args)
check_lock_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [CheckLockRequest, None],
        None,
    ),  # 1
)


class check_lock_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LockResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = NoSuchLockException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("check_lock_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_lock_result)
check_lock_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [LockResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [TxnAbortedException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [NoSuchLockException, None],
        None,
    ),  # 3
)


class unlock_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = UnlockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("unlock_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(unlock_args)
unlock_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [UnlockRequest, None],
        None,
    ),  # 1
)


class unlock_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchLockException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnOpenException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("unlock_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(unlock_result)
unlock_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchLockException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [TxnOpenException, None],
        None,
    ),  # 2
)


class show_locks_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = ShowLocksRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("show_locks_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(show_locks_args)
show_locks_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [ShowLocksRequest, None],
        None,
    ),  # 1
)


class show_locks_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ShowLocksResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("show_locks_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(show_locks_result)
show_locks_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ShowLocksResponse, None],
        None,
    ),  # 0
)


class heartbeat_args:
    """
    Attributes:
     - ids

    """

    def __init__(
        self,
        ids=None,
    ):
        self.ids = ids

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ids = HeartbeatRequest()
                    self.ids.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("heartbeat_args")
        if self.ids is not None:
            oprot.writeFieldBegin("ids", TType.STRUCT, 1)
            self.ids.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(heartbeat_args)
heartbeat_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "ids",
        [HeartbeatRequest, None],
        None,
    ),  # 1
)


class heartbeat_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchLockException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("heartbeat_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(heartbeat_result)
heartbeat_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchLockException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchTxnException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [TxnAbortedException, None],
        None,
    ),  # 3
)


class heartbeat_txn_range_args:
    """
    Attributes:
     - txns

    """

    def __init__(
        self,
        txns=None,
    ):
        self.txns = txns

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.txns = HeartbeatTxnRangeRequest()
                    self.txns.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("heartbeat_txn_range_args")
        if self.txns is not None:
            oprot.writeFieldBegin("txns", TType.STRUCT, 1)
            self.txns.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(heartbeat_txn_range_args)
heartbeat_txn_range_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "txns",
        [HeartbeatTxnRangeRequest, None],
        None,
    ),  # 1
)


class heartbeat_txn_range_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = HeartbeatTxnRangeResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("heartbeat_txn_range_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(heartbeat_txn_range_result)
heartbeat_txn_range_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [HeartbeatTxnRangeResponse, None],
        None,
    ),  # 0
)


class compact_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CompactionRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("compact_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(compact_args)
compact_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [CompactionRequest, None],
        None,
    ),  # 1
)


class compact_result:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("compact_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(compact_result)
compact_result.thrift_spec = ()


class compact2_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CompactionRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("compact2_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(compact2_args)
compact2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [CompactionRequest, None],
        None,
    ),  # 1
)


class compact2_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CompactionResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("compact2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(compact2_result)
compact2_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CompactionResponse, None],
        None,
    ),  # 0
)


class show_compact_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = ShowCompactRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("show_compact_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(show_compact_args)
show_compact_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [ShowCompactRequest, None],
        None,
    ),  # 1
)


class show_compact_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ShowCompactResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("show_compact_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(show_compact_result)
show_compact_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ShowCompactResponse, None],
        None,
    ),  # 0
)


class add_dynamic_partitions_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AddDynamicPartitions()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_dynamic_partitions_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_dynamic_partitions_args)
add_dynamic_partitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [AddDynamicPartitions, None],
        None,
    ),  # 1
)


class add_dynamic_partitions_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_dynamic_partitions_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_dynamic_partitions_result)
add_dynamic_partitions_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchTxnException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [TxnAbortedException, None],
        None,
    ),  # 2
)


class find_next_compact_args:
    """
    Attributes:
     - workerId

    """

    def __init__(
        self,
        workerId=None,
    ):
        self.workerId = workerId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.workerId = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_next_compact_args")
        if self.workerId is not None:
            oprot.writeFieldBegin("workerId", TType.STRING, 1)
            oprot.writeString(self.workerId.encode("utf-8") if sys.version_info[0] == 2 else self.workerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_next_compact_args)
find_next_compact_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "workerId",
        "UTF8",
        None,
    ),  # 1
)


class find_next_compact_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = OptionalCompactionInfoStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_next_compact_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_next_compact_result)
find_next_compact_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [OptionalCompactionInfoStruct, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class find_next_compact2_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = FindNextCompactRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_next_compact2_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_next_compact2_args)
find_next_compact2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [FindNextCompactRequest, None],
        None,
    ),  # 1
)


class find_next_compact2_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = OptionalCompactionInfoStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_next_compact2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_next_compact2_result)
find_next_compact2_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [OptionalCompactionInfoStruct, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class update_compactor_state_args:
    """
    Attributes:
     - cr
     - txn_id

    """

    def __init__(
        self,
        cr=None,
        txn_id=None,
    ):
        self.cr = cr
        self.txn_id = txn_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cr = CompactionInfoStruct()
                    self.cr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.txn_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_compactor_state_args")
        if self.cr is not None:
            oprot.writeFieldBegin("cr", TType.STRUCT, 1)
            self.cr.write(oprot)
            oprot.writeFieldEnd()
        if self.txn_id is not None:
            oprot.writeFieldBegin("txn_id", TType.I64, 2)
            oprot.writeI64(self.txn_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_compactor_state_args)
update_compactor_state_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "cr",
        [CompactionInfoStruct, None],
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "txn_id",
        None,
        None,
    ),  # 2
)


class update_compactor_state_result:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_compactor_state_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_compactor_state_result)
update_compactor_state_result.thrift_spec = ()


class find_columns_with_stats_args:
    """
    Attributes:
     - cr

    """

    def __init__(
        self,
        cr=None,
    ):
        self.cr = cr

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cr = CompactionInfoStruct()
                    self.cr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_columns_with_stats_args")
        if self.cr is not None:
            oprot.writeFieldBegin("cr", TType.STRUCT, 1)
            self.cr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_columns_with_stats_args)
find_columns_with_stats_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "cr",
        [CompactionInfoStruct, None],
        None,
    ),  # 1
)


class find_columns_with_stats_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1768, _size1765) = iprot.readListBegin()
                    for _i1769 in range(_size1765):
                        _elem1770 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1770)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_columns_with_stats_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1771 in self.success:
                oprot.writeString(iter1771.encode("utf-8") if sys.version_info[0] == 2 else iter1771)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_columns_with_stats_result)
find_columns_with_stats_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class mark_cleaned_args:
    """
    Attributes:
     - cr

    """

    def __init__(
        self,
        cr=None,
    ):
        self.cr = cr

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cr = CompactionInfoStruct()
                    self.cr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_cleaned_args")
        if self.cr is not None:
            oprot.writeFieldBegin("cr", TType.STRUCT, 1)
            self.cr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_cleaned_args)
mark_cleaned_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "cr",
        [CompactionInfoStruct, None],
        None,
    ),  # 1
)


class mark_cleaned_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_cleaned_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_cleaned_result)
mark_cleaned_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class mark_compacted_args:
    """
    Attributes:
     - cr

    """

    def __init__(
        self,
        cr=None,
    ):
        self.cr = cr

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cr = CompactionInfoStruct()
                    self.cr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_compacted_args")
        if self.cr is not None:
            oprot.writeFieldBegin("cr", TType.STRUCT, 1)
            self.cr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_compacted_args)
mark_compacted_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "cr",
        [CompactionInfoStruct, None],
        None,
    ),  # 1
)


class mark_compacted_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_compacted_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_compacted_result)
mark_compacted_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class mark_failed_args:
    """
    Attributes:
     - cr

    """

    def __init__(
        self,
        cr=None,
    ):
        self.cr = cr

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cr = CompactionInfoStruct()
                    self.cr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_failed_args")
        if self.cr is not None:
            oprot.writeFieldBegin("cr", TType.STRUCT, 1)
            self.cr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_failed_args)
mark_failed_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "cr",
        [CompactionInfoStruct, None],
        None,
    ),  # 1
)


class mark_failed_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_failed_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_failed_result)
mark_failed_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class mark_refused_args:
    """
    Attributes:
     - cr

    """

    def __init__(
        self,
        cr=None,
    ):
        self.cr = cr

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cr = CompactionInfoStruct()
                    self.cr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_refused_args")
        if self.cr is not None:
            oprot.writeFieldBegin("cr", TType.STRUCT, 1)
            self.cr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_refused_args)
mark_refused_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "cr",
        [CompactionInfoStruct, None],
        None,
    ),  # 1
)


class mark_refused_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("mark_refused_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(mark_refused_result)
mark_refused_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class update_compaction_metrics_data_args:
    """
    Attributes:
     - data

    """

    def __init__(
        self,
        data=None,
    ):
        self.data = data

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.data = CompactionMetricsDataStruct()
                    self.data.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_compaction_metrics_data_args")
        if self.data is not None:
            oprot.writeFieldBegin("data", TType.STRUCT, 1)
            self.data.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_compaction_metrics_data_args)
update_compaction_metrics_data_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "data",
        [CompactionMetricsDataStruct, None],
        None,
    ),  # 1
)


class update_compaction_metrics_data_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("update_compaction_metrics_data_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(update_compaction_metrics_data_result)
update_compaction_metrics_data_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class remove_compaction_metrics_data_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = CompactionMetricsDataRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("remove_compaction_metrics_data_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_compaction_metrics_data_args)
remove_compaction_metrics_data_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [CompactionMetricsDataRequest, None],
        None,
    ),  # 1
)


class remove_compaction_metrics_data_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("remove_compaction_metrics_data_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_compaction_metrics_data_result)
remove_compaction_metrics_data_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class set_hadoop_jobid_args:
    """
    Attributes:
     - jobId
     - cq_id

    """

    def __init__(
        self,
        jobId=None,
        cq_id=None,
    ):
        self.jobId = jobId
        self.cq_id = cq_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.cq_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_hadoop_jobid_args")
        if self.jobId is not None:
            oprot.writeFieldBegin("jobId", TType.STRING, 1)
            oprot.writeString(self.jobId.encode("utf-8") if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.cq_id is not None:
            oprot.writeFieldBegin("cq_id", TType.I64, 2)
            oprot.writeI64(self.cq_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_hadoop_jobid_args)
set_hadoop_jobid_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "jobId",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "cq_id",
        None,
        None,
    ),  # 2
)


class set_hadoop_jobid_result:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_hadoop_jobid_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_hadoop_jobid_result)
set_hadoop_jobid_result.thrift_spec = ()


class get_latest_committed_compaction_info_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = GetLatestCommittedCompactionInfoRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_latest_committed_compaction_info_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_latest_committed_compaction_info_args)
get_latest_committed_compaction_info_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [GetLatestCommittedCompactionInfoRequest, None],
        None,
    ),  # 1
)


class get_latest_committed_compaction_info_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetLatestCommittedCompactionInfoResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_latest_committed_compaction_info_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_latest_committed_compaction_info_result)
get_latest_committed_compaction_info_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetLatestCommittedCompactionInfoResponse, None],
        None,
    ),  # 0
)


class get_next_notification_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = NotificationEventRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_next_notification_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_next_notification_args)
get_next_notification_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [NotificationEventRequest, None],
        None,
    ),  # 1
)


class get_next_notification_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NotificationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_next_notification_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_next_notification_result)
get_next_notification_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [NotificationEventResponse, None],
        None,
    ),  # 0
)


class get_current_notificationEventId_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_current_notificationEventId_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_current_notificationEventId_args)
get_current_notificationEventId_args.thrift_spec = ()


class get_current_notificationEventId_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CurrentNotificationEventId()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_current_notificationEventId_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_current_notificationEventId_result)
get_current_notificationEventId_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CurrentNotificationEventId, None],
        None,
    ),  # 0
)


class get_notification_events_count_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = NotificationEventsCountRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_notification_events_count_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_notification_events_count_args)
get_notification_events_count_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [NotificationEventsCountRequest, None],
        None,
    ),  # 1
)


class get_notification_events_count_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NotificationEventsCountResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_notification_events_count_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_notification_events_count_result)
get_notification_events_count_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [NotificationEventsCountResponse, None],
        None,
    ),  # 0
)


class fire_listener_event_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = FireEventRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("fire_listener_event_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(fire_listener_event_args)
fire_listener_event_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [FireEventRequest, None],
        None,
    ),  # 1
)


class fire_listener_event_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FireEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("fire_listener_event_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(fire_listener_event_result)
fire_listener_event_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [FireEventResponse, None],
        None,
    ),  # 0
)


class flushCache_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("flushCache_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(flushCache_args)
flushCache_args.thrift_spec = ()


class flushCache_result:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("flushCache_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(flushCache_result)
flushCache_result.thrift_spec = ()


class add_write_notification_log_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = WriteNotificationLogRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_write_notification_log_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_write_notification_log_args)
add_write_notification_log_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [WriteNotificationLogRequest, None],
        None,
    ),  # 1
)


class add_write_notification_log_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WriteNotificationLogResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_write_notification_log_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_write_notification_log_result)
add_write_notification_log_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WriteNotificationLogResponse, None],
        None,
    ),  # 0
)


class add_write_notification_log_in_batch_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = WriteNotificationLogBatchRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_write_notification_log_in_batch_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_write_notification_log_in_batch_args)
add_write_notification_log_in_batch_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [WriteNotificationLogBatchRequest, None],
        None,
    ),  # 1
)


class add_write_notification_log_in_batch_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WriteNotificationLogBatchResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_write_notification_log_in_batch_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_write_notification_log_in_batch_result)
add_write_notification_log_in_batch_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WriteNotificationLogBatchResponse, None],
        None,
    ),  # 0
)


class cm_recycle_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = CmRecycleRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("cm_recycle_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(cm_recycle_args)
cm_recycle_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [CmRecycleRequest, None],
        None,
    ),  # 1
)


class cm_recycle_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CmRecycleResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("cm_recycle_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(cm_recycle_result)
cm_recycle_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CmRecycleResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_file_metadata_by_expr_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetFileMetadataByExprRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_file_metadata_by_expr_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_file_metadata_by_expr_args)
get_file_metadata_by_expr_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetFileMetadataByExprRequest, None],
        None,
    ),  # 1
)


class get_file_metadata_by_expr_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetFileMetadataByExprResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_file_metadata_by_expr_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_file_metadata_by_expr_result)
get_file_metadata_by_expr_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetFileMetadataByExprResult, None],
        None,
    ),  # 0
)


class get_file_metadata_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_file_metadata_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_file_metadata_args)
get_file_metadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [GetFileMetadataRequest, None],
        None,
    ),  # 1
)


class get_file_metadata_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_file_metadata_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_file_metadata_result)
get_file_metadata_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetFileMetadataResult, None],
        None,
    ),  # 0
)


class put_file_metadata_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PutFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("put_file_metadata_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(put_file_metadata_args)
put_file_metadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [PutFileMetadataRequest, None],
        None,
    ),  # 1
)


class put_file_metadata_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PutFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("put_file_metadata_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(put_file_metadata_result)
put_file_metadata_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PutFileMetadataResult, None],
        None,
    ),  # 0
)


class clear_file_metadata_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = ClearFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("clear_file_metadata_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(clear_file_metadata_args)
clear_file_metadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [ClearFileMetadataRequest, None],
        None,
    ),  # 1
)


class clear_file_metadata_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ClearFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("clear_file_metadata_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(clear_file_metadata_result)
clear_file_metadata_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ClearFileMetadataResult, None],
        None,
    ),  # 0
)


class cache_file_metadata_args:
    """
    Attributes:
     - req

    """

    def __init__(
        self,
        req=None,
    ):
        self.req = req

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = CacheFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("cache_file_metadata_args")
        if self.req is not None:
            oprot.writeFieldBegin("req", TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(cache_file_metadata_args)
cache_file_metadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "req",
        [CacheFileMetadataRequest, None],
        None,
    ),  # 1
)


class cache_file_metadata_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CacheFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("cache_file_metadata_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(cache_file_metadata_result)
cache_file_metadata_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CacheFileMetadataResult, None],
        None,
    ),  # 0
)


class get_metastore_db_uuid_args:
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_metastore_db_uuid_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_metastore_db_uuid_args)
get_metastore_db_uuid_args.thrift_spec = ()


class get_metastore_db_uuid_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_metastore_db_uuid_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(self.success.encode("utf-8") if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_metastore_db_uuid_result)
get_metastore_db_uuid_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class create_resource_plan_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMCreateResourcePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_resource_plan_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_resource_plan_args)
create_resource_plan_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMCreateResourcePlanRequest, None],
        None,
    ),  # 1
)


class create_resource_plan_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMCreateResourcePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_resource_plan_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_resource_plan_result)
create_resource_plan_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMCreateResourcePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_resource_plan_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMGetResourcePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_resource_plan_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_resource_plan_args)
get_resource_plan_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMGetResourcePlanRequest, None],
        None,
    ),  # 1
)


class get_resource_plan_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMGetResourcePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_resource_plan_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_resource_plan_result)
get_resource_plan_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMGetResourcePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_active_resource_plan_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMGetActiveResourcePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_active_resource_plan_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_active_resource_plan_args)
get_active_resource_plan_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMGetActiveResourcePlanRequest, None],
        None,
    ),  # 1
)


class get_active_resource_plan_result:
    """
    Attributes:
     - success
     - o2

    """

    def __init__(
        self,
        success=None,
        o2=None,
    ):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMGetActiveResourcePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_active_resource_plan_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_active_resource_plan_result)
get_active_resource_plan_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMGetActiveResourcePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 1
)


class get_all_resource_plans_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMGetAllResourcePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_resource_plans_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_resource_plans_args)
get_all_resource_plans_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMGetAllResourcePlanRequest, None],
        None,
    ),  # 1
)


class get_all_resource_plans_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMGetAllResourcePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_resource_plans_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_resource_plans_result)
get_all_resource_plans_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMGetAllResourcePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class alter_resource_plan_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMAlterResourcePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_resource_plan_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_resource_plan_args)
alter_resource_plan_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMAlterResourcePlanRequest, None],
        None,
    ),  # 1
)


class alter_resource_plan_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMAlterResourcePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_resource_plan_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_resource_plan_result)
alter_resource_plan_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMAlterResourcePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class validate_resource_plan_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMValidateResourcePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("validate_resource_plan_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(validate_resource_plan_args)
validate_resource_plan_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMValidateResourcePlanRequest, None],
        None,
    ),  # 1
)


class validate_resource_plan_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMValidateResourcePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("validate_resource_plan_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(validate_resource_plan_result)
validate_resource_plan_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMValidateResourcePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_resource_plan_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMDropResourcePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_resource_plan_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_resource_plan_args)
drop_resource_plan_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMDropResourcePlanRequest, None],
        None,
    ),  # 1
)


class drop_resource_plan_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMDropResourcePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_resource_plan_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_resource_plan_result)
drop_resource_plan_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMDropResourcePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class create_wm_trigger_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMCreateTriggerRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_wm_trigger_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_wm_trigger_args)
create_wm_trigger_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMCreateTriggerRequest, None],
        None,
    ),  # 1
)


class create_wm_trigger_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMCreateTriggerResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_wm_trigger_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_wm_trigger_result)
create_wm_trigger_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMCreateTriggerResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [MetaException, None],
        None,
    ),  # 4
)


class alter_wm_trigger_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMAlterTriggerRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_wm_trigger_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_wm_trigger_args)
alter_wm_trigger_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMAlterTriggerRequest, None],
        None,
    ),  # 1
)


class alter_wm_trigger_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMAlterTriggerResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_wm_trigger_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_wm_trigger_result)
alter_wm_trigger_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMAlterTriggerResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class drop_wm_trigger_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMDropTriggerRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_wm_trigger_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_wm_trigger_args)
drop_wm_trigger_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMDropTriggerRequest, None],
        None,
    ),  # 1
)


class drop_wm_trigger_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMDropTriggerResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_wm_trigger_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_wm_trigger_result)
drop_wm_trigger_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMDropTriggerResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_triggers_for_resourceplan_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMGetTriggersForResourePlanRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_triggers_for_resourceplan_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_triggers_for_resourceplan_args)
get_triggers_for_resourceplan_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMGetTriggersForResourePlanRequest, None],
        None,
    ),  # 1
)


class get_triggers_for_resourceplan_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMGetTriggersForResourePlanResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_triggers_for_resourceplan_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_triggers_for_resourceplan_result)
get_triggers_for_resourceplan_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMGetTriggersForResourePlanResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class create_wm_pool_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMCreatePoolRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_wm_pool_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_wm_pool_args)
create_wm_pool_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMCreatePoolRequest, None],
        None,
    ),  # 1
)


class create_wm_pool_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMCreatePoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_wm_pool_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_wm_pool_result)
create_wm_pool_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMCreatePoolResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [MetaException, None],
        None,
    ),  # 4
)


class alter_wm_pool_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMAlterPoolRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_wm_pool_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_wm_pool_args)
alter_wm_pool_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMAlterPoolRequest, None],
        None,
    ),  # 1
)


class alter_wm_pool_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMAlterPoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_wm_pool_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_wm_pool_result)
alter_wm_pool_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMAlterPoolResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [MetaException, None],
        None,
    ),  # 4
)


class drop_wm_pool_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMDropPoolRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_wm_pool_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_wm_pool_args)
drop_wm_pool_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMDropPoolRequest, None],
        None,
    ),  # 1
)


class drop_wm_pool_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMDropPoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_wm_pool_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_wm_pool_result)
drop_wm_pool_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMDropPoolResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class create_or_update_wm_mapping_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMCreateOrUpdateMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_or_update_wm_mapping_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_or_update_wm_mapping_args)
create_or_update_wm_mapping_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMCreateOrUpdateMappingRequest, None],
        None,
    ),  # 1
)


class create_or_update_wm_mapping_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMCreateOrUpdateMappingResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_or_update_wm_mapping_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_or_update_wm_mapping_result)
create_or_update_wm_mapping_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMCreateOrUpdateMappingResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [MetaException, None],
        None,
    ),  # 4
)


class drop_wm_mapping_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMDropMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_wm_mapping_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_wm_mapping_args)
drop_wm_mapping_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMDropMappingRequest, None],
        None,
    ),  # 1
)


class drop_wm_mapping_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMDropMappingResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_wm_mapping_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_wm_mapping_result)
drop_wm_mapping_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMDropMappingResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class create_or_drop_wm_trigger_to_pool_mapping_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = WMCreateOrDropTriggerToPoolMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_or_drop_wm_trigger_to_pool_mapping_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_or_drop_wm_trigger_to_pool_mapping_args)
create_or_drop_wm_trigger_to_pool_mapping_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [WMCreateOrDropTriggerToPoolMappingRequest, None],
        None,
    ),  # 1
)


class create_or_drop_wm_trigger_to_pool_mapping_result:
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WMCreateOrDropTriggerToPoolMappingResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_or_drop_wm_trigger_to_pool_mapping_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_or_drop_wm_trigger_to_pool_mapping_result)
create_or_drop_wm_trigger_to_pool_mapping_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [WMCreateOrDropTriggerToPoolMappingResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [InvalidObjectException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [MetaException, None],
        None,
    ),  # 4
)


class create_ischema_args:
    """
    Attributes:
     - schema

    """

    def __init__(
        self,
        schema=None,
    ):
        self.schema = schema

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schema = ISchema()
                    self.schema.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_ischema_args")
        if self.schema is not None:
            oprot.writeFieldBegin("schema", TType.STRUCT, 1)
            self.schema.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_ischema_args)
create_ischema_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "schema",
        [ISchema, None],
        None,
    ),  # 1
)


class create_ischema_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_ischema_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_ischema_result)
create_ischema_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class alter_ischema_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AlterISchemaRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_ischema_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_ischema_args)
alter_ischema_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [AlterISchemaRequest, None],
        None,
    ),  # 1
)


class alter_ischema_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alter_ischema_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alter_ischema_result)
alter_ischema_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_ischema_args:
    """
    Attributes:
     - name

    """

    def __init__(
        self,
        name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = ISchemaName()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_ischema_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_ischema_args)
get_ischema_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "name",
        [ISchemaName, None],
        None,
    ),  # 1
)


class get_ischema_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ISchema()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_ischema_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_ischema_result)
get_ischema_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ISchema, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_ischema_args:
    """
    Attributes:
     - name

    """

    def __init__(
        self,
        name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = ISchemaName()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_ischema_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_ischema_args)
drop_ischema_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "name",
        [ISchemaName, None],
        None,
    ),  # 1
)


class drop_ischema_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_ischema_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_ischema_result)
drop_ischema_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class add_schema_version_args:
    """
    Attributes:
     - schemaVersion

    """

    def __init__(
        self,
        schemaVersion=None,
    ):
        self.schemaVersion = schemaVersion

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schemaVersion = SchemaVersion()
                    self.schemaVersion.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_schema_version_args")
        if self.schemaVersion is not None:
            oprot.writeFieldBegin("schemaVersion", TType.STRUCT, 1)
            self.schemaVersion.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_schema_version_args)
add_schema_version_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "schemaVersion",
        [SchemaVersion, None],
        None,
    ),  # 1
)


class add_schema_version_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_schema_version_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_schema_version_result)
add_schema_version_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class get_schema_version_args:
    """
    Attributes:
     - schemaVersion

    """

    def __init__(
        self,
        schemaVersion=None,
    ):
        self.schemaVersion = schemaVersion

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schemaVersion = SchemaVersionDescriptor()
                    self.schemaVersion.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_version_args")
        if self.schemaVersion is not None:
            oprot.writeFieldBegin("schemaVersion", TType.STRUCT, 1)
            self.schemaVersion.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_version_args)
get_schema_version_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "schemaVersion",
        [SchemaVersionDescriptor, None],
        None,
    ),  # 1
)


class get_schema_version_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SchemaVersion()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_version_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_version_result)
get_schema_version_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [SchemaVersion, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_schema_latest_version_args:
    """
    Attributes:
     - schemaName

    """

    def __init__(
        self,
        schemaName=None,
    ):
        self.schemaName = schemaName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schemaName = ISchemaName()
                    self.schemaName.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_latest_version_args")
        if self.schemaName is not None:
            oprot.writeFieldBegin("schemaName", TType.STRUCT, 1)
            self.schemaName.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_latest_version_args)
get_schema_latest_version_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "schemaName",
        [ISchemaName, None],
        None,
    ),  # 1
)


class get_schema_latest_version_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SchemaVersion()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_latest_version_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_latest_version_result)
get_schema_latest_version_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [SchemaVersion, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_schema_all_versions_args:
    """
    Attributes:
     - schemaName

    """

    def __init__(
        self,
        schemaName=None,
    ):
        self.schemaName = schemaName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schemaName = ISchemaName()
                    self.schemaName.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_all_versions_args")
        if self.schemaName is not None:
            oprot.writeFieldBegin("schemaName", TType.STRUCT, 1)
            self.schemaName.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_all_versions_args)
get_schema_all_versions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "schemaName",
        [ISchemaName, None],
        None,
    ),  # 1
)


class get_schema_all_versions_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1775, _size1772) = iprot.readListBegin()
                    for _i1776 in range(_size1772):
                        _elem1777 = SchemaVersion()
                        _elem1777.read(iprot)
                        self.success.append(_elem1777)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schema_all_versions_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1778 in self.success:
                iter1778.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schema_all_versions_result)
get_schema_all_versions_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [SchemaVersion, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class drop_schema_version_args:
    """
    Attributes:
     - schemaVersion

    """

    def __init__(
        self,
        schemaVersion=None,
    ):
        self.schemaVersion = schemaVersion

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schemaVersion = SchemaVersionDescriptor()
                    self.schemaVersion.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_schema_version_args")
        if self.schemaVersion is not None:
            oprot.writeFieldBegin("schemaVersion", TType.STRUCT, 1)
            self.schemaVersion.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_schema_version_args)
drop_schema_version_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "schemaVersion",
        [SchemaVersionDescriptor, None],
        None,
    ),  # 1
)


class drop_schema_version_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_schema_version_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_schema_version_result)
drop_schema_version_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_schemas_by_cols_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = FindSchemasByColsRqst()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schemas_by_cols_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schemas_by_cols_args)
get_schemas_by_cols_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [FindSchemasByColsRqst, None],
        None,
    ),  # 1
)


class get_schemas_by_cols_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindSchemasByColsResp()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_schemas_by_cols_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_schemas_by_cols_result)
get_schemas_by_cols_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [FindSchemasByColsResp, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class map_schema_version_to_serde_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = MapSchemaVersionToSerdeRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("map_schema_version_to_serde_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(map_schema_version_to_serde_args)
map_schema_version_to_serde_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [MapSchemaVersionToSerdeRequest, None],
        None,
    ),  # 1
)


class map_schema_version_to_serde_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("map_schema_version_to_serde_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(map_schema_version_to_serde_result)
map_schema_version_to_serde_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class set_schema_version_state_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = SetSchemaVersionStateRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_schema_version_state_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_schema_version_state_args)
set_schema_version_state_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [SetSchemaVersionStateRequest, None],
        None,
    ),  # 1
)


class set_schema_version_state_result:
    """
    Attributes:
     - o1
     - o2
     - o3

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("set_schema_version_state_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_schema_version_state_result)
set_schema_version_state_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [MetaException, None],
        None,
    ),  # 3
)


class add_serde_args:
    """
    Attributes:
     - serde

    """

    def __init__(
        self,
        serde=None,
    ):
        self.serde = serde

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.serde = SerDeInfo()
                    self.serde.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_serde_args")
        if self.serde is not None:
            oprot.writeFieldBegin("serde", TType.STRUCT, 1)
            self.serde.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_serde_args)
add_serde_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "serde",
        [SerDeInfo, None],
        None,
    ),  # 1
)


class add_serde_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_serde_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_serde_result)
add_serde_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [AlreadyExistsException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_serde_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = GetSerdeRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_serde_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_serde_args)
get_serde_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [GetSerdeRequest, None],
        None,
    ),  # 1
)


class get_serde_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SerDeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_serde_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_serde_result)
get_serde_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [SerDeInfo, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_lock_materialization_rebuild_args:
    """
    Attributes:
     - dbName
     - tableName
     - txnId

    """

    def __init__(
        self,
        dbName=None,
        tableName=None,
        txnId=None,
    ):
        self.dbName = dbName
        self.tableName = tableName
        self.txnId = txnId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.txnId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_lock_materialization_rebuild_args")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 2)
            oprot.writeString(self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.txnId is not None:
            oprot.writeFieldBegin("txnId", TType.I64, 3)
            oprot.writeI64(self.txnId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_lock_materialization_rebuild_args)
get_lock_materialization_rebuild_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I64,
        "txnId",
        None,
        None,
    ),  # 3
)


class get_lock_materialization_rebuild_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LockResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_lock_materialization_rebuild_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_lock_materialization_rebuild_result)
get_lock_materialization_rebuild_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [LockResponse, None],
        None,
    ),  # 0
)


class heartbeat_lock_materialization_rebuild_args:
    """
    Attributes:
     - dbName
     - tableName
     - txnId

    """

    def __init__(
        self,
        dbName=None,
        tableName=None,
        txnId=None,
    ):
        self.dbName = dbName
        self.tableName = tableName
        self.txnId = txnId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace") if sys.version_info[0] == 2 else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.txnId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("heartbeat_lock_materialization_rebuild_args")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 2)
            oprot.writeString(self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.txnId is not None:
            oprot.writeFieldBegin("txnId", TType.I64, 3)
            oprot.writeI64(self.txnId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(heartbeat_lock_materialization_rebuild_args)
heartbeat_lock_materialization_rebuild_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.I64,
        "txnId",
        None,
        None,
    ),  # 3
)


class heartbeat_lock_materialization_rebuild_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("heartbeat_lock_materialization_rebuild_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(heartbeat_lock_materialization_rebuild_result)
heartbeat_lock_materialization_rebuild_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class add_runtime_stats_args:
    """
    Attributes:
     - stat

    """

    def __init__(
        self,
        stat=None,
    ):
        self.stat = stat

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stat = RuntimeStat()
                    self.stat.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_runtime_stats_args")
        if self.stat is not None:
            oprot.writeFieldBegin("stat", TType.STRUCT, 1)
            self.stat.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_runtime_stats_args)
add_runtime_stats_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "stat",
        [RuntimeStat, None],
        None,
    ),  # 1
)


class add_runtime_stats_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_runtime_stats_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_runtime_stats_result)
add_runtime_stats_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_runtime_stats_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = GetRuntimeStatsRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_runtime_stats_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_runtime_stats_args)
get_runtime_stats_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [GetRuntimeStatsRequest, None],
        None,
    ),  # 1
)


class get_runtime_stats_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1782, _size1779) = iprot.readListBegin()
                    for _i1783 in range(_size1779):
                        _elem1784 = RuntimeStat()
                        _elem1784.read(iprot)
                        self.success.append(_elem1784)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_runtime_stats_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1785 in self.success:
                iter1785.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_runtime_stats_result)
get_runtime_stats_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [RuntimeStat, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_partitions_with_specs_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetPartitionsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_with_specs_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_with_specs_args)
get_partitions_with_specs_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GetPartitionsRequest, None],
        None,
    ),  # 1
)


class get_partitions_with_specs_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPartitionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_partitions_with_specs_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_partitions_with_specs_result)
get_partitions_with_specs_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetPartitionsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class scheduled_query_poll_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ScheduledQueryPollRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("scheduled_query_poll_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scheduled_query_poll_args)
scheduled_query_poll_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [ScheduledQueryPollRequest, None],
        None,
    ),  # 1
)


class scheduled_query_poll_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ScheduledQueryPollResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("scheduled_query_poll_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scheduled_query_poll_result)
scheduled_query_poll_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ScheduledQueryPollResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class scheduled_query_maintenance_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ScheduledQueryMaintenanceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("scheduled_query_maintenance_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scheduled_query_maintenance_args)
scheduled_query_maintenance_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [ScheduledQueryMaintenanceRequest, None],
        None,
    ),  # 1
)


class scheduled_query_maintenance_result:
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """

    def __init__(
        self,
        o1=None,
        o2=None,
        o3=None,
        o4=None,
    ):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("scheduled_query_maintenance_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin("o3", TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin("o4", TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scheduled_query_maintenance_result)
scheduled_query_maintenance_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o3",
        [AlreadyExistsException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "o4",
        [InvalidInputException, None],
        None,
    ),  # 4
)


class scheduled_query_progress_args:
    """
    Attributes:
     - info

    """

    def __init__(
        self,
        info=None,
    ):
        self.info = info

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = ScheduledQueryProgressInfo()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("scheduled_query_progress_args")
        if self.info is not None:
            oprot.writeFieldBegin("info", TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scheduled_query_progress_args)
scheduled_query_progress_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "info",
        [ScheduledQueryProgressInfo, None],
        None,
    ),  # 1
)


class scheduled_query_progress_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("scheduled_query_progress_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scheduled_query_progress_result)
scheduled_query_progress_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [InvalidOperationException, None],
        None,
    ),  # 2
)


class get_scheduled_query_args:
    """
    Attributes:
     - scheduleKey

    """

    def __init__(
        self,
        scheduleKey=None,
    ):
        self.scheduleKey = scheduleKey

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scheduleKey = ScheduledQueryKey()
                    self.scheduleKey.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_scheduled_query_args")
        if self.scheduleKey is not None:
            oprot.writeFieldBegin("scheduleKey", TType.STRUCT, 1)
            self.scheduleKey.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_scheduled_query_args)
get_scheduled_query_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "scheduleKey",
        [ScheduledQueryKey, None],
        None,
    ),  # 1
)


class get_scheduled_query_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ScheduledQuery()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_scheduled_query_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_scheduled_query_result)
get_scheduled_query_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ScheduledQuery, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class add_replication_metrics_args:
    """
    Attributes:
     - replicationMetricList

    """

    def __init__(
        self,
        replicationMetricList=None,
    ):
        self.replicationMetricList = replicationMetricList

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.replicationMetricList = ReplicationMetricList()
                    self.replicationMetricList.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_replication_metrics_args")
        if self.replicationMetricList is not None:
            oprot.writeFieldBegin("replicationMetricList", TType.STRUCT, 1)
            self.replicationMetricList.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_replication_metrics_args)
add_replication_metrics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "replicationMetricList",
        [ReplicationMetricList, None],
        None,
    ),  # 1
)


class add_replication_metrics_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_replication_metrics_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_replication_metrics_result)
add_replication_metrics_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_replication_metrics_args:
    """
    Attributes:
     - rqst

    """

    def __init__(
        self,
        rqst=None,
    ):
        self.rqst = rqst

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = GetReplicationMetricsRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_replication_metrics_args")
        if self.rqst is not None:
            oprot.writeFieldBegin("rqst", TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_replication_metrics_args)
get_replication_metrics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "rqst",
        [GetReplicationMetricsRequest, None],
        None,
    ),  # 1
)


class get_replication_metrics_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReplicationMetricList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_replication_metrics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_replication_metrics_result)
get_replication_metrics_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ReplicationMetricList, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_open_txns_req_args:
    """
    Attributes:
     - getOpenTxnsRequest

    """

    def __init__(
        self,
        getOpenTxnsRequest=None,
    ):
        self.getOpenTxnsRequest = getOpenTxnsRequest

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.getOpenTxnsRequest = GetOpenTxnsRequest()
                    self.getOpenTxnsRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_open_txns_req_args")
        if self.getOpenTxnsRequest is not None:
            oprot.writeFieldBegin("getOpenTxnsRequest", TType.STRUCT, 1)
            self.getOpenTxnsRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_open_txns_req_args)
get_open_txns_req_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "getOpenTxnsRequest",
        [GetOpenTxnsRequest, None],
        None,
    ),  # 1
)


class get_open_txns_req_result:
    """
    Attributes:
     - success

    """

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetOpenTxnsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_open_txns_req_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_open_txns_req_result)
get_open_txns_req_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetOpenTxnsResponse, None],
        None,
    ),  # 0
)


class create_stored_procedure_args:
    """
    Attributes:
     - proc

    """

    def __init__(
        self,
        proc=None,
    ):
        self.proc = proc

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.proc = StoredProcedure()
                    self.proc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_stored_procedure_args")
        if self.proc is not None:
            oprot.writeFieldBegin("proc", TType.STRUCT, 1)
            self.proc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_stored_procedure_args)
create_stored_procedure_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "proc",
        [StoredProcedure, None],
        None,
    ),  # 1
)


class create_stored_procedure_result:
    """
    Attributes:
     - o1
     - o2

    """

    def __init__(
        self,
        o1=None,
        o2=None,
    ):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("create_stored_procedure_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_stored_procedure_result)
create_stored_procedure_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [NoSuchObjectException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [MetaException, None],
        None,
    ),  # 2
)


class get_stored_procedure_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = StoredProcedureRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_stored_procedure_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_stored_procedure_args)
get_stored_procedure_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [StoredProcedureRequest, None],
        None,
    ),  # 1
)


class get_stored_procedure_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StoredProcedure()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_stored_procedure_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_stored_procedure_result)
get_stored_procedure_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [StoredProcedure, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class drop_stored_procedure_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = StoredProcedureRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_stored_procedure_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_stored_procedure_args)
drop_stored_procedure_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [StoredProcedureRequest, None],
        None,
    ),  # 1
)


class drop_stored_procedure_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_stored_procedure_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_stored_procedure_result)
drop_stored_procedure_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_all_stored_procedures_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ListStoredProcedureRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_stored_procedures_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_stored_procedures_args)
get_all_stored_procedures_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [ListStoredProcedureRequest, None],
        None,
    ),  # 1
)


class get_all_stored_procedures_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1789, _size1786) = iprot.readListBegin()
                    for _i1790 in range(_size1786):
                        _elem1791 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1791)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_stored_procedures_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1792 in self.success:
                oprot.writeString(iter1792.encode("utf-8") if sys.version_info[0] == 2 else iter1792)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_stored_procedures_result)
get_all_stored_procedures_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class find_package_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetPackageRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_package_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_package_args)
find_package_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GetPackageRequest, None],
        None,
    ),  # 1
)


class find_package_result:
    """
    Attributes:
     - success
     - o1
     - o2

    """

    def __init__(
        self,
        success=None,
        o1=None,
        o2=None,
    ):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Package()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("find_package_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin("o2", TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(find_package_result)
find_package_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Package, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "o2",
        [NoSuchObjectException, None],
        None,
    ),  # 2
)


class add_package_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = AddPackageRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_package_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_package_args)
add_package_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [AddPackageRequest, None],
        None,
    ),  # 1
)


class add_package_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("add_package_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_package_result)
add_package_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_all_packages_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ListPackageRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_packages_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_packages_args)
get_all_packages_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [ListPackageRequest, None],
        None,
    ),  # 1
)


class get_all_packages_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1796, _size1793) = iprot.readListBegin()
                    for _i1797 in range(_size1793):
                        _elem1798 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem1798)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_packages_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1799 in self.success:
                oprot.writeString(iter1799.encode("utf-8") if sys.version_info[0] == 2 else iter1799)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_packages_result)
get_all_packages_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class drop_package_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = DropPackageRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_package_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_package_args)
drop_package_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [DropPackageRequest, None],
        None,
    ),  # 1
)


class drop_package_result:
    """
    Attributes:
     - o1

    """

    def __init__(
        self,
        o1=None,
    ):
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("drop_package_result")
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(drop_package_result)
drop_package_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)


class get_all_write_event_info_args:
    """
    Attributes:
     - request

    """

    def __init__(
        self,
        request=None,
    ):
        self.request = request

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetAllWriteEventInfoRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_write_event_info_args")
        if self.request is not None:
            oprot.writeFieldBegin("request", TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_write_event_info_args)
get_all_write_event_info_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "request",
        [GetAllWriteEventInfoRequest, None],
        None,
    ),  # 1
)


class get_all_write_event_info_result:
    """
    Attributes:
     - success
     - o1

    """

    def __init__(
        self,
        success=None,
        o1=None,
    ):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1803, _size1800) = iprot.readListBegin()
                    for _i1804 in range(_size1800):
                        _elem1805 = WriteEventInfo()
                        _elem1805.read(iprot)
                        self.success.append(_elem1805)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("get_all_write_event_info_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1806 in self.success:
                iter1806.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin("o1", TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["{}={!r}".format(key, value) for key, value in self.__dict__.items()]
        return "{}({})".format(self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_all_write_event_info_result)
get_all_write_event_info_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [WriteEventInfo, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "o1",
        [MetaException, None],
        None,
    ),  # 1
)
fix_spec(all_structs)
del all_structs
